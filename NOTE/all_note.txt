没有git的安装 git

准备软件  git clone git://43.254.90.134/nsd1903.git
         cd nsd1903/
         git pull  //同步
         eip 100 修改IP地址(老师写的jue本)
         vim /etc/
环境介绍  修改专用的虚拟机模板
      修改文件   /etc/clone.conf
      适合旧版本的 教学系统
      clone-vm7
      新版本 系统
      base-vm
      账户root
      密码a

DAY01 云平台的部署与管理
一.虚拟化
        1.1 介绍
            vmware(linux才是本体) 和 kvm(redhat)  rhev(redhat)

            vmware(window软件)= esxi+vcenter

            esxi= linux+ vm (虚拟化软件)
            vcenter  管理软件(Windows)

        1.2 安装虚拟化服务器平台
            KVM/QEMU/LIBVIRTD
            kvm是linux一个内核的模块,需要cpu支持, intel-vt/ amd-v 内存 ept / rvi

            QEMU  虚拟化仿真工具 通过ioctl与内核kvm交互完成虚拟化硬件支持

            libvirtd 是一个对虚拟化管理接口和工具  提供用户程序  virsh virt-install virt-manager virt-view

            lsmod 列出所有的内核模块
            ps -efww -ef显示进程 ww显示完整的信息

        1.3 必备软件
            qemu-kvm
            libvirt-daemon  //libvirtd 后台守护进程
            libvirt-client //客户端软件 提供客户端管理命令
            libvirt-daemon-driver-qemu  //libvirtd 链接qemu驱动

        1.4 kvm虚拟机的组成
            内核虚拟化模块  KVM
            系统设备仿真    QEMU
            虚拟机管理程序  LIBVIRT

            两部分构成
            配置文件位置  /etc/libvirt/qemu/
            磁盘镜像文件位置  /var/lib/libvirt/images/
二.virsh 管理
        2.1 virsh命令介绍

            提供管理虚拟机的命令借口
            -支持交互模式 ,查看/创建/停止/关闭
            -格式 : virsh 控制命令 [虚拟机名] 参数


            虚拟机控制
            
            -list[-all]  列出虚拟机
            -start|shutdown|reboot 虚拟机停止 重启 (正常关机)
            -destroy 强制停止虚拟机 //拔电源
            -define|undefine 根据 xml文件创建/删除虚拟机
            -console 链接虚拟机的console
            -resert  重置虚拟机
            虚拟机管理

            -edit       修改虚拟机配置  //修改完成直接生效,不推荐使用vim打开(需要重启生效)
            -autostart  设置虚拟机自启动
            -domiflist  查看虚拟机网卡
            -domblklist 查看虚拟机磁盘信息

            虚拟网络管理
            -net-list[-all]
            -net-start 启动虚拟交换机
            -net-destroy 强制关闭虚拟交换机
            -net-define  创建虚拟交换机
            -net-undefine 删除虚拟交换机
            -net-edit    修改虚拟交换机配置文件
            -net-autostart 开机自启



             eg:
                ~]$ virsh list --all //非交互
                [student@room9pc01 ~]$ virsh
                欢迎使用 virsh，虚拟化的交互式终端。

                输入：'help' 来获得命令的帮助信息
                       'quit' 退出

                virsh # list
                 Id    名称                         状态
                ----------------------------------------------------
                 1     mysql_22_slave                 running
                 2     mysql_11_master                running
                 3     monitor55                      running
                 4     tedu_node002                   running

                只有链接到同一个虚拟交换机的虚拟机是可以互通的(配置同网段ip)
                ~]$ virsh domiflist tedu_node002 //查看当前主机链接的虚拟交换机
                接口     类型     源        型号      MAC
                -------------------------------------------------------
                vnet12     bridge     vbr        virtio      52:54:00:67:fc:90

                 ~]$ virsh domblklist tedu_node002   //查看当前虚拟机的磁盘信息
                目标     源
                ------------------------------------------------
                vda        /var/lib/libvirt/images/tedu_node002.img

        2.2 常用磁盘镜像类型

            RAW(物理磁盘)  QCOW2(用多少写多少)
            qcow2 核心: copy on write 技术

            qemu-img 是虚拟机记得磁盘管理指令,支持非常多的磁盘格式

            qemu-img  命令 阐述 块文件名称 大小

            常用命令
                -create 创建磁盘
                -convert 转换磁盘格式
                -info   查看磁盘信息
                -resize 扩容磁盘空间
            选项:
                -f 指定文件系统
                -f qcow2
                -b 指定后端盘
                -b node.img
                eg:
                     查看磁盘文件信息/
                     1 ~]$  qemu-img info  /var/lib/libvirt/images/tedu_node002.img
                            image: /var/lib/libvirt/images/tedu_node002.img
                            file format: qcow2
                            virtual size: 20G (21474836480 bytes)
                            disk size: 25M
                            cluster_size: 65536
                            backing file: /var/lib/libvirt/images/.node_base.qcow2
                            Format specific information:
                                compat: 1.1
                                lazy refcounts: false

                     创建 -f 指定磁盘文件类型 50G表示最大可容量
                      ~]$ qemu-img create -f qcow2 ./f1.img 50G
                          Formatting './f1.img', fmt=qcow2 size=53687091200 encryption=off cluster_size=65536 lazy_refcounts=off

                     创建教学系统中创建虚拟机使用的前端盘
                          这里使用的后端盘可以由我们自己全新安装,配置完成后 img 文件 就是这里使用的模板(这里需要取消虚拟机定义,修改为qcow2)
                          //查找虚拟机的前端盘

                          ~]$ virsh domblklist tedu_node002
                                目标     源
                                ------------------------------------------------
                                vda        /var/lib/libvirt/images/tedu_node002.img


                          //查找后端盘
                          ~]$ qemu-img info /var/lib/libvirt/images/tedu_node002.img

                                image: /var/lib/libvirt/images/tedu_node002.img
                                file format: qcow2
                                virtual size: 20G (21474836480 bytes)
                                disk size: 9.6M
                                cluster_size: 65536
                                backing file: /var/lib/libvirt/images/.node_base.qcow2  //后端磁盘文件
                                Format specific information:
                                    compat: 1.1
                                    lazy refcounts: false

                          ~]$ cd /var/lib/libvirt/images
                          //创建前端盘
                          记得删除旧的前端盘
                          images]$ qemu-img create -f qcow2 ./tedu_node002.img -b /var/lib/libvirt/images/.node_base.qcow2  20G

                          使用后端盘创建镜像
                                qemu-img create -b 后端模板文件 -f 格式  磁盘路径  大小

        2.3 virsh 管理

            xml 文件管理
                命令 virsh edit 主机名

                eg:修改如下
                    virsh  edit tedu_node002.
                      <memory unit='KiB'>4588282</memory>   //最大内存
                      <currentMemory unit='KiB'>4588282</currentMemory>  //当前内存
                      <vcpu placement='static'>4</vcpu>  //cpu个数
                      <disk type='file' device='disk'>
                      <source file='/var/lib/libvirt/images/tedu_node002.img'/>  //磁盘
                      <interface type='bridge'>
                      <source bridge='vbr'/> //链接的虚拟交换机

                创建虚拟机

                    创建虚拟机前端盘

                        qemu-img create -f qcow2 /var/lib/libvirt/images/nsd1903.img -b /var/lib/libvirt/images/.node_base.qcow2 30G

                    创建虚拟机配置文件
                        cp /var/lib/libvirt/images/.node_base.xml /etc/libvirt/qemu/nsd1903.xml
                        vim /etc/libvirt/qemu/nsd1903.xml
                        修改为  <name>nsd1903</name>
                               <source file='/var/lib/libvirt/images/nsd1903.img'/>
                    定义虚拟机
                        virsh define /etc/libvirt/qemu/nsd1903.xml
                    开机
                        virsh start nsd1903

            网卡机器配置文件
                /etc/sysconfig/network-scripts/xxx xx主机名





            virsh 扩容硬盘

                virsh domblklist 主机名
                //扩容硬盘
                virsh blockresize --path [绝对路径] -- size xxG 主机名

                思路:
                    先扩容磁盘
                    扩容分区
                    扩容文件系统
            eg:扩容nsd1903 虚拟机
                物理机
                virsh domblklist nsd1903
                virsh blockresize --path /var/lib/libvirt/images/nsd1903.img --size 50G nsd1903

                虚拟机nsd1903
                LANG=en growpart /dev/vda 1
                xfs_growfs /dev/vda1
                df -h



三.云平台
        3.1 云平台介绍
            IaaS (infrastructure  as a service) 基础设置即服务

                iaas 通常分为 公有云(全部托管) 私有云(自建机房) 和 混合云(两种混合)
                提供给消费者所有云计算的基础设施,包括处理cpu 内存 存储 网络
            PaaS (Platform as a service)平台即服务
                不仅仅是单充的基础平台,还针对平台的技术支持服务,对于平台进行的应用系统开发优化等服务
            SaaS (software as a service )软件即服务
                通过internet提供软件(软件商店)
        3.2 openstack 简介

            iaas 解决方案
            开源的云计算管理平台
            Apache 授权
四.华为云

        基于openstack 开发而来的



DAY02 OPENSTACK
一.openstack
    基于python开发

    每个版本命令都可能不太一样,一般我们通过web页面来管理.
    每年2个大版本的更新
        1.1 openstack主要组件(核心组件)
            Horizon
                用于管理openstack的各种服务,基于web的管理接口
                通过图形界面实现创建用户.管理网络 启动实例

                dashborad python页面的解释器

            Keystack
                组件之
                间的认证
                提供了集中的目录服务
                也支持多种身份认证模式, 如密码 令牌 aws登录
                为用户提供其他服务提供sso认证服务

                验证谁是horizon

            Neutron
                一种软件定义的网络服务
                用于创建网络 子网 路由器 管理浮动 ip
                可以实现虚拟交换机 虚拟路由器
                可用于在项目中创建vpn
                (虚拟扩展局域网)
                通过(vxlan[扩展vlan]解决)
                不同公司之间需要隔离,相同公司之间需要通信
                所有安装 nova的机器上都要安装
                    VXLAN在云数据中心之间虚拟机迁移中的应用，如某个企业在不同的数据中心有不同业务应用的虚拟机，数据中心之间虚拟机迁移是经常会遇到的，
                    为了保证虚拟机迁移过程中业务不中断，则需要保证迁移虚拟机的IP地址、MAC地址等参数保持不变，这就要求虚拟机迁移前后属于统一个二层网络。
                    参考
                        https://bbs.hh010.com/thread-571168-1-1.html?_dsign=fc065a39
                        https://www.jianshu.com/p/cccfb481d548
            Cinder
                为虚拟机提供存储卷的服务
                为运行的Nova中的实例提供永久的块存储
                可以通过快照进行数据备份
                经常应用在实例存储环境中,如数据文件


            Glance
                扮演虚拟机镜像注册的角色
                允许用户为直接存储拷贝服务器镜像
                这些镜像可以直接用来创建新的虚拟机模板

                qcow2(后端盘)
            Nova
                在节点上用于管理虚拟机的服务
                Nova是一个分布式的服务,能够与keystone交互实现认证,与Glance交互实现镜像管理
                Nova被设计在成标准硬件上能够进行水平扩展
                启动实例,有需要则下载镜像

                除了安装 Horizon 的机器都要安装

            master :
                   Neutron  Horizon
            slave:
                  Nova    Neutron   Keystack

            机器的准备 :  卸载 networkmanager 和 防火墙(iptables/Firewalls)

        1.2  安装openstack

            准备三台虚拟机
                使用base模板 虚拟机
                openstack RAM 6G  disk 50G
                nova01  RAM 4.5G  disk 100G
                nova02  RAM 4.5G  disk 100G

            更改 ip

                vim /etc/sysconfig/network-scripts/ifcfg-eth0
                # Generated by dracut initrd
                DEVICE="eth0"
                ONBOOT="yes"
                NM_CONTROLLED="no"
                TYPE="Ethernet"
                BOOTPROTO="static"
                PERSISTENT_DHCLIENT="yes"
                IPADDR="192.168.1.10"  // 11 //12
                NETMASK="255.255.255.0"
                GATEWAY="192.168.1.254"

            修改hosts文件并检查是否可以相互ping同
                vim /etc/hosts
                192.168.1.10 openstack
                192.168.1.11 nova_01
                192.168.1.12 nova_02


            修改DNS
                 vim /etc/resolv.conf
                    #search localhost   //注释掉这一行
            同步时间

                vim /etc/chrony.conf

                    server 192.168.1.254 iburst
                    systemctl restart chronyd.service

                    测试 chronyc sources -v/timedatectl   ###ntp时间同步测试

            检查防火墙和networkmanager 是否安装

                若安装必须卸载
                68  rpm -qa | grep firewall
                69  rpm -qa | grep -i networkmanager



            配置对应的yum源软件已经在 linux-soft中提供

                /linux-soft/04/openstack/
                    RHEL7-extras.iso  RHEL7OSP-10.iso
                分别将上面的两个iso文件 挂载到 ftp下对应的文件夹中
                /var/ftp/extras
                /var/ftp/openstack

                在openstack中我们只需要 如下两个仓库
                 /var/ftp/openstack/rhel-7-server-openstack-10-devtools-rpms/
                 /var/ftp/openstack/rhel-7-server-openstack-10-rpms/
                将上面的仓库配置为yum源并检查
                    [openstack1]
                    name=ops1
                    baseurl="ftp://192.168.1.254/openstack/rhel-7-server-openstack-10-rpms"
                    enabled=1
                    gpgcheck=0

                    [openstack2]
                    name=ops2
                    baseurl="ftp://192.168.1.254/openstack/rhel-7-server-openstack-10-devtools-rpms"
                    enabled=1
                    gpgcheck=0

                    [extarts]
                    name=extars
                    baseurl="ftp://192.168.1.254/extras"
                    enabled=1
                    gpgcheck=0


            检查上面修改是否准确修改

                安装额外的软件包
                是否卸载firewalld 和 NetworkManager
                检查配置主机网络参数（静态IP）
                主机名必须能够相互 ping 通
                检查配置主机yum源（4个，10670）
                依赖软件包是否安装
                检查NTP服务器是否可用
                检查 /etc/resolv.conf 不能有 search 开头的行



            安装 packstack

                安装依赖软件 (三台都要安装)
                yum install -y qemu-kvm libvirt-client libvirt-daemon libvirt-daemon-driver-qemu python-setuptools

                packstack --gen-answer-file answer.ini   //生成应答文件

                //answer.ini与answer.txt是一样的，只是用vim打开answer.ini文件有颜色
                Packstack changed given value  to required value /root/.ssh/id_rsa.pub
                [root@openstack ~]# vim answer.ini
                42  CONFIG_SWIFT_INSTALL=n
                45  CONFIG_CEILOMETER_INSTALL=n                   //计费相关模块
                49  CONFIG_AODH_INSTALL=n                         //计费相关模块
                53  CONFIG_GNOCCHI_INSTALL=n                     //计费相关模块
                75  CONFIG_NTP_SERVERS=192.168.1.254   //时间服务器的地址
                98  CONFIG_COMPUTE_HOSTS=192.168.1.11
                102 CONFIG_NETWORK_HOSTS=192.168.1.10,192.168.1.11
                 333 CONFIG_KEYSTONE_ADMIN_PW=a     //修改管理员的密码
                840 CONFIG_NEUTRON_ML2_TYPE_DRIVERS=flat,vxlan   //驱动类型
                 876 CONFIG_NEUTRON_ML2_VXLAN_GROUP=239.1.1.5
                //设置组播地址,最后一个随意不能为0和255,其他固定
                 910 CONFIG_NEUTRON_OVS_BRIDGE_MAPPINGS=physnet1:br-ex  //物理网桥的名称
                 921 CONFIG_NEUTRON_OVS_BRIDGE_IFACES=br-ex:eth0
                //br-ex桥的名称与eth0连接，管理eth0,网桥与哪个物理网卡连接
                1179 CONFIG_PROVISION_DEMO=n   //DEMO是否测试
                 [root@openstack ~]# packstack --answer-file=answer.ini  //安装openstack
                Welcome to the Packstack setup utility
                The installation log file is available at: /var/tmp/packstack/20190423-170603-b43g_i/openstack-setup.log
                Installing:
                Clean Up                                             [ DONE ]
                Discovering ip protocol version                      [ DONE ]
                root@192.168.1.11's password:
                root@192.168.1.10's password:
                Setting up ssh keys
                **** Installation completed successfully ******        //出现这个为成功

                ************************************************************
                过程中出现错误请检查 硬盘 容量 足够 ,yum,依赖软件是否安装,dns,ip,ntp等.


            网络管理
                我们在虚拟机上查看网卡实际上查看的是真机上虚拟出来的虚拟交换机的端口,虚拟机之间通信都是通过虚拟交换机转发.
                查看外部OVS网桥

                    1）查看br-ex网桥配置（br-ex为OVS网桥设备）
                        [root@openstack ~]# cat /etc/sysconfig/network-scripts/ifcfg-br-ex
                        ONBOOT="yes"
                        NM_CONTROLLED="no"
                        IPADDR="192.168.1.10"
                        PREFIX=24
                        GATEWAY=192.168.1.254
                        DEVICE=br-ex
                        NAME=br-ex
                        DEVICETYPE=ovs
                        OVSBOOTPROTO="static"
                        TYPE=OVSBridge
                    2）查看eth0网卡配置（该网卡为OVS网桥的接口）
                        [root@openstack ~]# cat /etc/sysconfig/network-scripts/ifcfg-eth0
                        DEVICE=eth0
                        NAME=eth0
                        DEVICETYPE=ovs
                        TYPE=OVSPort
                        OVS_BRIDGE=br-ex
                        ONBOOT=yes
                        BOOTPROTO=none
                    3）验证OVS配置
                        [root@openstack ~]# ovs-vsctl show
                            Bridge br-ex
                                Controller "tcp:127.0.0.1:6633"
                                    is_connected: true
                                fail_mode: secure
                                Port br-ex
                                    Interface br-ex
                                        type: internal
                                Port phy-br-ex
                                    Interface phy-br-ex
                                        type: patch
                                        options: {peer=int-br-ex}
                                Port "eth0"
                                    Interface "eth0"
                            ovs_version: "2.5.0"


            修改/etc/httpd/conf.d/15-horizon_vhost.conf 配置文件，使其可以成功登录openstack
                在WSGIProcessGroup apache下
                添加如下
                WSGIApplicationGroup %{GLOBAL}
                重启httpd或者重新载入配置文件
                apachectl  graceful  //重新载入配置文件
            访问1.10登录


    DAY03
        openstack项目管理
            之前版本把项目也叫做租户
            openstack的一切管理都是从项目开始
                项目的目的是分配资源
                项目的资源是按照 需求的总数划分的 比如 多少核cpu 多少内存 多少储存 带宽的等(具体的划分可以由客户自己分配)

            项目管理员
                授权用户时,角色确认为member,admin是openstack的管理用户,并且必主选项目.


                在openstack 数据库中的 kyesstone.user 记录用户信息
                MariaDB [keystone]>  select * from user;

                在master主机上 查看
                 ~]# source keystonerc_admin //加载认证信息
                ~(keystone_admin)]# openstack user list //显示用户
                    +----------------------------------+---------+
                    | ID                               | Name    |
                    +----------------------------------+---------+

                 ~(keystone_admin)]# openstack user set --password aa uu   //修改普通用户的密码, 先写新密码 再写用户名

            修改管理员密码

                 ~]# source keystonerc_admin //加载认证信息
                 ~(keystone_admin)]# openstack user set --password aa admin

            破解openstack管理员密码
                 ~]# vim token
                        export OS_TOKEN=262b214a14ac4bdeb72999f1d824b1c9 ### 在/etc/keystone/keystone.conf 中找到 18 行 的数据 将这里的替换
                        export OS_URL=http://127.0.0.1:35357/v2.0
                        export OS_INDETITY_API_VERSION=2

                 ~]# source token
                 ~]# source  keystonerc_admin
                ~(keystone_admin)]# openstack user set --password gaoyuan admin



            云主机类型

                也叫作资源模板

            计算节点扩容
                删除已经创建的虚拟主机(openstack中),原因内存不够

                修改 answer.ini 98/102 添加 nova_02的ip地址

                安装
                    packstack --answer-file=answer.ini



                修改httpd 下的 15-horizon_vhost.conf
                    vim /etc/httpd/conf.d/15-horizon_vhost.conf

                    内容参考,第一次安装
                    WSGIProcessGroup apache
                    WSGIApplicationGroup %{GLOBAL}
                重启httpd
                    apachectl graceful/systemctl restarthttpd


            主机迁移

                迁移必须使用 openstack的管理账号迁移,迁移过程中不影响业务.

                迁移条件
                        -nova节点与openstack管理节点都能互相ping通 主机名也要可以ping通
                        所有计算节点安装 qemu-img-rhev,qemu-kvm-rhev
                        若位安装,在安装后需要重启libvirtd服务


    DAY04
        一.docker
            docker 是使用go语言编写
            Go 编译生成的是一个静态可执行文件,除了 glibc 外没有其他外部依赖,这让部署变得异常方便.
            参考:
            https://www.cnblogs.com/bethal/p/5942369.html
            镜像在没有运行起来之前只是镜像,运行起来后就可以称为 容器.
            要点：容器 = 镜像 + 可读层。并且容器的定义并没有提及是否要运行容器。
            docker 是 一个容器管理工具
            1.1什么是容器

                容器技术已经成为应用分装和交付的核心技术
                容器的核心组成需要一下三个内核技术组成
                    Cgroups (control Groups) 资源管理
                    NameSpace 进程隔离
                        (依靠内核的进程隔离机制,
                         主机名隔离,网络隔离,
                         文件系统隔离,
                         用户隔离,
                         信号向量隔离(kiall)-杀进程只能杀docker里面的进程对本机无影响)
                    selinux 安全

                我们在虚拟机上查看网卡实际上查看的是真机上虚拟出来的虚拟交换机的端口,虚拟机之间通信都是通过虚拟交换机转发.
                由于是在物理机器上实施隔离,所以启动一个容器会非常快(如同启动进程).
            1.2 docker

                docker是一套完整的容器管理系统
                docker提供了一组完整的命令,用户方便的直接使用容器,不需要过多的关系内核

                docker 优点
                    容器更加简介高效,相比传统的虚拟化
                    传统虚拟机需要给每个vm安装os,容器直接使用本机的系统
                    容器使用的共享库和程序(与真机共享)
                docker 缺点
                    容器的隔离性没有虚拟化强
                    共用 linux内核,先天性安全缺点
                    selinux难以控制
                    监控容器和容器排除是挑战

                    需要内核支持
            1.3准备

                需要64为系统

                rhel6.5以上,推荐rhel7 (内核3.x以上;;;2.6.32-431)

                关闭防火墙(不必要)

                YUM 源使用openstack 即可

                yum -y install docker
            1.4 docker镜像
                    由于qcow2的 特性 我们创建的的qcow2 是可以堆叠的.
                    我们教学环境中最基础的是.node_base.qcow2

                    牛老师.node_tedu.qcow2 后端盘指向 base

                docker容器基于镜像启动
                镜像是启动容器的核心
                镜像采用分层设计
                使用快照的cow技术,确保底层数据不丢失

                docker hub 镜像仓库
                    镜像由 name和tag确定唯一的
                由docker 官方提供 镜像仓库
                ~]# docker images //查看docker 镜像,管理不要手动管理,使用命令
                ~]# docker search busybox  //查找镜像 搜索镜像
                ~]# docker pull            //下载
                    docker pull [OPTIONS] NAME[:TAG|@DIGEST]
                    下载位置 /var/lib/docker/image/devicemapper/layerdb/sha256

                ~]# docker push            //上传
                    docker push [OPTIONS] NAME[:TAG]
                ~]# docker save                          //导出镜像
                    docker save [OPTIONS] IMAGE [IMAGE...]       //导出镜像  不是创建自定义镜像
                ~]# docker save docker.io/busybox:latest -o busybox.tar  //:lasts 是tag,-o outpu  t

                ~]# docker  load   //导入镜像
                    Usage:	docker load [OPTIONS]
                ~]# docker load  -i busybox.tar/  -i input
                导入失败:停止docker 删除下/var/lib/docker/的所有,重启服务,重新导入

            1.5开启容器

                 ~]# docker run -it docker.io/centos:latest  /bin/bash

                    /bin/bash 指需要启动的命令,不指定表示按照默认启动(只在容器中有效)
                    对于服务镜像的启动(交互),放置在前台,非交互(数据库,nginx)放置后台.

            1.6查看容器

                ~]# docker ps -a //查看所有的容器 -a显示所有 -q只显示容器id,
                ~]# docker ps  //查看运行的容器
                ~]# docker ps  -qa//查看所有容器的id

            1.7镜像常用命令

                docker images  //查看当前镜像
                docker pull    // 下载
                docker push     //上传
                docker history  //查看镜像制作历史
                    docker history docker.io/busybox:latest

                docker inspect   //查看镜像底层信息,注意 PATH和cmd部分就好
                    docker inspect docker.io/nginx //查看镜像底层信息
                    docker inspect a49918ac2a02 //查看容器信息
                    docker inspect -f "{{.NetworkSettings.IPAddress}}" a49918ac2a02(容器id) // -f  格式化输出  查看容器 ip地址
                    docker inspect -f '{{.NetworkSettings.MacAddress}}'


                    docker tag docker.io/nginx:latest nsd:nsd  //修改镜像的名称和tag
                docker tag docker.io/oldname:oldtag newname:newtag
                docker rmi 镜像名称   // 删除镜像,启动过容器的镜像不能删除
                    docker rmi docker.io/nginx:latest     先删除容器才能,继续删除镜像

                docker save 镜像名称 -o 保存文件名称  //导出镜像 (保存为tar包)
                    docker save docker.io/redis:latest -o redis.tar

                docker  load  -i 导入文件名称  //导入镜像
                    docker load  -i busybox.tar/

                docker search 镜像名称  //查找镜像

            1.8docker 管理命令

                docker run -itd docker.io/redis:latest  // 运行容器(创建新容器) i 交互式界面 t terminal(终端) d 后台执行
                docker ps  //查看启动的容器列表 -a 显示所有 -q 只显示容器数字id CONTAINER ID
                docker ps -a
                docker stop 9752526130d0    //关闭容器
                docker start 9752526130d0   //开启容器
                docker restart 9752526130d0 //重启容器
                docker inspect a49918ac2a02 //查看容器信息
                docker rm 5613aa11e610      //删除容器  先删除容器才能,继续删除镜像
                    docker rm -f 5876b2b46e6c   -f 强制删除真正运行的容器
                docker top 容器ID             //查看容器进程列表
                    docker top 9752526130d0
                #################################################
                docker exec -it 容器id 指定解释器(容器中存在的解释器)   //进入容器(平时使用)i 交互式界面  t 终端

                    docker exec -it daa87f3bb /bin/bash

                    docker attach  容器id     //进入容器    直接链接上帝进程systemd 退出后由systemd 关闭 整个容器,排错时使用,平时不推荐
                ###################################################
                docker rm $(docker stop $(docker ps -qa)) //删除所有的容器包括 关闭的 //命令中可以传递参数

            1.9 制作镜像
                    手动创建
                        docker run -it docker.io/centos:latest          //新建容器

                            安装需要的软件

                        docker commit CONTAINER ID docker.io/name:tag   //导出镜像
                            将基于官方镜像的自定义镜像 导出
                    自动创建

                        Dockerfile
                        dockerfile

                        FROM 基础镜像
                        RUN  在容器中执行  //RUM是在容器bash中执行的,也就是说每个RUN的父进程是一个bash进程     ADD  复制文件到镜像
                        MAINTAINER 镜像创建者信息
                        EXPOSE 开放端口
                        ENV  设置环境变量
                        WORKDIR 定义容器工作目录  //设置当前目录
                        CMD  容器启动时执行的命令,仅只能有一条  所有参数和命令之间用','分割并用""将每一部分引起来 CMD ["/bin/ls", "-a"]
                                                                                    中间使用 空格 将 , 分开 别忘记了

                        docker build  // -t  Name and optionally a tag in the 'name:tag' format (default [])


                    eg: 配置yum源
                        [root@docker1 ~]# ls base/
                        cp  /etc/yum.repos.d/local.repo bulid/
                        Dockerfile  local.repo  //创建文件如下
                        mkdir bulid
                        cd bulid
                        touch Dockerfile
                        FROM docker.io/centos:latest
                        RUN rm -rf  /etc/yum.repos.d/*.repo
                        ADD local.repo  /etc/yum.repos.d/    ### 需要复制到docker的文件必须和 Dockerfile 在一个文件夹下
                             本地文件       容器中文件
                        RUN yum -y install vim net-tools iproute psmisc tree lftp rsync bash-completion

                        [root@docker1 base]# docker build -t test:test .

                    eg:配置httpd服务


                        vim DockerfileENV

                            FROM docker.io/myos1:latest
                            RUN yum -y install httpd
                            RUN echo "hello world" > /var/www/html/index.html
                            EXPOSE 80
                            ENV EnvironmentFile=/etc/sysconfig/httpd
                            CMD ["/usr/sbin/httpd", "-DFOREGROUND"] 注意,后的空格

                            ENV 文件是通过如下找到的
                                rpm -ql httpd |grep service
                                vim /usr/lib/systemd/system/httpd.service
                                 中 一行 EnvironmentFile
                                    和   ExecStart  就是启动 命令和参数

                        docker build -t myapach:test .

                        docker run -it myapach:test
                        curl 172.17.0.2
                            hello world

            1.10自定义私有仓库
                      1.31
                      yum -y install docker-distribution
                      systemctl restart docker-distribution.service
                      systemctl enable docker-distribution.service


                      systemctl restart docker-distribution.service

                      docker tag docker.io/myos1:latest 192.168.1.31:5000/myos:latest

                      docker push 192.168.1.31:5000/myos:latest

                      1.32
                        先停止服务 才能看到配置
                        vim /etc/sysconfig/docker  //修改如下
                        13 ADD_REGISTRY='--add-registry 192.168.1.31:5000'  //docker1 定义在/etc/hosts 中也可以填 ip:port
                                                                        但是需要注意的是  这两行要么填hosts 要么填 ip:port
                                                                        并且之后上传/启动镜像也要使用相对应的

                        24 INSECURE_REGISTRY='--insecure-registry 192.168.1.31:5000' //允许不安全的 仓储
                        vim /etc/sysconfig/docker
                            //依然是13/24 行和31 填写的相同
                        systemctl restart docker-distribution.service
                            //启动
                        docker run -it 192.168.1.31:5000/apache:httpd /bin/bash

                        若上传 镜像失败 检查/etc/docker/ 下 daemon.json
                           添加 { "insecure-registries":["192.168.1.242:5000"] }
                            提示 : 一下信息
                            The push refers to a repository [192.168.1.242:5000/kubernetes-dashboard-amd64]
                            Get https://192.168.1.242:5000/v1/_ping: http: server gave HTTP response to HTTPS client


                查看共享的image
                     查看私有镜像仓库全部镜像
                     curl http://192.168.1.31:5000/v2/_catalog

                     私有库存储位置   /var/lib/registry/


            1.11 主机卷的共享

                docker 数据持久化
                        -v 数据传递
                    docker run -it -v/真机目录:/docker目录 192.168.1.31:5000/apache:httpd /bin/bash

                    docker run -v/webroot:/usr/share/nginx/html/ -itd 192.168.1.31:5000/nginx:latest

                        真机/webroot 可以使用nfs 等磁盘共享
                        docker 直接挂载使用




            1.12 docker 网络拓扑

                docker network list  //查看网络信息

                docker network create --subnet=10.10.10.0/24 docker1 //创建虚拟交换机 --subnet指定子网

                docker run --network=docker1 -itd docker.io/busybox:latest



                客户端访问容器内资源
                    默认容器可以访问外网
                    但是外部主机不可以不可以变成对应的服务
                    容器的特性是可以把宿主机器变成对应服务
                        -p 将容器端口和宿主机端口绑定

                        -p 宿主机端口:容器端口

                    文件系统的挂载
                    eg:
                        docker run -v/webroot:/var/www/html -itd -p 80:80 192.168.1.31:5000/apache:httpd
                          -v 挂载磁盘,数据持久化

                宿主机复制文件到docker容器(也可以将docker容器的文件复制到宿主机)

                    docker cp 要拷贝的文件路径 容器名：要拷贝到容器里面对应的路径
                    eg:
                        docker cp /opt/test.js testtomcat：/usr/local/tomcat/webapps/test/js
                    docker cp 容器名：要拷贝的文件在容器里面的路径       要拷贝到宿主机的相应路径
                    eg:
                        docker cp testtomcat：/usr/local/tomcat/webapps/test/js/test.js /opt

            1.13 docker 网络模式
                参考: https://www.cnblogs.com/zuxing/articles/8780661.html

                查看docker网络
                    docker network ls
                用--net选项指定容器的网络模式

                    · host模式，使用--net=host指定。

                    · container模式，使用--net=container:NAME_or_ID指定。

                    · none模式，使用--net=none指定。

                    · bridge模式，使用--net=bridge指定，默认设置


                    host模式:
                        Docker使用的网络实际上和宿主机一样，在容器内看到的网卡ip是宿主机上的ip

                        由于docker使用了 基于内核的 name space 技术来进行资源隔离
                        (隔离主要分为 PID Namespace隔离进程，Mount Namespace隔离文件系统，Network Namespace隔离网络),
                        若docker 创建 容器 时使用了 -net=host 指定网络模式,则容器将不会进行网络隔离,容器不会虚拟出自己的网卡和配置自己的ip
                        而直接使用宿主机的 ip.

                    container (容器) 模式:
                        多个容器使用共同的网络看到的ip是一样的。

                        该模式将指定一个已经存在的容器的 network name space 为新创建的容器提供共享ip,端口范围使用
                        而不是和宿主机共享.新创建的容器不会创建自己的网卡，配置自己的IP，
                        同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过lo网卡设备通信.

                    none模式:
                        该模式不会配置任何网络

                        这个模式下docker拥有自己的network namespace ,但是不会对容器配置任何网络,需要我们根据实际情况 对容器配置网络

                    bridge模式(默认):

                        bridge 模式是 docker默认的网络设置,该模式会为每一个容器分配network namespace,设置ip,
                        并将一个主机上的docker容器链接到同一个网段之下,之间是可以通信的.

                    eg:
                        在宿主机上启动一个含有nginx的docker容器,监听tcp80 端口
                        docker run --name=nginx_host --net=host -p 80:80 -d nginx

                    docker 网络配置过程:
                        1.宿主机上创建一对虚拟网卡veth pair 设备,veth 设备必须成对出现,不然怎么通信,之间组成一个数据通道,
                          数据从一个设备进入,从另一个设备出来, veth 设备则是用来链接这两个网络设备
                        2.docker 将veth pair的设备的一端放在新创建的的容器中,并命名为eth0.另一端放在宿主机中vethxxx命名,
                        并将这个网络设备加入到docker0网桥中,通过brctl show  查看

                        3.从docker0子网中分配一个ip给容器使用,并将docker0的ip地址为默认网关
[root@node6 ~]# docker run -d -h gitlab --name gitlab -p 443:443 -p 80:80 -p 22:22 --restart always -v /srv/gitlab/config:/etc/gitlab -v /srv/gitlab/logs:/var/log/gitlab -v /srv/gitlab/data:/var/opt/gitlab gitlab_zh:latest

                    -v 将本地文件和docker 文件 共享
                    --name 指定docker 容器启动后的 名字, 若没有则docker 生成一个
                    -h 指定镜像
大型架构及配置
DAY01 ansible
DevOps
    DevOps（Development和Operations的组合词）是一组过程、方法与系统的统称，用于促进开发（应用程序/软件工程）、技术运营和质量保障（QA）部门之间的沟通、协作与整合。
    它是一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。
    它的出现是由于软件行业日益清晰地认识到：为了按时交付软件产品和服务，开发和运营工作必须紧密合作.
一.ansible
    使用时 千万要小心  rsync rm 这种都是危险操作
    1.1简介
        ansible是it自动化和DevOps软件 基于python开发 批量部署 批量运行命令
        ansible可以实现:
        -自动化部署app
        -自动化管理配置项目
        -自动化持续交互
        -自动化云服务管理

    1.2ansible 特性
         模块化设计,调运特定的模块完成特定任务
         基于python
         -paramiko
         -PyYAML
         -jinja2
         基于模块支持支持JSON 标准输出格式,可以采用任何编程语言重写
         部署简单
         主从模式工作
         自定义模块-
         支持playbook
         易用使用
         支持多层部署
         支持异构it环境
         ##############################################
         可以管理 linux window server mysql docker k8s  只要开发模块 基本啥都能搞
         ###############################################
    1.3 为什么选择ansible
        特点:
            社区活跃度
            学习成本
            使用成本
            编码语言
            性能
            使用广发
        优点:
            只要支持ssh和python
            无客户端
            ansible功能强大,模块丰富
            上手容易,门槛低
            二次开发容易
            活跃度高
    1.4 工作流程


            host1           cmd1
            host2           cmd2
            host3           cmd3
            ...             ...

            hostx           cmdx

        每台host 会遍历 命令集合,我们就是让一批机器执行一批命令

        ansible 执行流程

            读取配置
            抓起全量机器&分组列表
            使用host-pattern过滤机器列表
            根据参数确定执行模块和配置
            runner执行返回
            输出,结束


    1.5 安装
        软件依赖关系

            管理主机
                python 2.6 /2.7以上
                ansible需要一下模块
                    -paramiko
                    -PyYAML
                    -jinja2
                    -httplib2
                    -six


            被管理主机
                ansible 默认通过ssh协议管理
                被管理机器要开启ssh服务,允许ansible主机登录
                管理节点需要python2.5以上
                若被管理节点开启selinux,需要安装 libselinux-python,所以尽量关闭selinux


        准备 6 台机器 1.40-1.45
        安装ansible
            yum 安装
                拷贝软件包到
                跟新索引文件 createrepo
                配置yum
            安装
                ansible管理主机上
                yum -y install ansible

                vim /etc/ansible/ansible.cfg
                    行取消注释
                    14 inventory      = /etc/ansible/hosts //主机集合
                    71 host_key_checking = False //不检查配置文件
    1.6主机定义与分组
        安装ansible后
            ########################### 记住啊######################
            ansible配置文件顺序查找
            -先检测ansible_config变量定义的配置文件
            -其次检测当前目录下的./ansible.cfg
            -再检查当前用户家目录下~/ansible.cfg文件
            -最后检查/etc/ansible/ansible.cfg文件
            /etc/ansible/ansible.cfg 是ansiblemore配置文件路径
            ansible.cfg 配置文件
                -inventory 定义托管主机地址配置文件路径
            ########################################################
            定义主机格式
                /etc/ansible/hosts 配置文件 位置
                [组名]
                主机名称/ip 其他参数
                vim /etc/ansible/hosts
                    添加
                    [web]
                    web[1:2]  //范围指定也可以向下面一样写
                    [db]
                    db[1:2]
                    [other]   //
                    cache
    1.7 ansible 命令

        ansible 主机集合 -m 模块 -a 模块参宿
            -主机集合 主机名/分组名 , 分割
            -m 模块名称 默认command模块
            -a / -args 模块参数
            -i inventory 文件路径/ 可执行脚本
            -k 使用交互式登录密码
            -e定义变量
            -v 显示详细信息

            显示可执行主机
            ansible web,db --list-hosts
            批量检测主机
            ansible web -m ping -k
            列出所有的可执行主机
            ansible all  --list-hosts

            部署免密码登录

            ssh-keygen -t rsa -b 2048 -N'' -f /root/.ssh/key
            for i in 41 42 43 44 45
            > do ssh-copy-id -i key.pub root@192.168.1.$i
            > done
            -i 指定 公钥文件
            再次检测
            ansible web -m ping

        inventory 扩展参数
            -ansible_ssh_port
                -ssh端口号: 若不是默认端口通过这个变量设置
                /etc/ansible/hosts
                [web]
                web1 ansible_ssh_port=22
            -ansible_ssh_user
                -默认的ssh用户名

            -ansible_ssh_pass
                -ssh密码 建议使用--ask-pass/ ssh秘钥
            -ansible_ssh_private_key_file
                -ssh使用的私钥文件,使用于多个秘钥,并不想使用ssh代理

            vars变量定义,用于用户组名后面
                [all:vars]   //all表示全部组,
                ansible_ssh_private_key_file="/root/.ssh/key"
            children 子组定义,引用其他组名称
                [app:children]
                web    //其他组名.非主机名
                db

            自定义配置文件
                有多少人就可以有多少配置文件,分组只限制与本文件(用户)
                创建 文件夹 myansible
                创建配置文件ansible.cfg
                    sed -n "14p;61p" /etc/ansible/ansible.cfg
                    [defaults]  //配置文件分组名称
                    inventory = myhost      //14 行
                    host_key_checking = False  //61 行

                配置主机文件
                    [app]
                    web1
                    db1
                    cache
                    [app1]
                    web1
                测试 ansible app -m ping

            动态主机
                无限可能
                    ansible inventory 包含静态和动态的inventory,静态的inventory
                    指在文件/etc/ansible/hosts中指定的主机和组
                    动态inventory指通过外部的脚本获取主机列表,按照要求格式返回给ansible命令

                json
                    Javascriptobjectnotation,Javascript对象表示法,一种基于文本独立于语言的轻量级数据交换格式



    1.8ansible 模块

        ansible-doc和ping模块

            ansible-doc
                -模块的手册相当于shell的man,  (非常重要,ansible必备)
                ansible-doc -l          //列出所有模块
                ansible-doc modulename   //查看帮助
            ping 模块
                测试网络连通性,ping模块没有参数,测试的ssh链接是否成功
                ansible host-pattern -m ping


            command模块
                ansible是并发执行
                默认模块,远程执行命令
                    ansible host-pattern -m command -a 'args'
                    查看机器负载
                    ansible all -m command -a 'free -mh'
                    查看当前时间日期
                    ansible all -m command -a 'date +%F_%T'
                command模块注意事项
                    -该模块通过-a 跟上需要执行的命令可以直接执行,若命令中有如下字符则不能执行
                    "<" ">" "|" "&"
                    -command模块不能解析系统变量
                    -该模块不起动shell 直接在ssh进程中执行,所有使用到shell的命令都会失败
                    - 下面命令会失败
                    -ansible all -m command -a 'ps aux |grep ssh'
            shell 模块
                -shell 模块用法基本和command一样,区别是shell模块通过/bin/sh 执行命令,可以执行任意命令
                -不能执行交互命令 如 vim top

                ansible all -m shell -a "echo ${HOSTNAME}"  //本地bash解析
                    db2 | SUCCESS | rc=0 >>
                    ansible
                ansible all -m shell -a 'echo ${HOSTNAME}'  //远程bash解析
                    db1 | SUCCESS | rc=0 >>
                    DB1

                ansible all -m shell -a 'echo \${HOSTNAME}'
                    web1 | SUCCESS | rc=0 >>
                    ${HOSTNAME}

                testfile 文件在哪里
                    ansible cache -m shell -a 'cd /tmp'
                    ansible cache -m shell -a 'touch testfile'

                问题解析
                    变量解析
                        -ansible 执行 命令是二次解析
                        -第一次在本机解析,第二次在执行机器解析
                        -需要第二次解析的变量要转义(\)
                    文件在哪里
                        -文件子用户家目录
                        -ansible是使用ssh多次链接执行
                        -链接退出后之前状态就全部失效
                        -解决方法使用chdir 代替cd

                给web1,db2 添加用户nb ,修改nb密码为123
                    ansible web1,db2 -m shell -a 'useradd nb && echo 123 |passwd --stdin nb'

            script 模块
                通过该模块可以执行脚本
               -在本地写脚本,然后使用script模块批量执行
               -注意:该脚本包含但不限于shell脚本,只要指定sha-bang解释器的脚本都可以
                ansible cache -m script -a 'useradd.sh'
                    vim useradd
                        #!/bin/bash
                        id nb
                        if [ $? != 0 ];then
                        useradd wk
                        echo 456 | passwd --stdin wk
                        fi

            yum模块
                -通过该模块使用yum包管理器
                -name 要进行操作的软件包名字
                -state 动作 (installed ,removed)
                -installed 安装
                -removed  删除

                ansible db -m yum -a 'name=mariadb-server state=installed'

            service模块
                -name 必选项,服务名
                -enabled 是否开机启动 yes/no
                -sleep 执行restarted,会在stop和start之间睡几秒
                -state 对应当前服务执行启动 停止 重启 重新加载
                -started stopped restarted reloaded

                ansible db -m service -a 'name=mariadb state=started enabled=yes'

            copy模块
                -复制文件远程主机
                -src 复制本地文件到远程主机,绝对路径和相对路径都可以,
                路径为目录时会递归复制.若路径以'/'结尾,则复制目录里面的内容,
                若不以'/'结尾,则复制包含目录在内的整个内容类似rsync
                -dest 必选项.远程主机的绝对路径,如源文件是一个目录,那路径必须是目录
                -backup 覆盖前先备份源文件,备份文件包含时间信息 选项:yes/no
                -force 若目标主机包含文件,单内容不同,若设置为yes,则墙纸覆盖,若设置为no,则只有当目标主机目标位置不存在该文件才会复制,默认为yes
                -复制文件
                    ansible all -m copy -a 'src=my.cnf dest=/etc/my.cnf'

                -复制目录
                    ansible all -m copy -a 'src=/etc/yum.repos.d/ dest=/etc/yum.repos.d/'



            lineinfile 模块
                -一个类似与sed的一种行编辑替换模块
                -path  目标文件
                -regexp 正则表达式,要修改的行
                -line 最终的修改结果
                -例如修改my.cnf,中 bin-log
                ansible db -m lineinfile -a 'path="/etc/my.cnf" regexp="^binlog-format" line="binlog-format = row"'

            replace 模块
                -一个类似与sed的一种行编辑替换模块
                -path  目标文件
                -regexp 正则表达式,要修改的行
                -replace 最终的修改结果
                -例如替换指定字符 row-->mixed
                ansible db -m replace -a 'path="/etc/my.cnf" regexp="row" replace="mixed"'


            setup 模块
                -主要用来获取主机信息,playbooks里经常会用的另一个参数gather_facts与该模块相关,
                setup模块下经常用的是filter参数
                -filter 过滤所需的信息

                ansible cache -m setup -a 'filter=ansible_distribution'


DAY02
    PLAYBOOK
    一.playbook 基础
        1.1ansible 七中武器
            第一种  (必须掌握)
                ansible 命令,用于执行零时性工作
            第二种  (必须掌握)
                ansible-doc 是ansible模块的文档说明,类似于man命令
            第三种 (必须掌握)
                ansible-console是ansible为用户提供的交互的工具
                用户可以使用ansible-console虚拟出来的终端上想使用shell一样使用ansible内置命令
            第四种
                ansible-galaxy从github上下载管理Roles的一款工具与python的pip一样
            第五种 (必须掌握)
                ansible-playbook 是日常使用中频率最高的命令,工作机制:通过读取先编写好的PLAYBOOK文件实现批量管理,可以理解为按照一定的条件组成的ansible任务集
            第六种
                ansible-vault主要用户配置文件加密,如编写的PLAYBOOK文件中包含敏感信息,用他可以加密/解密文件
            第七种
                ansible-pull
                ansible 有两种工作模式 pull/push 默认pull.pull和push的工作机制刚好相反
                适用场景: 有大量机器需要配置,即便适用高并发线程也需要花费很多时间
                通常配置大批量机器先适用,灵活性稍有欠缺,但效率几乎可以无限提升.

        1.2json简介
        json是什么
                json是JavaScript对象表示法,一种基于文本独立于语言的轻量级数据交换格式
                分隔符限于   ' ()  [] {} : , 这几种
                独立于语言,与使用什么编程语言无关
                eg:
                [1,2,3,4]
                {key:value}
        json特性
            json是纯文本
            json具有人类可读性
            json具有层级别结构 --可以互相嵌套
            json可通过Javascript进行解析
        json语法
            -数据在名称/值对中
            -数据由"," 分隔
            -{} 保存对象
            -[] 保存数组
        json 数组的书写格式  名称/值对
            名称/值对 包含字段名称(在""中),后面写一个:,然后是值
            "key":"value"
        json语法规则-数组
           { "key":["k1":"v1",["1","2","3","4"],"k2":["k3":"v3"]]
            }
            犇哥: 牛犇
            讲师:[牛犇,王凯,丁丁,静静,xx]
            讲师:[
                {姓名:牛犇,爱好:大锤},
                {姓名:王凯,爱好:吃香蕉},
                {姓名:丁丁,爱好:写书},
                {姓名:静静,爱好:养猫},
                {姓名:xx,爱好:开车}
            ]

        1.3jinja2介绍
            jinja2 是什么
                jinja2

            jinja2 模板基本语法
                -模板的表达式都是包含在分隔符"{{ }}"内的
                -控制语句都是包含在分隔符"{% %}" 内的
                -模板支持注释,都是包含在分隔符"{# #}" 内,支持块注释
                -调用变量
                    {{username}}
                -计算
                    {{2+3}}
                -判断
                     {{1 in [1,2,3]}}
            jinja2控制语句

                if 判断
                    {% if name == '诗仙' %}
                        dc
                    {% elif name == '诗圣' %}
                        ch
                    {% elif name == '诗魔' %}
                          bj
                    {% else %}
                        lh
                    {% endif %}

                    if
                    elif
                    else
                    endif

                for 循环
                    {% if name == .... %}
                        ... ...
                    {% elif name == '于谦' %}
                       {% for method in [抽烟,喝酒,烫头] %}
                        {{do method}}
                       {% endfor %}
                       ... ...

                    {% endif %}

                    for i in xx
                    do i
                    endfor


        1.4YAML简介
            YAML是什么
                高可读,用来表达数据数列的格式
                YAML已有多种编程语言的支持
            YAML基础语法
                YAML的结构通过空格来展示
                数组使用 - 来表示
                键值对使用 : 来表示
                YAML使用一个固定的缩进风格表示数据层级结构关系
                一般每个缩进级别由两个以上空格组成(千万不能使用table,用来就语法错误)
                #表示注释

                注意: 不要使用table ,缩进是初学者易出错的地方
                      同一层级必须对齐
            YAML的键值
                采用: 分隔
                :后面必须有一个空格
                YAML键值对例子

                key: value /
                key:
                  value
            YAML数组表示
                使用一个短横杠加一个空格
                json
                    讲师:[牛犇,王凯,丁丁,静静,xx]
                YAML
                   讲师:
                     - 牛犇
                     - 王凯
                     - 丁丁
                     - 静静
                     - xx
                json
                    讲师:[
                        {姓名:牛犇,爱好:大锤},
                        {姓名:王凯,爱好:吃香蕉},
                        {姓名:丁丁,爱好:写书},
                        {姓名:静静,爱好:养猫},
                        {姓名:xx,爱好:开车}
                    ]

                YAML

                    讲师:
                      -
                        姓名: 牛犇    ## 每层级 俩个空格分隔,"key:"与"value"间是有一个空格
                        爱好: 大锤
                      -
                        姓名: 王凯
                        爱好: 吃香蕉
                      -
                        姓名: 丁丁
                        爱好: 写书
                      -
                        姓名: 静静
                        爱好: 养猫
                      -
                        姓名: xx
                        爱好: 开车

    二.PLAYBOOK
        什么是PLAYBOOK
            ansible用于配置,部署和管理托管主机剧本,通过PLAYBOOK的详细描述,执行一系列的tasks

        为什么要使用PLAYBOOK
            执行简单的任务,使用ad-hoc

        PLAYBOOK语法基础
            PLAYBOOK语法
                PLAYBOOK由YAML编写,
                #表示注释
                同一列表元素保持缩进
                PLAYBOOK由一个/多个play组成
                play中hosts,variables,roles,tasks等对象表示方法都是键值以':' 分隔
                YAML开始 为---
            playbook构成
                hosts: 定义要执行PLAYBOOK的远程主机组
                vars: 定义PLAYBOOK运行时需要使用的变量
                tasks: 定义将要在远程主机上执行的任务列表
                handlers: 定义tasks执行完成后需要调用的任务
            PLAYBOOK执行结果
                绿色 成功
                红色 失败
                黄色 系统状态改变


            eg1:
                ---
                - hosts: all
                  remote_user: root
                  tasks:
                    - ping:
        变量
            eg2:
                ---
                - hosts: web
                  remote_user: root
                  vars:
                    username: l4
                  tasks:
                    - name: "create user "
                      user:
                        name: "{{username}}"
                        group: users
                    - name: "change_passwd"
                      shell: echo 123 |passwd --stdin "{{username}}"

            eg3:  变量过滤器
                ---
                - hosts: web
                  remote_user: root
                  vars:
                    username: w5
                  tasks:
                    - name: "create user "
                      user:
                        name: "{{username}}"
                        group: users
                        password: "{{'123'|password_hash('sha512')}}"


            eg4:参数传递
                ansible-playbook user.01.yml -e "{username:  ll}"
                ---
                - hosts: web
                  remote_user: root
                  tasks:
                    - name: "create user "
                      user:
                        name: "{{username}}"
                        group: users
                        password: "{{'123'|password_hash('sha512')}}"

            eg5: 参数传递
                ansible-playbook user.01.yml -e @username.yml

                vim username.yml
                ---
                username:
                  nb
                vim  user.01.yml
                ---
                - hosts: web
                  remote_user: root
                  tasks:
                    - name: "create user "
                      user:
                        name: "{{username}}"
                        group: users
                        password: "{{'123'|password_hash('sha512')}}"
            eg6: 安装httpd

                ---
                - hosts: web
                  remote_user: root
                  tasks:
                    - yum:
                        name: httpd
                        state: latest
                    - lineinfile:
                        path: /etc/httpd/conf/httpd.conf
                        regexp: '^Listen 80'
                        insertafter: '^#Listen '
                        line: 'Listen 8080'
                    - copy:
                        src: /root/index.html
                        dest: /var/www/html/index.html
                        owner: apache
                        group: apache
                        mode: 0644
                    - service:
                        name: httpd
                        state: started
                        enabled: yes

                vim index.html
                    html1
        erro模块
            忽略错误继续执行,
            ignore_errors: True
                True  忽略错误继续执行
                False 默认 遇到错误停止

                eg: 在web 上的创建 /tmp/cache 并 修改配置文件重新加载配置文件
                    ---
                    - hosts: web
                      remote_user: root
                      tasks:
                        - shell: mkdir /tmp/cache
                          ignore_errors: True
                        - copy:
                            src: /root/httpd.conf
                            dest: /etc/httpd/conf/httpd.conf
                            owner: apache
                            group: apache
                            mode: 0644
                        - service:
                            name: httpd
                            state: restarted
                            enabled: yes

        tag 标识
            调用 : ansible-playbook apacher_tags.yml -t syncconf
                ---
                - hosts: web
                  remote_user: root
                  tasks:
                #    - shell: mkdir /tmp/cache
                #      ignore_errors: True
                    - copy:
                        src: /root/httpd.conf
                        dest: /etc/httpd/conf/httpd.conf
                        owner: apache
                        group: apache
                        mode: 0644
                      tags: syncconf  ##与copy同级
                    - name: restart apache
                      service:
                        name: httpd
                        state: restarted
                        enabled: yes
        when 条件触发
            需要满足特定条件后出发某一项操作,或在特定条件下执行某个行为

            tasks:
              - name: somecommand
                  command: somecommand
                  when: expr
            eg:
                ---
                - name: Install vim
                  hosts: all
                  tasks:
                    - name: Install vim yum
                      yum: name=vim-enhanced state=installed
                      when: ansible_os_family == "RedHat"
                    - name: Install vim apt
                      apt: name=vim state=installed
                      when: ansible_os_family == "Debian"
        with_itmes  playbooks 标准循环

            通过{{item}} 获取每次迭代的值
            创建多个用户
            ---
            - hosts: web
              remote_user: root
              tasks:
                - name: add users
                  user: group=wheel |password="{{'123456'|password_hash('sha512')}} name={{item}}"
                  with_items:["nd","dd","plj","lx"]

            with_items 进阶

                为不同用户定义不同组
                ---
                - hosts: db


                  tasks:
                    - name: adduser "{{item.name}}"
                      user:
                        name: "{{item.name}}"
                        group: "{{item.group}}"
                        password: "{{item.pwd|password_hash('sha512')}}"
                      with_items:
                        -
                          name: nb
                          group: nobody
                          pwd: "123456"
                        -
                          name: wk
                          group: users
                          pwd: "654321"
                        -
                          name: dd
                          group: adm
                          pwd: nginx
                        -
                          name: jj
                          group: mysql
                          pwd: 123qqq...A
                        -
                          name: xx
                          group: root
                          pwd: a




        register  保存前一个命令的结果
            有时候我们需要前面一个命令的执行结果来判断是否要执行后面的操作,
            我们需要register模块来保存前一个命令的返回状态,在后面调用
            - command: test command
              register: result
            - command: run command
              when: result
            变量注册进阶
                -针对运行命令结果返回值做判定
                -当系统负载超过一定值做特殊处理

                vim dubug.yml
                ---
                - hosts: web
                  remote_user: root
                  tasks:
                    - shell: uptime | awk '{printf("%.2f",$(NF-2))}'
                      register: result      ####显示详细的错误信息
                    - service:
                        name: httpd
                        state: stopped
                      when: result.stdout|float > 0.7   #####result.stdout|float将输出字符转化为数值, 经过测试不转化为float也可以执行成功









        handlers 触发器
            ansible-playbook apacher_change.yml
                ---
                - hosts: web
                  remote_user: root
                  tasks:
                #    - shell: mkdir /tmp/cache
                #      ignore_errors: True
                    - copy:
                        src: /root/httpd.conf
                        dest: /etc/httpd/conf/httpd.conf
                        owner: apache
                        group: apache
                        mode: 0644
                #      tags: syncconf
                      notify:
                        - restart apache
                  handlers:  ###与tasks 同级 ,执行玩tasks后 才会执行 handler
                    - name: restart apache
                      service:
                        name: httpd
                        state: restarted
                        enabled: yes







        include and roles 调用PLAYBOOK文件
            include
                由于PLAYBOOK文件会随着项目越来越大,PLAYBOOK也会越来越复杂,我们可以把
                play tasks handler 分别写入不同文件 通过include指令包含进来

                tasks:
                  -include: tasks/setup.yml
                  -include: tasks/user.yml user=plj  ##user.yml 中可以通过{{user}} 来使用变量

                handler:
                  -include: handler/handlers.yml
            roles
                roles 像是一个加强版的include,他可以引入一个项目的文件和目录
                一般所需的目录层级有
                 -vars: 变量
                 -tasks: 任务层
                 -handler:出发层
                 -file: 文件
                 -template: 模板
                 -default: 默认,优先级最低

                 eg: 加入有一个play包含一个叫x的role则
                    ---
                    -hosts: host_group
                    roles:
                      -x
                 -x/tasks/main.yml
                 -x/vars/main.yml
                 -x/handler/main.yml
                 -x/.../main.yml
                 这些都会添加到这和play







        debug 模块
            检测语法 ansible-playbook --syntax-check test.yml

            运行测试 ansible-playbook -C test.yml
                由于测试和检测语法的问题可能 会检测失败,但是写的PLAYBOOK 并没有问题
            调用:ansible-playbook dubug.yml
            当一分钟之内的cpu使用率达到70%后就停止httpd服务,在报错时显示详细信息
            vim dubug.yml
            ---
            - hosts: web
              remote_user: root
              tasks:
                - shell: uptime | awk '{printf("%.2f",$(NF-2))}'
                  register: result      ####显示详细的错误信息
                - service:
                    name: httpd
                    state: stopped
                  when: result.stdout|float > 0.7   #####result.stdout|float将输出字符转化为数值, 经过测试不转化为float也可以执行成功
                - name: show debug info
                  debug: var=result

DAY03
    一.elk
        1.1 elk是什么
            elk 是一套日志监控解决方案 ,三个软件产品字母缩写,均为开源软件
            elasticsearch  日志检测和存储   (数据库)
            logstash       日志的收集和分析处理  (Java程序,处理log可视化-类似于php)
            kibana         负责日志的可视化  (web软件--类似nginx)

            虽然elk可zabbix都是监控软件但是,这是两个不同的监控方向,zabbix 监控服务,机器状态,elk监控日志


        1.2 elk能做什么
            -分布式日柱数据集中式查询和管理
            -系统监控,包含系统硬件和应用的各个组件的监控
            -故障排查
            -安全信息的事件管理
            --报表功能
        1.3 elasticsearch 特点
            非关系型数据库
            实时性
            分布式实时文档存储
            所有对象全是文档
            高可用 易于扩展 支持集群 分片和复制
            接口友好 支持json

            es 没有什么
            典型意义的事物
            面向文档的数据库
            没有授权和认证
        1.4 elasticsearch 相关概念

            node 装有es服务器节点
            cluster 有多个node组成集群
            document 一个可被搜索的基础信息单元     row       行
            index 拥有相似特征的文档集合           database
            type 一个索引中可定义一种/多种类型      table     表
            filed es最小单位 相当于数据的某一列     column    列
            shards 索引的分片,每一个分片就是shard
            replicas 索引的拷贝
            关系行
            DB--->database-->table-->rows-->columns

                                      行        列
            ES-->index-->types--> documents-->fields
                 索引     类型      文档          预


        1.5 安装

            准备 7台虚拟机
            配置 elk的 yum源
             createrepo .

            单台
            yum -y install  java-1.8.0-openjdk
            yum -y install elasticsearch
            vim +54 /etc/elasticsearch/elasticsearch.yml
            network.host: 0.0.0.0  //修改如下
            systemctl restart elasticsearch.service
            ss -antulp |grep 9200
            ss -antulp |grep 9300
            systemctl enable elasticsearch.service
            集群
            安装软件相同 只是修改的配置文件 有所不同
            vim /etc/hosts  //每台机器都要做
            192.168.1.51 es1
            192.168.1.52 es2
            192.168.1.53 es3
            192.168.1.54 es4
            192.168.1.55 es5
            192.168.1.56 kibana
            192.168.1.57 logstash
            192.168.1.58 Apache
            vim /etc/elasticsearch/elasticsearch.yml
            17 cluster.name: myelk        //配置集群名字
            23 node.name: es1        //当前主机名称,集群中node.name必须不同,与主机名一致,之前修改了hosts
            54 network.host: 0.0.0.0     // 0.0.0.0（监听所有地址）
            68 discovery.zen.ping.unicast.hosts: ["es1", "es2", "es3"]
            //声明集群里的主机成员有谁，不需要全部写进去,但是在启动其他机器的服务时这三台机器的服务必须先启动.
            集群中的其他机器在启动后会寻址这三台机器来确认集群
            systemctl restart elasticsearch.service
            启动没有 报错信息 若检查9300/9200 无端口 请检查 systemctl status elasticsearch.service 和  vim /var/log/messages 拍错
            访问测试 查看node 数量
            firefox http://192.168.1.51:9200/_cluster/health?pretty
                "number_of_nodes" : 5,

        安装插件
               27  cd /usr/share/elasticsearch/bin/
               28  ./plugin install ftp://192.168.1.254/elk/bigdesk-master.zip
               31  ./plugin install ftp://192.168.1.254/elk/elasticsearch-head-master.zip
               32  ./plugin list
               33  ./plugin install ftp://192.168.1.254/elk/elasticsearch-kopf-master.zip
               34  ./plugin list

        访问测试

            http://192.168.1.51:9200/_plugin/bigdesk/#nodes
            http://192.168.1.51:9200/_plugin/kopf/#!/cluster
            http://192.168.1.51:9200/_plugin/head/
                索引名称     nsd
                分片数        5    将数据分成5份存在服务器
                副本数量       2   每台服务器报错一份源数据两份备份

                最多坏两台服务器



        补充知识
            http协议

                GET POST HEAD

                OPTIONS PUT DELETE TRACE和CONNECT
            ES 常用
                PUT         增
                DELETE      删
                POST        改
                GET         查

            命令 curl
                   -A 修改请求 agent -A
                   -X 设置请求方法
                   -i 显示返回头信息

                   curl -A Safari/537.36 -Li http://www.jkgaoyuan.ml |head -10

                      % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                                     Dload  Upload   Total   Spent    Left  Speed
                    100  1104    0  1104    0     0   1319      0 --:--:-- --:--:-- --:--:--  1318HTTP/1.1 200 OK
                    Server: nginx/1.16.0
                    Date: Tue, 16 Jul 2019 06:45:32 GMT
                    Content-Type: text/html; charset=UTF-8
                    Transfer-Encoding: chunked
                    Connection: keep-alive
                    X-Powered-By: PHP/5.6.40

                   curl -A Safari/537.36 -Li -X PUT http://118.144.89.240/info.php

                    HTTP/1.1 200 OK
                    Server: nginx
                    Date: Tue, 16 Jul 2019 06:48:24 GMT
                    Content-Type: text/html; charset=UTF-8
                    Transfer-Encoding: chunked
                    Connection: keep-alive
                    Set-Cookie: PHPSESSID=f13e90b9a3b7fcc167e5e69c88445099; path=/
                    Expires: Thu, 19 Nov 1981 08:52:00 GMT
                    Cache-Control: no-store, no-cache, must-revalidate
                    Pragma: no-cache

                    <pre>
                    [ REQUEST_METHOD] ==> PUT
                    [    REMOTE_ADDR] ==> 223.255.15.21
                    [HTTP_USER_AGENT] ==> Safari/537.36
                    [   HTTP_REFERER] ==>



            RESTful API 调用
                显示 所有cat目录
                curl  http://192.168.1.51:9200/_cat/
                curl  http://192.168.1.51:9200/_cat/recovery
                显示 详细的 health信息 ?v 表示显示详细信息
                curl  http://192.168.1.51:9200/_cat/health?v

                通过命令行创建索引
                [root@es1 ~]# curl -XPUT http://192.168.1.51:9200/tedu -d '{
                >   "settings":{
                >     "index" :{
                >       number_of_shards: 5,
                >       number_of_replicas: 1
                >               }
                >               }
                > }'
                这里的ip地址填写从服务器/主服务器都可以
                插入数据
                                                    索引   类型   域
                curl -XPUT http://192.168.1.51:9200/tedu/teacher/3 -d '{
                "name": "ff",
                "age": "35",
                "gender": "man",
                "like": "chaoyan"
                }'

                修改数据
                    -XPOST  _update  {"doc": {}} 为固定格式
                curl -XPOST http://192.168.1.51:9200/tedu/teacher/4/_update -d '{"doc": {"gender":"wmen"}}'

                查询
                curl -XGET http://192.168.1.51:9200/tedu/teacher/6?putty
                删除
                    就是不能删除类型
                删除字段
                curl -XDELETE http://192.168.1.51:9200/tedu/teacher/5?putty
                删除索引
                curl -XDELETE http://192.168.1.51:9200/tedu/
                删库
                curl -XDELETE http://192.168.1.51:9200/*

                批量导入数据

                lftp 192.168.1.254
                lftp user:passwd@ip:port
                cd elk/
                get logs.jsonl.gz
                logs.jsonl.gz
                shakespeare.json.gz

                gzip -d *.gz

                curl -XPOST 'http://192.168.1.51:9200/_bulk' --data-binary @logs.jsonl
                curl -XPOST 'http://192.168.1.51:9200/_bulk' --data-binary @shakespeare.json
                curl -XPOST 'http://192.168.1.51:9200/x/xx/_bulk/' --data-binary @accounts.json

                accounts.json
                {"index":{"_id":"1"}}^M
                shakespeare.json
                {"index":{"_index":"shakespeare","_type":"act","_id":0}}

                这是表中必须包含的,但是account.json 缺少了 索引和 类型,我们应在导入数据时补上索引和类型
                索引 类型 字段



        1.6kibana
            安装 配置yum,使用 es1 使用的 yum源

                yum -y install kibana
            修改配置文件
                 vim /opt/kibana/config/kibana.yml


                  2 server.port: 5601

                  5 server.host: "0.0.0.0"

                  15 elasticsearch.url: "http://es1:9200"


                  23 kibana.index: ".kibana"

                  26 kibana.defaultAppId: "discover"

                  53   elasticsearch.pingTimeout: 1500
                  57   elasticsearch.requestTimeout: 30000
                  64   elasticsearch.startupTimeout: 5000



                  systemctl restart kibana.service
                  http://192.168.1.56:5601/status

                  状态为green则为正常

                  http://192.168.1.56:5601/

                    discover

                    kibana选择日志

                      支持通配符
                      选择logstash-*
                      time-field  选择 @timestramp
                      create

                      选择时间范围  右上角
                      15.5.17  51.5.21
                      框选


                    visualiz

                    pie chart


        1.7 logstash

            安装
                 yum -y install java-1.8.0-openjdk
                 yum -y install logstash

                 安装位置
                    /opt/logstash/

                    默认没有 配置文件

                 编写配置文件
                    默认包含三部分
                        input{}  输入
                        filter{} 处理
                        output{} 输出
                    vim /opt/logstash/logstash.conf

                    input{
                            stdin{}
                    }
                    filter{ }
                    output{
                            stdout{}
                    }

                 启动
                    -f 指定配置文件位置
                    /opt/logstash/bin/logstash -f logstash.conf

                 查看logstash 已经安装的插件
                    /opt/logstash/bin/logstash-plugin list

                 由于logstash的插件众多,可以访问下面两个 网站寻找帮助
                    https://github.com/logstash-plugins
                    https://www.elastic.co/guide/en/logstash/current/index.html   // INPUT filter OUTPUT 这三项


                 配置file插件
                    vim /opt/logstash/logstash.conf


                    input{
                            file{
                            start_position => "beginning"    // 开始读取log文件的位置,这个参数受到下面文件的影响,并且优先级高于 position
                            sincedb_path => "/var/lib/logstash/sinedb-access"    // 将指针文件定向到 /var/lib/logstash/sinedb-access, 该文件决定了服务启动后,读取log文件位置,该文件默认在 /root .sincedb_xxx
                            path => ["/tmp/a.log","/var/tmp/b.log"]
                            type => "a.log"                  //标记

                            }
                    }

                    filter{ }
                    output{
                            stdout{ codec => "rubydebug"}
                    }


DAY04
    大型架构的配置及其技术

    一.大数据
        定义:无法再一定时间范围内用常规软件工具进行捕捉管理和处理的数据集合

            从海量数据中快速获取有价值的信息.

            大规模并行处理数据库,数据挖掘,分布式文件系统,/数据库,云计算和可扩展的存储系统

        特点: 数量(vloume)  速度(velocity) 种类(variety) 价值(value) 真实性(veracity)

    二.Hadoop
        定义: 分析和处理海量数据的软件平台
              开源 Java分支
              分布式基础架构

              高可靠 高扩展 高效性 高容错 低成本
        最先有Google 发布的三篇论文  产生 GFS MapReduce BigTable 组成
        之后有Yahoo 依照论文用Java 进行实现
            GFS------> HDFS
            MapReduce------>  MapReduce
            BigTable------> Hbase


        1.1Hadoop 常用组件

            HDFS      hadoop分布式文件系统  核心
            mapreduce 分布式计算框架        核心
            Yarn      集群资源管理系统      核心
            Zookeeper 分布式协作服务
            Hbase     分布式列存数据库
            Hive      基于hadoop的数据仓库
            Sqoop     数据同步工具

        1.2 hdfs 角色及概念
            1.2.1 hdfs结构
                client
                    切分文件
                    访问hdfs
                    与namenode交互,获取文件位置信息
                    与datanode交互,读取和写入数据
                datanode
                    数据存储节点,存储实际数据
                    汇报存储信息给namenode
                namenode
                    master节点,管理hdfs的名称空间和数据块映射信息(该文件名fsimage什么数据存储位置),
                    配置副本策略(数据存储几份),处理所有客户请求,(管理数据具体存储位置)

                secondary namenode
                    定期合并fsimage 和fsedits(数据变更日志,记录数据何处变化), 推送给namenode
                    紧急情况下,辅助恢复namenode
                    但是secondary namenode 非namenode 热备份
                block
                    每块128m大小
                    每块多副本

            1.2.2 mapreduce

                    由Java实现的分布式计算框架
                    jobtracker  分解任务
                        master节点
                        管理所有的作业/任务监控/错误处理
                        将任务分解,分配给tasktracker
                    tasktracker 执行任务

                    map task
                        分析记录每条数据记录,传递给用户编写的map()并执行,将输出结果写入本地磁盘
                        -若map-only 作业,直接写入 hdfs
                    reducer task
                        从map task的执行结果中,远程读取输入数据,对数据进行排序,将数据安装分组,传递给用户编写的reduce函数执行


            1.2.3 yarn
                    核心: 将jobtracker 和task tracker 分离,由下面几大组件构成
                         -resourcemanager 一个全局的资源管理节点
                         -nodemanager   每个节点(RM)代理
                         -applicationmaster 表示每个应用
                         -每一个applicationmaster有多个container在nodemanager上运行


                    resource manager
                       处理客户端请求
                       启动/监控applicationmaster
                       监控nodemanager
                       资源分配与调度

                    nodemanager

                        单个节点的资源管理
                        处理来自resourcemanager
                        处理来自applicationmaster
                    container

                        对任务运行环境的抽象,封装了cpu 内存
                        对维度资源及环境变量,启动命令的任务运行相关的信息
                    applicationmaster

                        数据切分
                        为应用申请资源,并分配内部任务
                        任务监控与容错
                    client
                        用户与yarn的交互客户端
                        提交应用程序,监控 应用程序状态,杀死应用

        1.3 hadoop
                 注意:所有的hadoop的文件必须一致
                模式

                    单机
                    伪分布式  测试开发
                    完全分布式  生产


                单机install Hadoop

                    安装Java环境
                    yum -y install java-1.8.0-openjdk-devel


                    tar -xf hadoop-2.7.7.tar.gz  -C

                    cp -r hadoop-2.7.7/ /usr/local/hadoop/

                    配置Java的运行环境
                    vim /usr/local/hadoop/etc/hadoop/hadoop-env.sh

                    指定 Java安装路径
                    rpm -ql java-1.8.0-openjdk
                    export JAVA_HOME="/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.161-2.b14.el7.x86_64/jre"
                    指定hadoop的配置文件 位置
                    export HADOOP_CONF_DIR="/usr/local/hadoop/etc/hadoop"

                    cd /usr/local/hadoop
                    mkdir testinput

                    cp LICENSE.txt  NOTICE.txt README.txt testinput/
                    ./bin/hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.7.jar wordcount testinput/ testoutput

                    wordcount 是内置的命令
                    wordcount 输入目录  输出目录(会自己创建)  我们只需要准备好输入目录中的内容就好

                    查看结果
                    cat testoutput/part-r-00000


                伪分布式

                    伪分布式的安装和完全分布式类似,区别在与所有的角色安装在一台机器上面,使用本地磁盘,一般生产环境都会使用完全分布式,伪分布式用来学习和测试

                    伪分布式配置和完全分布式配置类似

                hadoop配置文件及格式

                    xml文件配置格式
                    <property>
                        <name>关键词</name>
                        <value>变量</value>
                        <description>描述</description>
                    </property>


                搭建完全分布式

                    准备三台机器(两台node 一台namenode,算上上午的node1 一共四台) 配置/etc/hosts
                      ping通namenode
                      192.168.1.60 node1
                      192.168.1.61 node2
                      192.168.1.62 node3
                      192.168.1.63 namenode

                      java -version 验证java
                      jps 验证角色

                    确保 namenode 能面秘钥远程 node1-3 包括本机

                        vim /etc/ssh/ssh_config
                        Host *
                        GSSAPIAuthentication yes
                        StrictHostKeyChecking no
                                     加密长度 算法  不需要密码  文件名称
                        ssh-keygen -b 2048 -t rsa -N '' -f .ssh/id_rsa

                        ssh-copy-id root@node1
                        ssh-copy-id root@node2
                        ssh-copy-id root@node3
                        ssh-copy-id root@namenode


                    修改hdfsde配置文件

                        下面配置文件的参数可以在下面网站的左下角找到
                        http://hadoop.apache.org/docs/stable/

                        ##################
                        core-site.xml
                        #################
                        vim /usr/local/hadoop/etc/hadoop/core-site.xml

                                hadoop.tmp.dir  数据的根目录, 类似mysql /usr/lib/mysql
                            将<configuration>中添加如下

                            <configuration>

                                <property>
                                    <name>fs.defaultFS</name>
                                    <value>hdfs://namenode:9000</value>
                                </property>
                                <property>
                                    <name>hadoop.tmp.dir</name>
                                    <value>/var/hadoop</value>
                                </property>

                            </configuration>

                            ##############
                            hdfs-site.xml
                            #############

                            vim /usr/local/hadoop/etc/hadoop/core-site.xml
                                哪里启动 namenode
                                哪里启动 secondary namenode

                            <configuration>
                                <property>
                                    <name>dfs.namenode.http-address</name>
                                    <value>namenode:50070</value>
                                </property>
                                <property>
                                    <name>dfs.namenode.secondary.http-address</name>
                                    <value>namenode:50090</value>
                                </property>
                                <property>
                                    <name>dfs.replication</name>
                                    <value>3</value>
                                </property>
                            </configuration>

                            ###########
                            slaves
                            ###########
                                声明谁是datanode
                            vim /usr/local/hadoop/etc/hadoop/slaves

                            node1
                            node2
                            node3

                        同步配置

                          注意:所有的hadoop的文件必须一致

                          scp -r /usr/local/hadoop/ root@node2:/usr/local/hadoop/
                          scp -r /usr/local/hadoop/ root@node3:/usr/local/hadoop/
                          scp -r /usr/local/hadoop/ root@namenode3:/usr/local/hadoop/

                        在namenode上初始化并启动服务,检查集群状态

                            cd /usr/local/hadoop
                            ./bin/hdfs namenode -format    //初始化
                            ./sbin/start-dfs.sh            //启动服务
                            ./bin/hdfs dfsadmin -report    // 检查集群状态

                            ./sbin/stop-dfs.sh              //停止服务
                            ./sbin/stop-all.sh              //停止所有服务

                            jps 验证

                                23985 Jps
                                23747 SecondaryNameNode
                                23564 NameNode

                        日志位置
                            每台机器都有
                            /usr/local/hadoop/logs/

                        rsync -avXSH
                        rsync指定端口 eg： rsync -e 'ssh -p 27076' xxxxx  user@hostIP:/url/



                    修改 mapreduce 和 Yarn 的配置文件

                        官方手册

                        下面配置文件的参数可以在下面网站的左下角找到
                        http://hadoop.apache.org/docs/stable/

                        ssh root@namenode
                        cd /usr/local/hadoop/etc/hadoop/
                        mv mapred-site.xml.template mapred-site.xml

                        mapreduce

                        vim mapred-site.xml

                        <configuration>
                        <property>
                            <name>mapreduce.framework.name</name>
                            <value>yarn</value>
                        </property>

                        </configuration>

                        Yarn

                        vim yarn-site.xml

                        <configuration>

                        <!-- Site specific YARN configuration properties -->

                        <property>
                                <name>yarn.resourcemanager.hostname</name>
                                <value>namenode</value>
                        </property>
                        <property>
                                <name>yarn.nodemanager.aux-services</name>  //计算框架
                                <value>mapreduce_shuffle</value>            //由开发决定
                        </property>
                        </configuration>

                    同步配置文件

                        for i in node{1..3};do rsync -avXSH /usr/local/hadoop/etc ${i}:/usr/local/hadoop/; done

                    启动
                        因为上面已经启动了dfs ,这里只需要启动yarn
                        /usr/local/hadoop/sbin/start-yarn.sh


                    检查
                        namenode
                        jps     // java ps

                            23747 SecondaryNameNode
                            24248 ResourceManager
                            24507 Jps
                            23564 NameNode

                            namenode 主机
                            注意这里ip需要与你设定的ip一致
                        http://192.168.1.63:50070/        //--namenode web页面
                        http://192.168.1.63:50090/        //--secondory namenode web页面
                        http://192.168.1.60:50075/        //--datanode web页面（node1,node2,node3）
                        http://192.168.1.63:8088/        //--resourcemanager web页面
                        http://192.168.1.60:8042/        //--nodemanager web页面（node1,node2,node3）








                        在namenode中创建文件夹

                            /usr/local/hadoop/bin/hadoop fs -mkdir /test   // -后面写 shell命令
                            /usr/local/hadoop/bin/hadoop fs -ls /
                            /usr/local/hadoop/bin/hadoop fs -put id_rsa id_rsa.pub /test  //上传本地文件到 hadoop, 前面本机文件,后面hadoop文件
                            /usr/local/hadoop/bin/hadoop fs -get /test /test1   //下载 签名写hadoop的 后面写本机,若没有目录会自己创建

                            但是只支持部分命令,touch在 hadoop 中 应该写为 touchz
                            我们将需要统计的文件上传到 hadoop文件系统中进行分析
                            cd /usr/local/hadoop  不去 目录 会table 不出 xxx.jar                          统计方式    hadoop文件非本机文件
                            ./bin/hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.7.jar wordcount /test/ /out

                    扩展节点

                        hdfs 增加节点 (修复节点操作与增加相同)

                            启动新服务器,做namenode ,免密登录
                            修改所有的/etc/hosts,增加新节点
                            安装openjdk 和 openstack-devel

                            修改namenode的 slave 文件添加node4
                            同步/usr/local/hadoop 到node4 /usr/local下
                            在该节点启动datanode
                                cd /usr/local/hadoop
                                ./sbin/hadoop-daemon.sh start datanode
                            查看
                             node4 jps
                             namenode  /usr/local/hadoop/bin/hdfs dfsadmin -report
                                4个

                            同步数据
                                    ./bin/hdfs dfsadmin --help
                                    ./bin/hdfs dfsadmin -setBalancerBandwidth 5000000  //设置同步带宽
                                    ./sbin/start-balancer.sh    //同步
                                    ./bin/hdfs dfsadmin -report

                        Yarn 节点
                            列出 yarn节点
                            ./bin/yarn node -list

                             ./sbin/yarn-daemon.sh start nodemanager  //启动
                             ./bin/yarn node -list              //查看节点
                             ./sbin/yarn-daemon.sh stop nodemanager
                             停止节点后 并不会立刻消失而是,等待一段时间后消失

                        删除节点
                            hdfs 节点

                            配置
                            cd /usr/local/hadoop/
                            vim ./etc/hadoop/hdfs-site.xml
                                在<configuration> </configuration>
                            添加
                                    <property>
                                        <name>dfs.hosts.exclude</name>
                                        <value>/usr/local/hadoop/etc/hadoop/exclude</value>
                                    </property>


                            vim ./etc/hadoop/exclude

                                node4
                             ./bin/hdfs dfsadmin -report   //查看node节点

                            Decommission Status : Normal   //正常状体

                            ./bin/hdfs dfsadmin -refreshNodes  //刷新node节点

                            Decommission Status : Decommissioned   //删除成功





                NFS 网关

                    准备 两台 1.65(nfsgw) 1.66(client) 服务器
                    NFS
                        特性:
                            HDFS 超级用户是与namenode 进行本身具有相同表示的用户,
                            超级可以执行任何操作,因为权限检查永远不会认为超级用户失败
                        注意事项:
                            安全NFS  Kerberos keytab 中的用户是代理用户
                            非安全NFS 运行网关进程的用户是代理用户

                        下面用序号表示 操作的顺序 代理用户和 配置namenode 中序号相同 表示同时进行
                    配置代理用户
                        在nfsgw上
                            1.添加用户 (同时在namenode上进行)
                                groupadd -g 800 nfsuser
                                seradd -u 800 -g 800 -r -d /var/hadoop nfsuser
                            1.查找 rpcbin/ nfs-utlis
                                rpm -qa |grep -i rpcbind
                                rpm -qa |grep -i nfs-utils
                                有了就卸载,卸载后重启
                            3.拷贝hadoop文件到 nfsgw (在namenode上操作,请参考)

                                需要等待namenode修改完core-site.xml成后 进行

                                rsync -avXSH /usr/local/hadoop/ root@192.168.1.65:/usr/local/ ###这个命令会将hadoop下的所有文件 拷贝到 /usr/local/ 下
                                rsync -avXSH /usr/local/hadoop root@192.168.1.65:/usr/local/   ###这个命令会将hadoop文件夹 拷贝到 /usr/local/ 下

                            4.修改  hdfs-site
                                    (只在nfsgw)
                                vim ./etc/hadoop/hdfs-site.xml
                                添加 如下
                                <property>
                                    <name>nfs.dump.dir</name>
                                    <value>/var/nfstmp</value>
                                </property>
                                <property>
                                    <name>nfs.exports.allowed.hosts</name>
                                    <value>* rw</value>
                                </property>


                            4.创建 临时文件夹
                               设定权限
                                mkdir /var/nfstmp

                                chown 800.800 /var/nfstmp

                                setfacl -m user:nfsuser:rwx logs/
                                getfacl logs/

                            5.启动
                                portmap
                                    必须先启动
                                ./sbin/hadoop-daemon.sh --script ./bin/hdfs start portmap

                                nfs3
                                    在portmap后启动
                                [root@nfsgw hadoop]# sudo -u nfsuser \
                                > ./sbin/hadoop-daemon.sh --script ./bin/hdfs start nfs3
                                停止服务时相反,先停止 nfs3 , 依赖关系


                        配置namenode
                            1.添加用户 (同时在nfsgw上进行)
                                groupadd -g 800 nfsuser
                                useradd -u 800 -g 800 -r -d /var/hadoop nfsuser

                            1.停止所有的hadoop服务
                                cd  /usr/local/hadoop/
                                ./sbin/stop-all.sh

                            2.修改 core-site.xml 文件

                                vim ./etc/hadoop/core-site.xml

                                <property>
                                    <name>hadoop.proxyuser.nfsuser.groups</name>
                                    <value>*</value>
                                 </property>

                                <property>
                                    <name>hadoop.proxyuser.nfsuser.hosts</name>
                                    <value>*</value>
                                 </property>

                            2.删除 不必要的文件
                                vim ./etc/hadoop/slaves
                                    删除 node4
                                vim ./etc/hadoop/exclude
                                    删除内容
                            2.同步文件
                                同步配置文件给node节点
                                 rsync -avXSH /usr/local/hadoop/etc/ root@node1:/usr/local/hadoop/etc/
                                 rsync -avXSH /usr/local/hadoop/etc/ root@node2:/usr/local/hadoop/etc/
                                 rsync -avXSH /usr/local/hadoop/etc/ root@node3:/usr/local/hadoop/etc/

                            2.启动hdfs服务

                                namenode

                                cd  /usr/local/hadoop/
                                 ./sbin/start-dfs.sh

                            3.同步 /usr/local/hadoop 给 nfsgw

                                 拷贝hadoop

                                #只是测试,用下面 :rsync -avXSH /usr/local/hadoop/ root@192.168.1.65:/usr/local/  ###这个命令会将hadoop下的所有文件 拷贝到 /usr/local/ 下
                                rsync -avXSH /usr/local/hadoop  root@192.168.1.65:/usr/local/   ###这个命令会将hadoop文件夹 拷贝到 /usr/local/ 下

                            配置client

                                挂载hdfs 文件系统  (需要等待,nfsgw 启动完成后才能挂载)
                                安装
                                    yum -y install nfs-utils
                                挂载
                                    mount -t nfs -o \
                                    vers=3,proto=tcp,nolock,noatime,sync,noacl 192.168.1.64:/  /mnt/  //挂载

                                由于hdfs只支持的nfs3协议,所以这里 也要使用 nfs3 协议
                                vers=3
                                使用tcp作为传输协议
                                proto=tcp
                                不支持NLM  内核?
                                nolock
                                禁用access time
                                noatime
                                禁用acl权限
                                noacl
















    补充 :
       linux 文件的三个时间信息 atime mtime ctime

            stat  [选项] 文件
                stat可以显示inode(索引节点)信息也可以查看一个文件的某些信息 部分Metadata(元数据)
            access time  最后一次访问时间,没有改动
            modify time   最后一次修改文件的时间
            change time  最后一次对文件属性改变的时间,包括权限 大小 属性

            inodb(index node) 索引节点
                作用:用于储存文件和目录基本信息

                block

                    磁盘在格式化的时候会被分为两部分 数据区和inodb区,并且在这个时候会设定iNode区域的大小
                    比如我们一般ntfs文件系统 每个块(block)大小为4k,由8个扇区(sector)组成block,每个sector存储512字节,一共4k,
                    所以具有文件系统的磁盘也被叫做块设备
                    当然block的大小的设定一般是和我们存储文件的大小有关,文件越大相应的block应该设置越大,反之,需要注意的是block越小磁盘寻道的时间就会变长,

                iNode节点的大小

                    每个文件必须要有一个iNode,所以可能会有iNode节点被用完但是磁盘还是有空间的情况,这是我们无法继续创建文件
                    每个inode节点的大小，一般是128字节或256字节。
                    查询iNode大小
                        sudo dumpe2fs -h /dev/sda2 | grep "Inode size"   ## /dev/sda2被查询的分区
                    查询硬盘分区iNode的总数和
                        df -i
                    关于如何修改iNode的大小可以参考,我先鸽了
                        https://blog.csdn.net/lemontree1945/article/details/80744009

                inodb区主要用来存放 文件的元数据
                    元数据包含如下信息
                       文件的字节数
                　　    文件拥有者的User ID
                　　    文件的Group ID
                　　    文件的读、写、执行权限
                　　    文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。
                　　    链接数，即有多少文件名指向这个inode
                　　    文件数据block的位置
       关于 kill
            INT, TERM 立刻终止
            QUIT 平滑终止
            USR1 重新打开日志文件
            USR2 平滑重载所有worker进程并重新载入配置和二进制模块
            php-fpm进程停止
            1. 查看 master 进程
                ps aux |grep fpm
                root     13380  0.0  0.2 151952  4940 ?        Ss   Sep18   0:01 php-fpm: master pro

            2. kill -QUIT PID

               kill -QUIT 13380   #结束进程

            这个方法适合 不生产 php-fpm.pid 使用 需要生成 可以参考https://www.cnblogs.com/GaZeon/p/5421906.html

DAY05
    一.zookeeper
        是什么

            开源的分布式应用程序协调服务

        能干嘛

            保证数据在集群之间的事物一致性

            作用: 保证节点信息的一致性
                 服务发现



        zookeeper 运用场景

            集群分布式锁
            集群统一命名服务
            分布式协调服务

        角色与特性

        角色与选举
            zookeeper角色与选举
                -服务在启动是的时候是没有角色的(LOOKING)
                -角色是通过选举产生的
                -选举产生一个Leader,剩下的时Follower
            选举leader原则
                -集群中超过半数的机器投票选择Leader
                -加入集群中有Nn台服务器,那么leader必须得到n/2+1 台服务器的投票
                -Leader死亡,重新选举Leader
                -若down机超过一般,则集群挂掉
                -若无法得到足够的投票数量,就重新发起投票,若参与投票机器不足n/2+1
                集群停止工作
                -Observer不计算在投票总设备数量里面


        安装
            准备 host 安装java-1.8.0.openjdk
                /etc/hosts  每台
                192.168.1.60 node1
                192.168.1.61 node2
                192.168.1.62 node3
                192.168.1.63 namenode


                tar -xf zookeeper-3.4.13.tar.gz

                mv zookeeper-3.4.13 zookeeper

                mv zookeeper /usr/local/


                修改配置文件

                    cd /usr/local/zookeeper/conf/


                    mv zoo_sample.cfg zoo.cfg


                    chown root:root zoo.cfg
                    vim zoo.cfg
                    添加如下
                    server.1=node1:2888:3888
                    server.2=node2:2888:3888
                    server.3=node3:2888:3888
                    server.4=namenode:2888:3888:observer

                    mkdir /tmp/zookeeper
                    ssh node1 mkdir /tmp/zookeeper
                    ssh node2 mkdir /tmp/zookeeper
                    ssh node3 mkdir /tmp/zookeeper

               编辑 myid 文件 与 /usr/local/zookeeper/conf/zoo.cfg 中的 service 对应

                    ssh node4 'echo 4 > /tmp/zookeeper/myid'
                    ssh node3 'echo 3 > /tmp/zookeeper/myid'
                    ssh node2 'echo 2 > /tmp/zookeeper/myid'
                    ssh node1 'echo 1 > /tmp/zookeeper/myid'
                每一台服务器都要手动启动,全部启动后才能查看状态
                /usr/local/zookeeper/bin/zkServer.sh start   //启动
                /usr/local/zookeeper/bin/zkServer.sh status  //查看状态

               老师给的 脚本  在namenode下运行, 使用zookeeper 提供的api借口查询
                    ./zkstats node{1..3}

                    #!/bin/bash
                    function getzkstat(){
                        exec 2>/dev/null
                        exec 8<>/dev/tcp/$1/2181
                        echo stat >&8
                        Msg=$(cat <&8 |grep -P "^Mode:")
                        echo -e "$1\t${Msg:-Mode: \x1b[31mNULL\x1b[0m}"
                        exec 8<&-
                    }

                    if (( $# == 0 ));then
                        echo "${0##*/} zk1 zk2 zk3 ... ..."
                    else
                        for i in $@;do
                            getzkstat ${i}
                        done
                    fi

    二.kafka
        是什么

            分布式消息系统
            kafka是使用Scala编写
            一种消息中间件
        为什么使用

            解耦 冗余 提高扩展性 缓冲
            保证顺序 灵活 削峰填谷
            异步通信
        kafka 角色

            角色/集群结构
                producer 生产者,负责发布消息
                consumer 消费者,负责读取处理消息
                topic   消息的类别
                parition 每个topic集群包含一个/多个partition
                broker kafka集群包含一个或多个服务器

            kafka 通过 zookeeper 选举Leader


        安装

            安装在node1-3上

                 tar -xf kafka_2.12-2.1.0.tgz
                 mv kafka_2.12-2.1.0 /usr/local/kafka
                 修改配置文件 /usr/local/kafka/config/server.properties
                     cd /usr/local/kafka/config
                     vim server.properties
                         broker.id=22
                         zookeeper.connect=node1:2181,node2:2181,node3:2181




                 拷贝 kafka 到其他主机，并修改 broker.id ,不能重复
                   for i in 63 64; do rsync -aSH --delete /usr/local/kafka 192.168.1.$i:/usr/local/; done



                    vim /usr/local/kafka/config/server.properties
                        broker.id=23

                    vim /usr/local/kafka/config/server.properties
                        broker.id=24
        启动

            启动 kafka 集群（node1，node2，node3启动）
               /usr/local/kafka/bin/kafka-server-start.sh -daemon /usr/local/kafka/config/server.properties
               jps查看

            验证配置，创建一个 topic
                /usr/local/kafka/bin/kafka-topics.sh --create --partitions 1 --replication-factor 1 --zookeeper localhost:2181 --topic aa

            模拟生产者，发布消息
                /usr/local/kafka/bin/kafka-console-producer.sh \
                --broker-list localhost:9092 --topic aa
                123
            模拟消费者，接收消息
                /usr/local/kafka/bin/kafka-console-consumer.sh \
                --bootstrap-server node1:9092 --topic aa
                123


    三.hadoop 高可用

        原因

        -由于namenode是hdfs的核心配置,而]HDFS又是hadoop核心组件,namenode在hadoop集群中至关重要
        -namenode宕机,将导致集群不可用,若namenode数据丢失将导致整个集群的数据丢失,
            而namenode的数据更新有比较频繁,实现namenode的高可用是必须的

        解决方案
                HDFS with nfs
                HDFS with qjm

            方案对比
                HA方案对比
                    -都可以实现热备份
                    -都是一个active nn 和一个 standby nn
                    -都是用zookeeper和ZKFC来实现自动失效恢复
                    -失效切换都是用Fencin配置的方法来active nn
                    -nfs 数据共享变更方案把数据存储在共享存储里,我们还需要考虑nfs的高可用
                    -qjm 不需要共享存储,但是需要让每一个dn都知道两个nn的位置,
                     并把块信息和心跳包发送个active 和standby两个nn

                使用原因 (qjm)
                    -解决了namenode 单点故障
                    -hadoop 给出了HDFS的高可用ha方案:HDFS通常由两个namenode组成,
                     一个active nn 和一个 standby nn. active namenode对外提供服务,
                     比如处理来自客户端的RPC请求,而standby nn 则不能对外提供服务,仅仅同步active nn的状态,
                     以便在它失败时进行切换

                nn 高可用架构
                    -为了让standby node 和active node 同步,这两个node 都与一组jns的互相独立的进程保持通信(journal nodes)
                     当active node更新namespace,它将记录修改日志发送给jns的多数排.standby node将会从 jns 中读取edits
                     ,并持续关注它们对于日志的变更
                    -standby node 将日志变更应用在自己的namespace中,当failover[故障切换] 发生standby将会在提升自己为active之前,
                     确保能够从jns中读取所有的edits,即在 failover 故障切换 发生前standby持有 namespace与active保持完全同步
                    -由于namenode更新频繁,为了确保主备数据一致性,为了支持快速 failover ,standby node 持有集群中blocks的最新位置是
                     非常必要的. 为了这一目的datanode需要同时配置两个namenode地址,同时和它建立心跳链接,并把blocks位置发送给nn

                    -需要注意的是任何时刻只能有一个active namenode,负责会导致集群状态混乱,两个nn将会有两种不同的数据状态,将导致数据丢失或者状态异常,这种情况称为
                     split-brain (脑列,三节点通信阻塞,集群中不同的datanode,看到不同的 active name node)
                    -对于jns来说 任何时候只能有一个nn 作为writer ; 在fillover 故障切换期间,原来的standby node 将会接管active的所有职能,并负责向jns写入日志记录,
                     这种机制阻止了其他的namenode处于active状态的问题


        配置

            主要修改
                  如下文件并将修改好的文件传递给node1-3 nn和 nnbackup
                  vim core-site.xml
                  vim hdfs-site.xml
                  vim yarn-site.xml

            同步配置文件
                for i in {node1,node2,node3,nn,nnbackup}; do  rsync -avXSH /usr/local/hadoop/etc/ root@192.168.1.$i:/usr/local/hadoop/etc/; done
            初始化集群
                删除 使用过的存储初始化目录
                    rm -rf /var/hadoop/*
                    ssh node1 rm -rf /var/hadoop/*
                    ssh node2 rm -rf /var/hadoop/*
                    ssh node3 rm -rf /var/hadoop/*

                初始化 nn1 zk集群
                    /usr/local/hadoop/bin/hdfs zkfc -formatZK
                node 1-3 启动journalnode服务
                    /usr/local/hadoop/sbin/hadoop-daemon.sh start journalnodejps
                格式化 nn1

                    /usr/local/hadoop//bin/hdfs namenode -format
                nn2 数据同步到本地 /var/hadoop/dfs
                    rsync -aSH namenode:/var/hadoop/dfs/ /var/hadoop/

                初始化 nn1 jns
                    /usr/local/hadoop/bin/hdfs namenode -initalizeSharedEdits

                node 1-3 停止journalnode 服务
                    /usr/local/hadoop//sbin/hadoop-daemon.sh stop journalnode
            启动集群
                nn1
                    /usr/local/hadoop/sbin/start-dfs.sh
                    /usr/local/hadoop/sbin/start-yarn.sh
                nnbackup  启动热备
                     /usr/local/hadoop/sbin/yarn-daemon.sh start resourcemanager
            检查集群状态
                resource manager 状态
                /usr/local/hadoop/bin/yarn rmadmin -getServiceState rm2
                nn状态
                /usr/local/hadoop/bin/hdfs haadmin -getServiceState nn1

            查看节点
                /usr/local/hadoop/bin/hdfs dfsadmin -report
                /usr/local/hadoop/bin/yarn node -list
            访问集群文件
                 /usr/local/hadoop/bin/hadoop fs -mkdir /input/
                 /usr/local/hadoop/bin/hadoop fs -ls hdfs://nsd1903/
                 ### 集群中定义的 /usr/local/hadoop/etc/hadoop/core-site.xml

            主从切换
                /usr/local/hadoop/sbin/hadoop-daemon.sh stop namenode


               test


    k8s 是容器的集群管理系统,一个开源的平台,实现容器集群的自动化部署,升级,管理

    master 节点  (主节点)
        API-server  scheduer  controler-manager etcd
            API-server 提供系统对外的接口, 供客户端和其他组件调用
            scheduler 负责 对集群内部的资源进行调度
            controller-manager 负责管理控制器
    node 节点
        docker kubelet kube-proxy fluentd kube-dns pod

        pod 是 kubenetes 最基本的操作单元
        pod 代表集群中运行的一个进程 内部封装了一个或多个紧密相关的容器
        service 可以看做一组提供相同服务的pod对外访问接口
        docker
        kubelet 负责监控指派到他所在node上的pod, 包括创建 修改 监控 删除
        kube-proxy 主要为pod提供代理
        fluentd 日志收集 存储 查询


    k8s 安装
        配置 yum 源 为 华为云的

                wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.huaweicloud.com/repository/conf/CentOS-7-anon.repo
        需要注意的是  华为云 默认提供的  kubernetes 版本 过低  我们需要手动指定 版本 //使用下面的 yum源
            安装 1.10.版本的 kubernets
                [kubernets-110]
                name=110
                #baseurl=http://mirror.centos.org/centos/$releasever/os/$basearch/
                gpgcheck=0
                enabled=1
                baseurl=https://mirrors.huaweicloud.com/centos/7/virt/x86_64/kubernetes110/


        master
        node1
        node2

        master节点
         安装
            docker etcd kubernetes-master kubernetes-client
            修改 docker 配置文件

            vim  /etc/sysconfig/docker
                添加如下 两行
                ADD_REGISTRY='--add-registry 192.168.1.242:5000'
                NSECURE_REGISTRY='--insecure-registry 192.168.1.242:5000'

         设置 开机自启
                kube-apiserver.service kube-controller-manager.service kube-scheduler.service etcd.service

                vim /etc/etcd/etcd.conf
                    ETCD_LISTEN_CLIENT_URLS="http://192.168.1.242:2379"



                vim /etc/kubernetes/config
                    KUBE_MASTER="--master=http://192.168.1.242:8080"


                vim /etc/kubernetes/apiserver
                    8: KUBE_API_ADDRESS="--insecure-bind-address=0.0.0.0"
                   17: KUBE_ETCD_SERVERS="--etcd-servers=http://192.168.1.242:2379"  /// 这里可以填写多个 etcd 服务器 防止单点故障 但是这里只有一个所以 只写一个
                   23: 删除 server account 这是用来认证产生 秘钥来进行认证的 当 node 加入 集群是需要 秘钥来认证
                /etc/kubernetes/controller-manager
                /etc/kubernetes/scheduler
                这两个文件使用默认值 即可
         启动服务 查看状态
                systemctl start etcd kube-apiserver.service kube-controller-manager.service kube-scheduler.service
                systemctl status etcd kube-apiserver.service kube-controller-manager.service kube-scheduler.service
         查看端口
                ss -antulp
                    2379 2380 8080
         检查状态
                [root@ecs-5287 ~]# kubectl get cs
                NAME                 STATUS    MESSAGE             ERROR
                scheduler            Healthy   ok
                controller-manager   Healthy   ok
                etcd-0               Healthy   {"health":"true"}
        node节点
            安装 docker  kubernetes-node

            修改配置文件
               将master 的 docker /etc/sysconfig/docker 复制到 node: /etc/sysconfig/

               vim /etc/kubernetes/config
                   ETCD_LISTEN_CLIENT_URLS="http://192.168.1.242:2379"

               vim /etc/kubernetes/kubelet

                    KUBELET_ADDRESS="--address=0.0.0.0"
                    KUBELET_HOSTNAME="--hostname-override=YOU-HOST-NAME"  这里写的主机名需要你能ping同
                 14 添加如下
                    KUBELET_ARGS
                    --kubeconfig=/etc/kubernetes/kubelet.kubeconfig
                    --pod-infra-container-image=pod-infrastructure:latest   // 通过这个 镜像 来启动 容器

                    curl http://192.168.1.242:5000/v2/_catalog
                    {"repositories":["centos","kubernetes-dashboard-amd64","pod-infrastructure"]}

               vim /etc/kubernetes/kubelet.kubeconfig
                YML 格式文件
                    apiVersion: v1
                    kind: Config
                    clusters:
                      - cluster:
                          server: http://192.168.1.242:8080   ##MASTER 自身IP
                        name: local
                    contexts:
                      - context:
                          cluster: local
                        name: local
                    current-context: local
                启动服务 检查 状态
                systemctl enable docker kubelet.service kube-proxy.service
                systemctl restart docker kubelet.service kube-proxy.service
                systemctl status docker kubelet.service kube-proxy.service

            master
                查看集群
                [root@ecs-5287 ~]# kubectl get node
                NAME      STATUS    ROLES     AGE       VERSION
                node1     Ready     <none>    9m        v1.10.3
                node2     Ready     <none>    20s       v1.10.3


        修改网络
            master
                vim /etc/etcd/etcd.conf

                    8 ETCD_LISTEN_CLIENT_URLS="http://0.0.0.0:2379"   ///// 监听所有地址

                systemctl restart etcd.service  重启服务

                创建子网
                etcdctl mk /atmoic.io/network/config '{"Network": "10.254.0.0/16", "Backend": {"Type": "vxlan"}}'
                etcdctl ls /atmoic.io/network/config
                etcdctl get /atmoic.io/network/config  查看
                    {"Network": "10.254.0.0/16", "Backend": {"Type": "vxlan"}}

            在所有 节点上 安装 flannel
                yum -y install flannel
            vim /etc/sysconfig/flanneld

                FLANNEL_ETCD_ENDPOINTS="http://192.168.1.242:2379"     /// master ip

            systemctl restart docker flanneld

                启动时 先启动 flanneld 然后是docker
                关闭时 docker 然后 flanneld

        node 节点
        ##########我的 服务有问题  flanneld 重启失败
        ip 不变化
        重启成功 ip 会变成 10.254.0.0/16 网段  明天检查 视频  LINUX第四阶段-PROJECT3-Day04  早上201.6
        同步 配置文件 重启服务

        rsync -av 192.168.1.242:/etc/sysconfig/flanneld /etc/sysconfig/flanneld

        systemctl restart docker flanneld





.....................
DAY01
    一.xshell
        1.上传/下载linux的文件到win
            yum -y install lrzsz

                sz 文件名称   下载
                linux进入目标目录,在win下选择直接拖入终端 就上传完成了.

                只能对 文件操作 不能对文件夹操作,所以我们下载/上传文件夹需要先压缩为压缩包在上传/下载.
        2.同时对多个终端发送相同的命令
            右下角的三条横线 选择 全部标签 就可以对现在已经打开的全部标签发送相同的命令
    二.web集群的 vip

        如下的拓扑图 我们只需要一个vip (公网ip)
                lvs

      web1  web2  web3 web4

      核心

      jump(跳板机,也会安装运维审计服务) 不但第二yum源还但任 ansible 服务器, 我们通常通过 jump服务器来管理其他服务器


                jump

      ser1    ser2      ser3  ****



      我们在云主机上创建的 xxx.pem文件 实际上是 id_rsa 私钥文件 设置文件为属性 400,.ssh/文件夹的属性 700,
      而使用ansible 有需要 免密登录,在创建主机的时候 选择该秘钥,就可以通过jump跳板服务器来远程管理内网服务器.


            ifconfig [interface] IP/mask
            ifconfig eth0:1 192.168.1.100/24

                    立即生效,重启失效

            负载均衡

            nginx     cache,web
             lvs       4 层         问题: 超不过200台,不能跨vlan   直到lvs的 full-net出现,解决了不能跨vlan,需要修改内核.
            haproxy    4/7层

            这个架构的高扩展我们直接创建新的  集群和 nginx 在接入 lvs 即可

                            lvs         4层 负载均衡

                       nginx    nginx    7层 动静分离

                     web集群1   web 集群2

                                            超大型网络架构  lvs-full-net+DPDK = DPVS
                                                OSPF

                            lvs                 lvs               lvs

                       nginx    nginx        nginx    nginx    nginx    nginx

                     web集群1   web 集群2   web集群1   web 集群2  web集群1   web 集群2




            已经做成 基于路径的 动静分离

            将外网ip绑定在 192.168.1.99 提供了动静分离 上

            访问 image下文件是静态 页面
                http://139.9.94.171/image/test.html   显示 hostname      gif /jpg
                    显示web4/web5
            访问 /下文件是动态 页面  Tomcat 提供服务
                http://139.9.94.171/test.jsp    显示hostname和ip
                显示 时间和 web1/2/3
            但是还没有做ceph 做完ceph后将文件转移到 ceph中来做 网站根目录


            tomcat 启动  /usr/local/tomcat/bin/startup.sh  检查 8080端口

            nginx 启动  /usr/local/nginx/sbin/nginx

            记得启动 1.99 的nginx调度


            重启集群后 记得 挂载ceph

                 tomcat
                 rbd map vm1-image
                 mount /dev/rbd0 /usr/local/tomcat/webapps/ROOT/

                 nginx
                 rbd map vm1-image
                 mount /dev/rbd0 nginx/usr/local/nginx/sbin/nginx



             数据库使用mariadb  root密码为 a  mysql -uroot -pa
                主从 同步 repluser 密码为 a
                    slave 1 slave2 repluser  a

                设置 mha vip 1.110
                http://tts.tmooc.cn/ttsPage/LINUX/NSDTN201904/RDBMS2/DAY04/CASE/01/index.html#case1
                到这里这里了
                4）在当前主服务器部署vip地址

                mha启动 命令
                masterha_manager --conf=/etc/mha/app1.cnf  --remove_dead_master_conf --ignore_last_failover

               ##############################
                manager_workdir=/var/log/masterha/app1
                manager_log=/var/log/masterha/app1/manager.log
                master_ip_failover_script=/etc/mha/master_ip_failover

                1.40:
                    检查 ssh   masterha_check_ssh --conf=/etc/mha/app1.cnf
                    检查 主从   masterha_check_repl --conf=/etc/mha/app1.cnf
                    启动 mha集群masterha_manager --conf=/etc/mha/app1.cnf  --remove_dead_master_conf --ignore_last_failover


                1.50/1.51 读写分离
                    启动
                     maxscale -f /etc/maxscale.cnf
                     管理
                     maxadmin  -uadmin -pmariadb -P4016


                    使用user test  pass a 链接1.50 的 4006

                     mysql -h192.168.1.50 -P4006 -utest -pa

                     进行 读写 操作 ,写只向主库写, 读 可以向从库和主库读


                1.52  1.53 作为 haproxy+keeplive 为 maxscale提供高可用和负载均衡


                         haproxy(负载均衡) 中定义的 端口 4015 作为本机监听端口,将本机端口的访问数据转发给 maxscale读写分离集群
                            keeplived和haproxy配合使用 在 haproxy的 listen 中指定 监听的 端口  keeplived 则保证 vip 就好
                            eg  : haproxy 监听 80 端口

                           listen  websrv-rewrite 0.0.0.0:80
                           balance roundrobin
                           server  web1 192.168.2.100:80 check inter 2000 rise 2 fall 5   //2000 表示单次检测时间间隔 ms
                           server  web2 192.168.2.200:80 check inter 2000 rise 2 fall 5

                            访问 mysql -h192.168.1.52/53 -P4015 -utest -pa  // 测试 haproxy
                                    数据操作
                            访问 mysql -h192.168.1.111 -P4015 -utest -pa   //测试 keeplive + haproxy

                                停止 keeplive 检查 vip是否会 转移到另外一台的 keeplive+haproxy上
                                    数据操作

                54 55 redis 主从 哨兵模式

                    /etc/init.d/redis_6354  stop start  启动停止命令

                    55 启动哨兵模式   redis-sentinel /etc/sentinel.conf


ip  172.40.50.117    vnc 7000

庞丽静  静静

panglj@tedu.cn

1903   13   402

学生

不迟到 不早退  认证听讲  专心做实验

第三阶段 （数据库管理员  DBA ）     （运维工程师 DBA）
1  RDBMS---MYSQL     2 NOsql---Redis  3 监控与安全

RDBMS1---day01
一、搭建数据库服务器
	1.1 相关概念
	1.2 在50主机部署mysql数据库服务      练习到 11：35
		解包
		安装软件包
		启动mysqld服务
		查看服务进程和端口
		查看初始登陆密码
		使用初始密码登陆
		修改登陆密码
		断开连接
		使用修改后的密码登陆
		修改密码策略
		根据新密码策略设置密码
		使用新密码登陆

]# tar -xvf  mysql-5.7.17.tar
]# ls *.rpm
]# yum -y  install mysql-community-*.rpm
]# systemctl  start mysqld
]# ls  /var/lib/mysql
]# systemctl  enable mysqld
]# netstat  -utnlp  | grep  :3306
]# ps -C  mysqld

		]# grep  password  /var/log/mysqld.log
		]# mysql -hlocalhost -uroot -p'f<tbekh-d8Y!'
		mysql> alter user  root@"localhost" identified by "123qqq...A";
		mysql> exit

]# mysql  -uroot -p123qqq...A
mysql> show variables like "%password%";
mysql> set global validate_password_length=6;
mysql> set global validate_password_policy=0;
mysql> alter user  root@"localhost" identified by "tarena";
mysql> exit

	]# mysql  -uroot -ptarena
	]# vim /etc/my.cnf
		[mysqld]
		validate_password_length=6
		validate_password_policy=0
	:wq

二、数据库服务的基本使用
	2.1 连接方式
	2.2 数据存储流程 ?
	2.3 mysql管理环境 (SQL命令)

练习25分钟到 13：55
	2.4 库管理命令 （创建新库 查看已有的库 切换库 删除库 库名命名规则）
	2.5 表管理命令 （查看已有的表  创建新表 查看表结构 查看表记录）
	2.6 记录管理命令（查看已有记录 插入新记录 修改记录 删除记录）

设置表记录可以写中文
		]# LANG="zh_CN.UTF-8"
mysql> create table db1.学生表(
   姓名 char(10),
   家庭地址 char(20)
   ) DEFAULT CHARSET=utf8;

mysql> insert into db1.学生表 values("张三丰","武当山");
mysql> insert into db1.学生表 values("张四丰","武台山");
mysql> select  * from  db1.学生表;


三、MySQL数据类型
	3.1 字符类型  char   varchar

	3.2 数值类型  练习到 15：35
		整数类型  tinyint  smallint int  bigint
		浮点类型  float  double
mysql> create table db1.t5 (name char(10), level  tinyint );
mysql> insert into  db1.t5 values ("zbj",-1);
mysql> insert into  db1.t5 values ("zbj",-129);
mysql> insert into  db1.t5 values ("zbj",198);

mysql> create table db1.t6 (name char(10), level  tinyint unsigned);
mysql> insert into  db1.t6 values ("zbj",-1);
mysql> insert into  db1.t6 values ("zbj",0);
mysql> insert into  db1.t6 values ("zbj",256);
mysql> insert into  db1.t6 values ("zbj",25);
mysql> insert into  db1.t6 values ("zbj",25.22);
mysql> insert into  db1.t6 values ("zbj",25.52);

mysql> create  table db1.t3(pay float , id double);
mysql> insert into db1.t3 values(9999.23,9999.77);

mysql> create  table db1.t4( pay float(5,2) , id double(4,2) );
mysql> insert into db1.t4 values(9999.23,9999.77);

mysql> create table  db1.t7(stu_num int , name char(5) ,
       age tinyint ,pay float ,money float(7,2) );

mysql> desc  db1.t7 ;
				练习到 15：45

	3.3 日期时间类型
		年    日期   时间   日期时间
		year  date   time   datetime/ timestamp

create table db1.t8(      休息到 16：15
name  char(15),
your_s    year,
birthday  date,
up_class  time,
party  datetime
);

desc  db1.t8 ;

insert into  db1.t8  values
("bob",1990,20191120,083000,20190607203000);

当year类型 使用2位数赋值时：
01~69视为  2001~2069
70~99视为  1970~1999
insert into  db1.t8  values
("tom",77,20191120,083000,20190607203000);

select  * from  db1.t8 ;

当未给timestamp字段赋值时，自动以当前系统时间赋值，而datetime 值为 NULL (空)

create table  db1.t9(  练习到 16:30
meetting  datetime,
party	  timestamp
) ;

insert into  db1.t9 values (20190606162000,20190606162000);

insert into  db1.t9(meetting) values (20180707093000);

insert into  db1.t9(party) values (20160707093000);

select  *  from  db1.t9;

可以使用时间函数给字段赋值

mysql> insert into db1.t8 values
( "jack" , year(now()) , date(now()) , curtime() , now()  );

	3.4 枚举类型
	enum 单选
	set  多选

create table db1.t10 (
 name  char(10),
 sex   enum("boy","girl","no"),
 likes set("eat","game","piao","du","film")
);


mysql> desc db1.t10;

insert into  db1.t10 values ("jack","man","a,b,c");
insert into  db1.t10 values ("jack","boy","eat,piao");

select  * from  db1.t10 ;

RDBMS1_day01 内容总结
一、搭建的mysql数据库服务器：什么是数据库？ 数据库服务软件？
			        mysql优点？ 应用场景？ LAMP / LNMP
			      安装mysql软件 启动服务  使用初始密码登陆
				修改登陆密码  设置密码策略

二、基本使用？ 把数据库存储到mysql服务器上的步骤 ？
	       连接方式？
	       库的基本管理命令 表的基本管理命令  记录管理
		SQL命令使用规则

三、数据类型： 字符  数值  日期时间  枚举



+++++++++RDBMS1_day02
一、表结构
	2.1 约束条件
		作用：限制给表字段赋值
		查看字段的约束条件： desc 库.表；
		约束条件包括那些：
				 是否允许为空 (null)    not null
				 键值
				 默认值  default 值
				 额外设置

mysql> create table db1.t21(
    -> name char(10) not null,
    -> age  tinyint  unsigned  default  25,
    -> sex  enum("m","w") not null  default "w"
    -> );
mysql> insert into  db1.t21(name)values("jerry");
mysql> insert into  db1.t21    values("bob",29,"m");

mysql> insert into  db1.t21    values(null,null,null);

mysql> insert into  db1.t21    values("null",null,null);
ERROR 1048 (23000): Column 'sex' cannot be null
mysql>

mysql> insert into  db1.t21    values("null",null,"m");
mysql> select  * from  db1.t21;


	2.2 修改表结构
		命令格式  alter  table  库.表 执行动作;
		执行动作包括如下：
	        		add  添加新字段
mysql> alter table db1.t10  add  email  varchar(50) default "stu@tedu.cn" ;
mysql> alter table  db1.t10 add  stu_num char(9) first;
mysql> alter table db1.t10  add  age  tinyint  unsigned  not null default 19  after name;

练习到 10：25

				drop 删除已有字段
mysql> alter table db1.t10 drop email ,drop stu_num ;

				modify  修改字段类型
注意：修改的字段类型与已经存储的数据冲突时，不允许修改类型

mysql> alter table db1.t10  modify  name varchar(15)   default  "" ;


mysql> alter table db1.t10
           modify age tinyint unsigned not null default 19 after sex;

				change  修改字段名
mysql> alter table  db1.t10
           change likes loves set('eat','game','piao','du','film') ;
				rename  修改表名

mysql> alter table db1.t10 rename db1.classinfo;

		休息到 11：15
二、MySQL 键值
	键值类型：
		普通索引 index  ***
		唯一索引 unique
		主    键 primary  key ***
		外    键 foreign  key ***
		全文索引 fulltext

	作用：约束如何给字段赋值

	普通索引（index）
		什么是索引（索引介绍）
		为什么要使用索引（索引优点与缺点）
		使用索引：
			 使用规则 ？
			 查看 desc  库.表  key
			      show   index  from  表名 \G;

			 创建索引:
				建表时创建索引字段
					create  table db1.t22(
						class  char(9),
						name  char(15),
						age int,
						index(name),index(age)
					 );

					desc  db1.t22;

				        show index  from  db1.t22\G;

				在已有表里创建索引字段
					mysql> create index xixi
							on  stuinfo(name);

			 删除索引:
				mysql> drop  index  name on t22;

	2.2 主    键 primary  key
			作用：限制字段赋值
			使用规则？
			使用主键：
				1 创建主键
					1.1 建表时创建主键
mysql> create table  db1.t23(
    -> name char(10) primary key,
    -> age int,
    -> pay float(7,2)
    -> );

mysql> desc  db1.t23 ;
mysql> insert into  db1.t23 values(null,19,28800.88);
mysql> insert into  db1.t23 values("bob",19,28800.88);
mysql> insert into  db1.t23 values("bob",29,38800.88);

					1.2 在已有表里添加主键
		mysql> select  * from  db1.classinfo;
		mysql> delete from  db1.classinfo;
		mysql> alter table  db1.classinfo add  primary key(name);
		mysql> desc  db1.classinfo;

练习到 14：45

				2 创建复合主键
				    约束方式： 主键字段的值不可以同时重复
	PRI       PRI
	clientip  serport  status
 	1.1.1.1   22        yes
	1.1.1.1   22        yes

create table db1.t24(
clientip  char(15),
serport	  int,
status    enum("yes","no"),
primary key(clientip,serport)
);

mysql> insert into db1.t24 values ("1.1.1.1",22,"yes");
mysql> insert into db1.t24 values ("1.1.1.1",22,"no");
mysql> insert into db1.t24 values ("1.1.1.1",22,"yes");
mysql> insert into db1.t24 values ("1.1.1.1",25,"yes");
mysql> insert into db1.t24 values ("1.1.1.1",25,"no");
mysql> insert into db1.t24 values ("2.1.1.1",25,"no");

				3 primary key与auto_increment连用
						自增长
						赋值时 字段的值字段加1

 id  name  age sex
 1   bob   19  boy
 2  tom   21  boy
 3  jerry  25  boy
 4  lucy   18  girl

create table  db1.t25(
 id int primary key  auto_increment,
 name char(15),
 age tinyint ,
 sex enum("boy","girl")
);

mysql> desc db1.t25 ;

mysql> insert into  db1.t25(name,age,sex)values("bob",19,"boy");

mysql> insert into  db1.t25(name,age,sex)values("tom",21,"boy");

mysql> select  * from  db1.t25;

mysql> insert into db1.t25 values (6,"bob",19,"girl");
mysql> select  * from  db1.t25;

mysql> insert into  db1.t25(name,age,sex)values("jack",27,"boy");
mysql> select  * from  db1.t25;

mysql> delete from   db1.t25;
mysql> select  * from db1.t25;

mysql> insert into  db1.t25(name,age,sex)values("jack",27,"boy");
mysql> select  * from db1.t25;

				4 删除主键
				mysql> alter table db1.t23 drop  primary key;

				mysql> alter table  db1.t24 drop primary key;

			mysql> alter table  db1.t25  modify id int;
			mysql> alter table  db1.t25 drop  primary key;


	2.3 外    键 foreign  key
			作用：限制给字段赋值，插入记录时，
				     字段值在另一个表字段值范围内选择。

			使用规则:
				1 表存储引擎必须是innodb
				2 字段类型要一致
				3 被参照字段必须要是键值类型的某一种，通常是p					rimary key

			命令格式：

			create table 库.表（
				字段列表，
   foreign   key(字段名)  references  表名(字段名)
   on  update  cascade
   on  delete    cascade
   )engine=innodb;


yg 员工表
	编号 姓名
 	1    bob
	2    tom
 	3    bob

create table db1.yg(
yg_id int  primary key auto_increment,
name  char(20)
)engine=innodb;

insert into db1.yg(name)values("bob");
insert into db1.yg(name)values("tom");
insert into db1.yg(name)values("bob");
select  * from  db1.yg;
gz 工资表
	编号 工资
	 1   30000
	 2   50000

create table db1.gz(
gz_id int,
pay  float(7,2),
foreign key(gz_id) references yg(yg_id)
on  update  cascade on delete cascade
)engine=innodb;

mysql> desc db1.gz;
mysql> show create table db1.gz\G;
mysql> select  * from  db1.gz;

			测试外键：
mysql> insert into db1.gz values(4,50000);

ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (`db1`.`gz`, CONSTRAINT `gz_ibfk_1` FOREIGN KEY (`gz_id`) REFERENCES `yg` (`yg_id`) ON DELETE CASCADE ON UPDATE CASCADE)


mysql> insert into db1.gz values(1,50000);

mysql> insert into db1.gz values(2,45000);

mysql> insert into db1.gz values(3,35000);

mysql> select  * from db1.gz;

					练习 到 17：52

mysql> update db1.yg  set yg_id=4 where yg_id=3;
mysql> select  * from  db1.yg;
mysql> select  * from  db1.gz;


mysql> delete from db1.yg where yg_id=1;
mysql> select  * from  db1.yg;
mysql> select  * from  db1.gz;

mysql> delete from db1.gz;
mysql> alter table db1.gz add primary key(gz_id);

		删除外键
			mysql> show create table db1.gz\G;
			mysql> alter table db1.gz drop foreign key gz_ibfk_1;


		50  51 52 53

		前任信息表
		婚宴邀请表 （邀请人必须在前任信息表里选）
++++++++RDBMS1_DAY02 学习内容
1 约束条件 ： 作用？ 包括那些？ 约束条件相关的命令 ？

2 修改表结构： 命令格式 ？ 执行动作有那些？

3 mysql键值 ： 键值类型 ？  普通索引的使用？ 主键的使用 ？ 外键的使用？


++++++++RDBMS1_DAY03
一、数据导入导出

	修改搜索路径
	]# mkdir  /myload
	]# chown  mysql  /myload
	]# vim  /etc/my.cnf
     		[mysqld]
     		secure_file_priv="/myload“
	:wq
	]# systemctl  restart mysqld

	mysql> show  variables  like  “secure_file_priv”;  查看



	1.1 数据导入：
		作用？把系统文件的内容存储到数据的表里
		命令格式？
		mysql>
		load  data  infile   "目录名/文件名"
into   table  库名.表名
fields terminated   by   "分隔符"
lines  terminated  by   "\n";


		注意事项？
			字段分隔符要与文件一致
			表字段类型和字段个数要与文件匹配
			导入数据时指定文件的绝对路径

		操作步骤？
			create database db3;
			create table db3.user(
				name char(50),
				password  char(1),
				uid int,
				gid int,
				comment  char(150),
				homedir char(50),
				shell	char(50)
			);

			desc db3.user;

			select  * from db3.user;

			]# cp /etc/passwd  /myload/

mysql> load data infile "/myload/passwd" into table db3.user
       fields terminated by ":" lines terminated by "\n" ;
mysql> select  * from  db3.user;
mysql> alter table  db3.user
    -> add
    -> id  int primary key auto_increment first;
mysql> select  * from  db3.user;
mysql> select  * from  db3.user where id=1;        （10:30 上课）


	1.2 数据导出 :
		作用：把表记录存储到系统文件里

		命令格式：
			格式1：
			mysql>  select命令   into   outfile   “目录名/文件";

			格式2：
			mysql>  select命令   into   outfile   “目录名/文件"
				fields   terminated   by   “分隔符”;


			格式3：
			mysql>  select命令   into   outfile   “目录名/文件"
				fields   terminated   by   “分隔符”
				lines	  terminated   by   “分隔符” ;


		注意事项：
			导出数据行数由SQL查询决定。
			导出的是表记录，不包括字段名。
			自动创建存储数据的文件。
			存储数据文件，具有唯一性。


		例子：

		mysql> select  * from  db3.user  into outfile "/myload/user1.txt";

		mysql> select  * from  db3.user  where id<=3   into outfile "/myload/user2.txt" fields   terminated   by "###";


		mysql> select  name,uid,shell from  db3.user  where id<=3   into outfile "/myload/user3.txt" fields   terminated   by "#"  lines terminated   by "???";

		]# ls /myload
		]# vim /myload/user1.txt
		]# vim /myload/user2.txt
		]# vim /myload/user3.txt
						练习到 10：57



二、管理表记录 （db3.user）

		2.1 添加记录
			格式1 添加1条记录，给所有字段赋值
				  insert   into   库.表名  values (字段值列表)；
mysql> insert into  user
	values (22,"bob","x",3000,3000,"test user","/home/bob","/bin/bash");

			格式2：添加N条记录，给所有字段赋值
				insert   into   库.表名  values (字段值列表), (字段值列表);

mysql> insert into  user
values
(23,"lucy","x",3001,3000,"test user","/home/bob","/bin/bash"),
(24,"tom","x",3002,3000,"test user","/home/bob","/bin/bash"),
(25,"jack","x",3003,3000,"test user","/home/bob","/bin/bash");

			格式3：添加1条记录，给指定字段赋值
				insert   into  表名 (字段名列表) values (字段值列表);

mysql> insert into user(name,uid)values("jerry","4000");

			格式4：添加N条记录，给指定字段赋值
				insert   into  表名 (字段名列表)
					values (字段值列表),(字段值列表);

mysql> insert into user(name,uid)values("mack","4001"),("lili",4002),("dachui",4003);

			注意事项：
				字段值要与字段类型相匹配。
				字符类型的字段，要用 ””号括起来。
				依次给所有字段赋值时，字段名可以省略。
				只给部分字段赋值时，必须明确写出对应的字段名称。
				没有赋值的字段使用默认值或自增长赋值。



		2.2 查看记录
			格式1：查看所有记录
			      select   字段1,字段N  from  库名.表名;

			格式2  条件查询
			      select  字段1,字段N  from  库名.表名 where 条件表达式;

			注意事项：
				*表示所有字段
				查看当前库表记录时库名可以省略
				字段列表决定显示列个数
				条件决定显示行的个数

mysql> select  id , name , shell from user;
mysql> select  * from user;

mysql> select  id , name , shell from user where name="adm";

mysql> select * from user where id<=5;

		2.3 修改记录
			格式1，批量更新
				update  库名.表名 set  字段名=值 , 字段名=值 , 字段名=值;

			格式2，条件匹配更新
				update  库名.表名 set  字段名=值 , 字段名=值 , 字段名=值
					where 匹配条件;

			注意事项:
			字段值要与字段类型相匹配
			对于字符类型的字段，值要用双引号括起来
			若不使用where限定条件，会更新所有记录字段值
			限定条件时，只更新匹配条件的记录的字段值

mysql> update user set  password="A" , comment="student user" ;
mysql> update user set password="x" where name="root";

		2.4 删除记录
			格式1，条件匹配删除
					delete    from   库名.表名  where  条件表达式;

			格式2，删除所有记录
					delete    from   库名.表名;

			注意事项:
				不加条件删除表中的所有行

mysql> delete from user where id>21;
mysql> delete from user ;

三、匹配条件
	3.1 基本匹配条件(适用于select \ update \delete)
		3.1.1 数值比较 >  >=  <  <=  =  !=
				mysql> select  * from user where uid=3;
				mysql> select  * from user where id<=5;
				mysql> select name,uid,gid from user
						where uid=gid ;

				mysql> select name,uid,gid from user
						where uid!=gid ;

		3.1.2 字符比较  =    !=
				mysql> select name,shell from user
						where shell != "/bin/bash";
				mysql> select name,shell from user
						where name = "adm";
		3.1.3 范围内比较
			in  (值列表) 	在…里…
			not  in  (值列表)	不在…里…
			between 数字 and  数字	在…之间…

			mysql> select name from user
			where  name in ("mysql","apache","adm","sync");

			mysql> select name,uid from user
					where  uid in (3,5,7,9);

			mysql> select name,shell from user
			where  shell not in ("/bin/bash","/sbin/nologin");

			mysql> select name,uid from  user
				where  uid between 50 and 100;

		3.1.4 逻辑比较(多个判断条件)
			逻辑与  and  或 && (多个判断条件必须同时成立)
			逻辑或  or   或 || (多个判断条件，某个成立即可)
			逻辑非  取反 ！ 或 not
mysql> select  * from user
       where  name="root" and  uid=1  and shell="abc" ;

mysql> select  * from user  where name="root" or  uid=1  or shell="abc";

mysql> select  * from user
     where name="root" &&  uid=0  &&  shell="/bin/bash";

		3.1.5 空/非空
		     is null  / is not null

mysql> insert into user(name) values(null);
mysql> select id from  user where name is null ;
mysql> select id from  user where name is not null ;
							练习到14：40

		3.1.6 去掉重复数据 distinct

		mysql> select  shell from user where uid>=100;
		mysql> select distinct shell from user where uid>=100;
		mysql> select distinct shell from user ;

	休息到15：15

	3.2 高级匹配条件(适用于select \ update \delete)
		3.2.1 模糊匹配
		where 字段名  like   '通配符'
			_      表示1个字符
			%     表示0~n个字符

mysql> select name from user where  name like '____';
mysql> select name from user where  name like '__%__';
mysql> select name from user where  name like '%a%';
mysql> select name from user where  name like 'a%';

		3.2.2 正则匹配
			where 字段名  regexp   '正则表达式'
			正则符号 ^ $ . * [] |

mysql> select name from user where name regexp  '^r|y$';

mysql> select name from user where name regexp  '^r.*y$';

mysql> select name,uid from user where uid regexp  '^....$';

mysql> insert into user(name)values("yaya9"),("7yaya"),("ya8ya");
mysql> select name,uid from user where name regexp  '[0-9]';

		3.2.3 四则计算  + - * / %
mysql> select name , uid , gid ,  uid+gid  zh from user where  name="bin";
mysql> select name , uid , gid ,  uid+gid  zh from user ;

mysql> update user set gid=gid+1 ;

mysql> alter table user add  age tinyint unsigned default 19 after name;
mysql> select name,age, 2019-age  your_s from user where name="root";


		3.2.4 提高优先级 ()
			mysql> select name , uid , gid ,  (uid+gid)/2  pjz from user where name="adm";


	3.3 操作查询结果(适用于select)
		3.3.1 聚集函数(MySQL内置数据统计命令)
			avg(字段名)			//统计字段平均值
			sum(字段名) 			//统计字段之和
			min(字段名) 			//统计字段最小值
			max(字段名) 			//统计字段最大值
			count(字段名) 			//统计字段值个数

			mysql> select min(uid) from user;
			mysql> select max(uid) from user;
			mysql> select avg(uid) from user;
			mysql> select sum(uid) from user;

mysql> select count(name) from  user where shell != "/bin/bash";
mysql> select count(name) from  user;

mysql> select * from  user ;
mysql> select count(*) from  user ;

		3.3.2 查询结果排序
			SQL查询   order   by   字段名   [ asc | desc ];

mysql> select name,uid from user
        where uid >=10  and uid <= 500 ;

mysql> select name,uid from user
	where uid >=10  and uid <= 500 order by uid

mysql> select name,uid from user
	where uid >=10  and uid <= 500 order by uid desc ;

		3.3.2 查询结果分组
			SQL查询  group   by   字段名;

mysql> select shell from user  where uid <=500;
mysql> select shell from user  where uid <=500 group by  shell;

mysql> select gid  from user ;
mysql> select gid  from user  group by  gid;

		3.3.3 查询结果过滤
			SQL查询   having   条件表达式;

mysql> select name from  user where id<=20  ;
mysql> select name from  user where id<=20  having name="adm";

		3.3.4 限制查询结果显示行数
			SQL查询  limit  数字; 	//显示查询结果前多少条记录
		SQL查询  limit  数字1,数字2; //显示指定范围内的查询记录
		数字1  起始行 （0 表示第1行  ）
		数字2  总行数


mysql> select id,name,password from  user where id<=20;
mysql> select id,name,password from  user where id<=20 limit 10;
mysql> select id,name,password from  user where id<=20 limit  5;

mysql> select name,uid from user where id<=10;
mysql> select name,uid from user where id<=10 limit 0,2;
mysql> select name,uid from user where id<=10 limit 1,3;

		练习到 17：10
		休息到 17：25

四、MySQL管理工具
	在192.168.4.50 上安装图形软件phpMyAdmin
	# yum  -y  install  httpd  php  php-mysql
	# systemctl start httpd
	# systemctl  enabled  httpd

	# tar  -zxvf  phpMyAdmin-2.11.11-all-languages.tar.gz
	# mv  phpMyAdmin-2.11.11-all-languages  /var/www/html/phpmyadmin

	# cd /var/www/html/phpmyadmin/
	# cp  config.sample.inc.php   config.inc.php  //创建主配置文件

	# vim  config.inc.php
	17   $cfg[‘blowfish_secret’] = ‘plj123’;  //cookies参数
	31   $cfg[‘Servers’][$i][‘host’] = ‘localhost’; //数据库服务器IP地址

	访问软件管理数据库服务
	http://192.168.4.50/phpmyadmin
	用户名 root
	密  码
++++++++++RDBMS1_DAY04++++++++++++++
一、用户授权
	1.1 用户授权： 在数据库服务器上添加新的连接用户，默认只允许数据库管理员本机登陆

	1.2 命令：
	    mysql> grant  权限列表  on   库名  to  用户名@”客户端地址” identified  by  “密码” with  grant  options ;

		休息到11：16
	例子：
mysql> grant   all    on     *.*     to     mydba@"%"  identified by "123qqq...A"
    -> with grant option;


mysql> grant select on  db3.user to admin@"192.168.4.%" identified by "123qqq...A";


mysql> grant select , update , insert ,delete on db3.* to admin2@"localhost"
    -> identified by "123qqq...A";


	1.3 在客户端使用授权连接数据库服务器
		]# mysql -h数据库服务器ip地址  -u授权用户名 -p密码
		]# mysql -h192.168.4.50  -uadmin  -p123qqq...A
		mysql> show grants;
+-------------------------------------------------------+
| Grants for admin@192.168.4.%                          |
+-------------------------------------------------------+
| GRANT USAGE ON *.* TO 'admin'@'192.168.4.%'           |
| GRANT SELECT ON `db3`.`user` TO 'admin'@'192.168.4.%' |
+-------------------------------------------------------+
2 rows in set (0.00 sec)
		mysql> delete from  db3.user;
ERROR 1142 (42000): DELETE command denied to user 'admin'@'192.168.4.51' for table 'user'
mysql>
mysql> update db3.user set password="A";
ERROR 1142 (42000): UPDATE command denied to user 'admin'@'192.168.4.51' for table 'user'
mysql>
mysql> select * from db3.user limit 1;
+----+------+------+----------+------+------+--------------+---------+-----------+
| id | name | age  | password | uid  | gid  | comment      | homedir | shell     |
+----+------+------+----------+------+------+--------------+---------+-----------+
|  1 | root |   19 | x        |    0 |    0 | student user | /root   | /bin/bash |
+----+------+------+----------+------+------+--------------+---------+-----------+
1 row in set (0.00 sec)


	1.4 相关命令
		select user(); //显示登录用户名及客户端地址
		show grants;   //用户显示自身访问权限
		show  grants   for  用户名@“客户端地址”;  //管理员查看已有授权用户权限
		set  password=password(“密码”); //授权用户连接后修改连接密码
		set   password   for 用户名@“客户端地址”= password(“密码”)； //管理员重置授权用户连接密码
		drop user 用户名@“客户端地址”; //删除授权用户


	1.5 授权库: mysql库 记录授权信息，主要表如下：
			user表    	//记录已有的授权用户及权限
			db表       	//记录已有授权用户对数据库的访问权限
			tables_priv表   //记录已有授权用户对表的访问权限
			columns_priv表  //记录已有授权用户对字段的访问权限


			mysql> desc mysql.user;
			mysql> select host,user from mysql.user;
			mysql> show  grants for mydba@"%";


			mysql> desc mysql.db;
			mysql> select host,user,db from mysql.db;
			mysql> select  * from mysql.db
				 where db="db3" and user="admin2" and host="localhost"\G;
			mysql> show grants for  admin2@"localhost";
			mysql> update mysql.db set Drop_priv="Y"
				where db="db3" and user="admin2" and host="localhost";
			mysql> flush privileges; //重新加载表记录
			mysql> show grants for  admin2@"localhost";


			mysql> desc mysql.tables_priv;
			mysql> select host,user,db,Table_name from mysql.tables_priv;

			mysql> select * from mysql.tables_priv
					where Table_name="user" and db="db3"\G;

			mysql> show grants for admin@"192.168.4.%";


			mysql> desc mysql.columns_priv;
			mysql> select  * from  mysql.columns_priv;
			mysql> grant select ,update(name,password) on  db3.user
					to admin3@"localhost" identified by "123qqq...A" ;

			mysql> select  * from  mysql.columns_priv;

			]# mysql -uadmin3  -p123qqq...A
			mysql> show  grants;
			mysql> update  db3.user set age=18;
			mysql> update  db3.user set password="F";
			mysql> select  password from db3.user;


	1.6 撤销权限：删除授权用户的权限
		1.6.1 命令：
			mysql> revoke  权限列表  on  库名.表   from  用户名@"客户端地址";

		例子：
			mysql> select host,user from mysql.user;
			mysql> show grants for mydba@"%";

			mysql> revoke grant option on *.* from mydba@"%";
			mysql> show grants for mydba@"%";

			mysql> revoke delete,update on  *.* from mydba@"%";
			mysql> show grants for mydba@"%";


			mysql> revoke all on  *.* from mydba@"%";
			mysql> show grants for mydba@"%";

			mysql> drop user  mydba@"%";

	1.7 root密码
		1.7.1 恢复数据库管理员本机登陆密码
			1. 停止MySQL服务程序
			   ]# systemctl  stop  mysqld
			2. 跳过授权表启动MySQL服务程序
			   ]# vim /etc/my.cnf
				[mysqld]
				skip-grant-tables
				#validate_password_length=6
				#validate_password_policy=0
			   ：wq
			   ]# systemctl  start  mysqld
			3. 修改root密码
			   ]# mysql
			   mysql> update mysql.user
		set  authentication_string=password("123qqq...A")
		where user="root" and host="localhost";
			  mysql> flush privileges;
			  mysql> exit
			4. 正常方式重启MySQL服务程序
			  ]# vim /etc/my.cnf
                                [mysqld]
                                #skip-grant-tables
                        	validate_password_length=6
				validate_password_policy=0
                           ：wq
                           ]# systemctl  restart  mysqld
			5、使用修改后的密码登陆
			   ]# mysql -uroot -p123qqq...A
        mysqladmin的格式  详细
        可以参考  https://www.cnblogs.com/dadonggg/p/8625500.html
		1.7.2  重置root密码
			 ]# mysqladmin  -uroot -p  password "123456"
			 Enter password:123qqq...A

			 ]# mysql -uroot -p123456
			 mysql>
			练习到  15：45   休息到 16：00
二 数据完全备份
	2.1 数据备份相关概念 ？
			数据备份方式
			数据备份策略
	物理备份 50
		 ]# cp -r /var/lib/mysql /root/mysql.bak
		 ]# scp -r /root/mysql.bak root@192.168.4.51:/tmp/

	物理恢复 51
	]# systemctl  stop mysqld
  	]# ls /var/lib/mysql
  	]# rm -rf /var/lib/mysql
  	]# cp -r /tmp/mysql.bak /var/lib/mysql
  	]# ls /var/lib/mysql
  	]# ls -ld /var/lib/mysql
  	]# chown  -R mysql:mysql /var/lib/mysql
  	]# ls -ld /var/lib/mysql
  	]# ls -l /var/lib/mysql
  	]# systemctl  start mysqld
  	]# mysql -uroot -p123456
	mysql> show databases;
	mysql> select  * from db3.user;
	mysql> use db1;
	mysql> show tables;
				练习到16：30

	完全备份
		命令
		]#mysqldump   -uroot    -p密码    库名  >  目录/xxx.sql

		192.68.4.50:
		]# mysqldump -uroot -p123456 -A > allbak.sql
  		]# ls *.sql
  		]# mysqldump -uroot -p123456 db3 > db3.sql
 		]# ls *.sql
  		]# vim db3.sql
  		]# scp db3.sql  root@192.168.4.51:/tmp/
  		]# scp db3.sql  root@192.168.4.52:/tmp/

	完全恢复
		命令
		]#mysql  -uroot    -p密码    库名    <   目录/xxx.sql

		192.168.4.52:
		mysql>create database db3;

		]#mysql  -uroot    -p密码 db3 < /tmp/db3.sql
		mysql> select  * from db3.user;

							休息到 17：15
三、增量备份
		3.1 binlog日志的使用
			3.1.1 binlog日志介绍（binlog日志是什么）


			3.1.2 启用binlog日志

				]# vim /etc/my.cnf
			   	[mysqld]
			   	log-bin
			   	server_id=50
				:wq

				]# systemctl restart mysqld


				]# ls /var/lib/mysql/*-bin.*
			3.1.3  手动生成新的日志文件：
				 1. systemctl  restart  mysqld

     				 2. mysql> flush logs;
         				或
        			     ]# mysql -uroot  -p密码  -e ‘flush log’

      				 3. mysqldump -uroot -p123456  --flush-logs db3  > /db3.sql

			3.1.4 清理日志
				删除指定编号之前的binlog日志文件
				mysql>  purge  master  logs  to "host50-bin.000004";

				删除所有binlog日志，重建新日志
				mysql> reset master;

			3.1.5 启用日志时，自定义日志文件存储目录和文件名
			      ]# vim /etc/my.cnf
				[mysqld]
					#log-bin
					log-bin=/mylog/db50
					server_id=50
				:wq
				]# mkdir /mylog
				]# chown  mysql /mylog
				]# systemctl restart mysqld
				]# ls /mylog/db50.*

	192.168.4.50:
		]# mysqldump  -uroot -p123456 db3 user > /root/db3_user.sql

		mysql> show master status;
		mysql> insert into db3.user(name)values("xixi");
		mysql> insert into db3.user(name)values("xixi");
		mysql> insert into db3.user(name)values("xixi");
		mysql> insert into db3.user(name)values("xixi");
		mysql> insert into db3.user(name)values("xixi");
		mysql> show master status;

		]# scp /mylog/db50.000001 root@192.168.4.51:/tmp/

		3.2 恢复数据 (使用binlog日志恢复数据)
			3.2.1 日志格式 （日志如何区分记录的多条SQL命令）
				查看日志当前记录格式
				 mysql> show variables like "%binlog%";
				 mysql>show variables like "binlog_format";

				 修改日志格式  10:32
				  ]# vim /etc/my.cnf
					[mysqld]
					binlog_format="mixed"
				   :wq
				   ]# systemctl  restart mysqld
				   ]# mysql -uroot -p123456
mysql> show variables like "binlog_format";
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| binlog_format | MIXED |
+---------------+-------+
1 row in set (0.01 sec)

mysql> show master status;
+-------------+----------+--------------+------------------+-------------------+
| File        | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+-------------+----------+--------------+------------------+-------------------+
| db50.000002 |      154 |              |                  |                   |
+-------------+----------+--------------+------------------+-------------------+
1 row in set (0.00 sec)

mysql>

			日志如何区分记录的多条SQL命令
			偏移量
			时间点

			命令]# mysqlbinlog 【选项】 日志文件 | mysql -uroot -p密码
			选项
			--start-datetime=“yyyy-mm-dd hh:mm:ss”	起始时间
			--stop-datetime="yyyy-mm-dd hh:mm:ss"	结束时间
			--start-position=数字	起始偏移量
			--stop-position=数字 	结束偏移量
	192.168.4.50:
		]# mysqlbinlog --start-position=1404 --stop-position=2094 /mylog/db50.000002 | mysql -uroot -p123456

	192.168.4.51:
		]# mysqlbinlog /tmp/db50.000001
		]# mysqlbinlog /tmp/db50.000001 | mysql -uroot  -p123456
		mysql> select  count(*) from db3.user;
		mysql> select  name from db3.user;

		]# mysqlbinlog  --start-position=1087 --stop-position=2094 /tmp/db50.000002 | mysql -uroot -p123456


	练习到 11：33
++++++++++RDBMS1_DAY05++++++++++++++
192.168.4.50  192.168.4.51
一、percona软件介绍
		1.1 软件介绍

		1.2 安装软件
		]# rpm -ivh libev-4.15-1.el6.rf.x86_64.rpm
                ]# yum -y  install percona-xtrabackup-24-2.4.7-1.el7.x86_64.rpm

		[root@host50 ~]# rpm -qa  | grep -i percona
percona-xtrabackup-24-2.4.7-1.el7.x86_64
[root@host50 ~]#
[root@host50 ~]#
[root@host50 ~]# rpm -ql percona-xtrabackup-24
/usr/bin/innobackupex
/usr/bin/xbcloud
/usr/bin/xbcloud_osenv
/usr/bin/xbcrypt
/usr/bin/xbstream
/usr/bin/xtrabackup
/usr/share/doc/percona-xtrabackup-24-2.4.7
/usr/share/doc/percona-xtrabackup-24-2.4.7/COPYING
/usr/share/man/man1/innobackupex.1.gz
/usr/share/man/man1/xbcrypt.1.gz
/usr/share/man/man1/xbstream.1.gz
/usr/share/man/man1/xtrabackup.1.gz
[root@host50 ~]#
[root@host50 ~]# innobackupex --help  ^C
[root@host50 ~]#
[root@host50 ~]# man  innobackupex



二、innobackupex备份与恢复
		2.1 完全备份 192.168.4.50
			]# innobackupex --user root --password 123456 /allbak --no-timestamp

			]# ls /allbak/
			]# scp -r /allbak root@192.168.4.51:/root/
		    完全恢复 192.168.4.51
			]# ls /root/allbak
			]# rpm -ivh  libev-4.15-1.el6.rf.x86_64.rpm
  			]# yum -y  install percona-xtrabackup-24-2.4.7-1.el7.x86_64.rpm
]# systemctl  stop mysqld
]# ls /var/lib/mysql
]# rm -rf /var/lib/mysql/*
]# ls /var/lib/mysql

]# cat /root/allbak/xtrabackup_checkpoints
]# innobackupex --apply-log /root/allbak
]# cat /root/allbak/xtrabackup_checkpoints

]# innobackupex --copy-back /root/allbak
]# ls /var/lib/mysql
]# ls /var/lib/mysql -l
]# chown  -R mysql:mysql /var/lib/mysql

]# systemctl  start mysqld
]# mysql -uroot -p123456
mysql> show databases;
mysql> select * from db3.user2;
mysql> select count(*) from db3.user;

		2.2 恢复单张表 192.168.4.50    (练习到 17：00)
		mysql> delete from db3.user2; 误删除数据操作
具体操作如下：
删除表空间 mysql> alter table db3.user2 discard  tablespace;

导出表信息     ]# innobackupex --apply-log --export  /allbak

拷贝表信息文件到数据库目录下
	       ]# cp /allbak/db3/user2.{cfg,exp,ibderver_id=55
 /var/lib/mysql/db3/
修改表信息文件的所有者及组用户为mysql
	       ]# chown mysql:mysql /var/lib/mysql/db3/user2.*

导入表空间 mysql> alter  table db3.user2   import  tablespace;

删除数据库目录下的表信息文件
	     ]# rm -rf /var/lib/mysql/db3/user2.cfg
             ]# rm -rf /var/lib/mysql/db3/user2.exp

查看表记录 mysql> select  * from db3.user2;

	     2.3 增量备份与恢复
		 增量备份 192.168.4.50
		]# innobackupex --user root --password 123456  /fullbak --no-timestamp
		]# ls /fullbak
		]# cat /fullbak/xtrabackup_checkpoints

		mysql> insert into db3.user2 values(5,"jack"); 插入新记录,多写几条
		]# innobackupex --user root --password 123456 --incremental /new1dir --incremental-basedir=/fullbak  --no-timestamp
		]# ls /new1dir
		]# cat /new1dir/xtrabackup_checkpoints


		mysql> insert into db3.user2 values(6,"jack88"); 插入新记录,多>写几条
		]# innobackupex --user root --password 123456 --incremental /new2dir --incremental-basedir=/new1dir  --no-timestamp
		]# ls /new2dir
		]# cat /new2dir/xtrabackup_checkpoints
		练习到 09：35
		]# scp -r /fullbak  root@192.168.4.51:/root/
  		]# scp -r /new1dir/  root@192.168.4.51:/root/
  		]# scp -r /new2dir/  root@192.168.4.51:/root/
		增量恢复 192.168.4.51
			[root@host51 ~]# systemctl  stop  mysqld
			[root@host51 ~]# rm -rf /var/lib/mysql/*

]# innobackupex --apply-log --redo-only /root/fullbak
]# cat /root/fullbak/xtrabackup_checkpoints

]# innobackupex --apply-log --redo-only /root/fullbak --incremental-dir=/root/new1dir
]#cat /root/fullbak/xtrabackup_checkpoints
]# rm -rf  /root/new1dir

]# innobackupex --apply-log --redo-only /root/fullbak --incremental-dir=/root/new2dir
]# cat /root/fullbak/xtrabackup_checkpoints
]# rm -rf  /root/new2dir

]# innobackupex --copy-back /root/fullbak
]# ls /var/lib/mysql -l
]# chown  -R mysql:mysql /var/lib/mysql

]# systemctl  start mysqld
]# mysql -uroot -p123456
mysql> select  count(*)  from db3.user;

对数据做备份 的命令 cp/tar(直接对数据库根目录操作)  mysqldump binlog   innobackupex

备份方式？ 备份时间   备份策略？周一   完全备份      数据存储空间lv
		      00 06 * * 1    /root/allbak.sh
		      00 07 * * 2-7  /root/newbak.sh

			休息到 10：05
++++++++++RDBMS2_DAY01++++++++++++++
	192.168.4.50
	192.168.4.51
	192.168.4.52
	192.168.4.53
	192.168.4.54
	192.168.4.55

一、 MySQL 主从同步

	配置主服务器192.168.4.51
		]# vim /etc/my.cnf
		 [mysqld]
		 log-bin=db51
		 server_id=51
		:wq
		]# systemctl restart mysqld
		]#ls /var/lib/mysql/db51.*

		]# mysql -uroot -p123456
		mysql> grant replication  slave on *.*
			   to  repluser@"%" identified by "123qqq...A";


		mysql> show  master status;


       配置从服务器192.168.4.52
		]# vim /etc/my.cnf
			[mysqld]
			server_id=52
		   :wq
		]# systemctl restart mysqld
	与主服务器数据一致
	51
        ]# mysqldump -uroot -p123456 --master-data  db3  > /db3.sql
	]# scp  /db3.sql  root@192.168.4.52:/root/
	52
	mysql> create database db3;
	]# mysql -uroot -p密码 < /root/db3.sql
	]# vim  /root/db3.sql   查看备份数据对应的日志名及偏移量编号
	]# mysql -uroot -p123qqq...A
	mysql> change master to master_host="192.168.4.51",
		master_user="repluser",master_password="123qqq...A",
		master_log_file="db51.000001",master_log_pos=701;
	mysql> start slave;
	mysql> show slave status\G;
		 Master_Host: 192.168.4.51
		 Slave_IO_Running: Yes
                 Slave_SQL_Running: Yes

	测试配置：
		方法1
			51的数据库管理员在本机创建新数据库和表 插入记录
				mysql> create table db3.user4(name char(10));
				mysql> create database db4 ;
				mysql> create table db4.a(id int);
				mysql> insert into db4.a values(99);
				mysql> insert into db4.a values(99);
				mysql> insert into db4.a values(99);
				mysql> insert into db3.user2 values(99,"jerry");
			52的数据库管理员在本机查看时可以看到同样的库和表及记录
				mysql> select  * from db3.user2;
				mysql> select  * from db4.a;

		方法2
			51的数据库管理员在本机,做用户授权
			   mysql> grant select,insert on  *.*  to
					yaya99@"%"  identified by "123qqq...A";

			50连接主服务器51存和查数据
			  ]# mysql -h192.168.4.51 -uyaya99 -p123qqq...A
			  mysql> insert into db3.user4 values("bob"),("tom"),("lucy");

			51/52 的数据库管理员在本机能够查看到新插入的数据
			  mysql> select  * from  db3.user4;


		练习到 15：40

把从数据库恢复为独立的数据库服务器
		]# rm -rf master.info  relay-log.info  host52-relay-bin.* ^C
		]# systemctl restart mysqld


查看报错信息 mysql> show slave status\G;
Last_IO_Error: Got fatal error 1236 from master when reading data from binary log: 'Misconfigured master - master server_id is 0'


Last_SQL_Error: Error 'Can't create database 'db3'; database exists' on query. Default database: 'db3'. Query: 'create database db3'


Last_IO_Error: error connecting to master 'repluser@192.168.4.51:3306' - retry-time: 60  retries: 136

Last_Error: Error 'Operation ALTER USER failed for 'repluser'@'%'' on query. Default database: ''. Query: 'ALTER USER 'repluser'@'%' IDENTIFIED WITH 'mysql_native_password' AS '*C608BE758B104C08A668562152C943506CFD9BE6''


Last_IO_Error: Fatal error: The slave I/O thread stops because master and slave have equal MySQL server UUIDs; these UUIDs must be different for replication to work.


 Last_IO_Error: Got fatal error 1236 from master when reading data from binary log: 'Client requested master to start replication from position > file size'


stop slave;
start slave;
show slave status\G;
			练习到 15:00

二、主从同步模式
		2.1 结构类型？

		2.2 配置一主多从同步结构
		    要求：把数据库服务器192.168.4.53 也配置为51的从服务器

	            数据库服务器192.168.4.53的配置如下：
			1 验证主服务器51的授权用户
				]# mysql -h192.168.4.51 -urepluser -p123qqq...A
				mysql> exit;
			2 指定server_id
				]# vim /etc/my.cnf
				 [mysqld]
				 server_id=53
			        :wq
				]# systemctl  restart mysqld

			3 确保与主服务器数据一致
				51]# ]# mysqldump -uroot -p123456 --master-data -B db3  db4 > /root/dbtwo.sql
				51]# scp  /root/dbtwo.sql  root@192.168.4.53:/root/

				53]# mysql -uroot -p123qqq...A  < /root/dbtwo.sql
				53]# grep  -i db51  /root/dbtwo.sql
练习到16：31
			4 指定主服务器信息
				mysql> change master to master_host="192.168.4.51",
					master_user="repluser",
    					master_password="123qqq...A",
					master_log_file="db51.000001",
    					master_log_pos=3855;

			5 启动slave程序  mysql> start slave;

			6 查看状态信息   mysql> show slave status\G;
					 Master_Host: 192.168.4.51
					 Slave_IO_Running: Yes
            				 Slave_SQL_Running: Yes

			7 在客户端50 测试配置
				50 访问主服务器51
				    host50 ~]# mysql -h192.168.4.51 -uyaya99 -p123qqq...A
mysql> mysql> insert into db3.user4 values("jerry");
mysql> insert into db3.user4 values("alice");
mysql> insert into db3.user4 values("jack");
mysql> select  * from db3.user4;
				53 数据库管理员登陆可以查看到新插入的数据
mysql> select  * from db3.user4;
+-------+
| name  |
+-------+
| bob   |
| tom   |
| jerry |
| alice |
| jack  |
+-------+
	 	2.3 配置主从从结构
	 	           配置主机192.168.4.53为主服务器
                   配置主机192.168.4.54为53主机的从服务器
                   配置主机192.168.4.55为54主机的从服务器
		    2.3.1 配置主服务器53
			]# vim /etc/my.cnf
			   [mysqld]
				server_id=53
				log-bin=db53
			   :wq

			]# systemctl  restart mysqld

			]# mysql -uroot -p密码
			mysql> grant replication slave on  *.*
				to repluser@"%" identified by "123qqq...A";

			mysql> show  master status;
+-------------+----------+--------------+------------------+-------------------+
| File        | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+-------------+----------+--------------+------------------+-------------------+
| db53.000001 |      441 |              |                  |                   |
+-------------+----------+--------------+------------------+-------------------+

		    2.3.2 配置从服务器54

			]# vim /etc/my.cnf
				[mysqld]
				server_id=54
				log-bin=db54
				log_slave_updates
			:wq
			]# systemctl  restart mysqld

			]# mysql -uroot -p密码
mysql> grant replication slave on  *.*  to  repluser2@"%" identified by "123qqq...A";
Query OK, 0 rows affected, 1 warning (0.02 sec)

mysql> show master status;
+-------------+----------+--------------+------------------+-------------------+
| File        | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+-------------+----------+--------------+------------------+-------------------+
| db54.000001 |      442 |              |                  |                   |
+-------------+----------+--------------+------------------+-------------------+
1 row in set (0.00 sec)

mysql> change master to  master_host="192.168.4.53",master_user="repluser",
    -> master_password="123qqq...A",master_log_file="db53.000001",master_log_pos=441;
Query OK, 0 rows affected, 2 warnings (0.22 sec)

mysql> start slave;
Query OK, 0 rows affected (0.03 sec)

mysql> show slave status\G;
		 Slave_IO_Running: Yes
            	Slave_SQL_Running: Yes
		Master_Host: 192.168.4.53

			2.3.3 配置从服务器55
			]# vim /etc/my.cnf
				[mysqld]
 				server_id=55
			:wq

			]# systemctl  restart mysqld
			]# mysql  -uroot -p密码
mysql> change master to  master_host="192.168.4.54",master_user="repluser2",
master_password="123qqq...A",master_log_file="db54.000001",master_log_pos=442;

mysql> start slave ;
mysql> show slave status\G;
	    Master_Host: 192.168.4.54
	    Slave_IO_Running: Yes
            Slave_SQL_Running: Yes

			2.3.4 测试配置
				在主服务器本机创建新库新表插入记录
				在2台从服务器本机可以查看到同样的库表及记录

			53 mysql>
			   create database bbsdb;
			   create table bbsdb.a(id int);
			   insert into bbsdb.a values(99);

			54/55 mysql>
			   select  * from bbsdb.a;

		mysql主从同步结构模式
			一主一从   一主多从  主从从  主主结构

	2.4 复制模式(mysql主从同步复制模式)
		2.4.1 模式分类
		异步复制模式（默认）
		全同步复制模式
		半同步复制模式

		2.4.2 配置半同步复制模式 (在数据服务器54上做配置)
		主53   从主 54    从55
			2.4.2.1 命令行配置（立即生效）
				1  查看数据库服务是否允许动态加载模块（默认允许）
mysql> show  variables  like  'have_dynamic_loading';
+----------------------+-------+
| Variable_name        | Value |
+----------------------+-------+
| have_dynamic_loading | YES   |
+----------------------+-------+
1 row in set (0.03 sec)

				2  安装模块，并查看结果
mysql>  select  plugin_name, plugin_status from  information_schema.plugins  where plugin_name like '%semi%';
Empty set (0.00 sec)

mysql>  install  plugin  rpl_semi_sync_master SONAME "semisync_master.so" ;
Query OK, 0 rows affected (0.07 sec)

mysql> select  plugin_name, plugin_status from  information_schema.plugins  where plugin_name like '%semi%';
+----------------------+---------------+
| plugin_name          | plugin_status |
+----------------------+---------------+
| rpl_semi_sync_master | ACTIVE        |
+----------------------+---------------+
1 row in set (0.00 sec)

mysql>  install  plugin rpl_semi_sync_slave SONAME "semisync_slave.so";
Query OK, 0 rows affected (0.09 sec)

mysql> select  plugin_name, plugin_status from  information_schema.plugins  where plugin_name like '%semi%';
+----------------------+---------------+
| plugin_name          | plugin_status |
+----------------------+---------------+
| rpl_semi_sync_master | ACTIVE        |
| rpl_semi_sync_slave  | ACTIVE        |
+----------------------+---------------+
2 rows in set (0.00 sec)

				3  激活模块，并查看结果

mysql> show  variables  like  "rpl_semi_sync_%_enabled" ;
+------------------------------+-------+
| Variable_name                | Value |
+------------------------------+-------+
| rpl_semi_sync_master_enabled | OFF   |
| rpl_semi_sync_slave_enabled  | OFF   |
+------------------------------+-------+
2 rows in set (0.00 sec)

mysql> set  global rpl_semi_sync_master_enabled=1;
Query OK, 0 rows affected (0.00 sec)

mysql> show  variables  like  "rpl_semi_sync_%_enabled" ;
+------------------------------+-------+
| Variable_name                | Value |
+------------------------------+-------+
| rpl_semi_sync_master_enabled | ON    |
| rpl_semi_sync_slave_enabled  | OFF   |
+------------------------------+-------+
2 rows in set (0.00 sec)

mysql> set  global rpl_semi_sync_slave_enabled=1;
Query OK, 0 rows affected (0.00 sec)

mysql> show  variables  like  "rpl_semi_sync_%_enabled" ;
+------------------------------+-------+
| Variable_name                | Value |
+------------------------------+-------+
| rpl_semi_sync_master_enabled | ON    |
| rpl_semi_sync_slave_enabled  | ON    |
+------------------------------+-------+
2 rows in set (0.01 sec)

mysql>
			2.4.2.2 写进配置文件使其永久有效果
]# vim /etc/my.cnf
[mysqld]
plugin-load="rpl_semi_sync_master=semisync_master.so;rpl_semi_sync_slave=semisync_slave.so"
rpl_semi_sync_master_enabled=1
rpl_semi_sync_slave_enabled=1
:wq

]# mystemctl  restart mysqld

]# mysql -uroot -p123qqq...A
mysql> select  plugin_name, plugin_status from  information_schema.plugins  where plugin_name like '%semi%';
+----------------------+---------------+
| plugin_name          | plugin_status |
+----------------------+---------------+
| rpl_semi_sync_master | ACTIVE        |
| rpl_semi_sync_slave  | ACTIVE        |
+----------------------+---------------+
2 rows in set (0.00 sec)

mysql>  show  variables  like  "rpl_semi_sync_%_enabled";
+------------------------------+-------+
| Variable_name                | Value |
+------------------------------+-------+
| rpl_semi_sync_master_enabled | ON    |
| rpl_semi_sync_slave_enabled  | ON    |
+------------------------------+-------+
2 rows in set (0.00 sec)

mysql>

+++++++++RDBMS2_DAY02++++++++++++++
一、数据读写分离
	1.1 数据读写分离介绍（什么是数据读写分离）
		把客户端访问时的查询请求和写请求分别给不同的数据库服务器处理

	1.2 数据对写分离的优点（为什么要配置数据读写分离）
		减轻主服务器的工作压力，提高从服务器的硬件利用率

	1.3 配置数据读写分离（实现数据读写分离的方式）
		程序实现      程序员写代码实现
		部署服务实现  在服务器部署数据读写分离服务

	1.4 拓扑结构

	1.5 环境准备 （到 11：00  休息10分钟 11：10 讲新课）

		50 做客户端 能够ping 通 57 主机 即可
		克隆1台新的虚拟机 配置ip地址为 192.168.4.57 不需要安装mysql数据库服务
		配置mysql 一主一从 同步结构  51 主服务器  52 从服务器

		拷贝软件给57 主机
]#scp /linux-soft/03/mysql/maxscale-2.1.2-1.rhel.7.x86_64.rpm root@192.168.4.57:/root/

	1.6 配置代理服务 192.168.4.57
		1.6.1 装包（安装提供代理服务的软件包）
			]# rpm -ivh maxscale-2.1.2-1.rhel.7.x86_64.rpm
			]# rpm -ql maxscale

		1.6.2 修改代理服务的主配置文件
			]# cp /etc/maxscale.cnf  /root/
			]# vim /etc/maxscale.cnf
[maxscale]
threads=auto  线程个数

[server1]  定义第1台数据库服务器
type=server
address=192.168.4.51
port=3306
protocol=MySQLBackend

[server2] 定义第2台数据库服务器
type=server
address=192.168.4.52
port=3306
protocol=MySQLBackend

[MySQL Monitor]  定义监控的服务器及监控用户
type=monitor
module=mysqlmon
servers=server1, server2
user=maxscalemon
passwd=123qqq...A
monitor_interval=10000


[Read-Write Service] 定义读写分离服务及路由用户
type=service
router=readwritesplit
servers=server1, server2
user=maxscalerouter
passwd=123qqq...A
max_slave_connections=100%

[MaxAdmin Service] 定义管理服务
type=service
router=cli

[Read-Write Listener]  定义读写分离服务端口号
type=listener
service=Read-Write Service
protocol=MySQLClient
port=4006

[MaxAdmin Listener] 定义管理服务端口号
type=listener
service=MaxAdmin Service
protocol=maxscaled
socket=default
port=4016

		1.6.3 配置数据库服务器（根据主配置文件的设置做配置）
			创建监控用户maxscalemon   123qqq...A
			路由用户maxscalerouter  123qqq...A
配置到14：20
mysql> grant replication slave, replication client on *.*
to  maxscalemon@"%"identified by "123qqq...A";

mysql> grant select  on  mysql.*  to
maxscalerouter@"%" identified by "123qqq...A";

mysql> select user,host from  mysql.user where user like "maxscale%";
+----------------+------+
| user           | host |
+----------------+------+
| maxscalemon    | %    |
| maxscalerouter | %    |
+----------------+------+
2 rows in set (0.00 sec)

		1.6.4 启动代理服务
[root@host57 ~]# maxscale -f /etc/maxscale.cnf
[root@host57 ~]#


		1.6.5 查看服务状态

[root@host57 ~]# netstat  -utnlp  | grep  :4006
tcp6       0      0 :::4006                 :::*                    LISTEN      3769/maxscale
[root@host57 ~]#
[root@host57 ~]# netstat  -utnlp  | grep  :4016
tcp6       0      0 :::4016                 :::*                    LISTEN      3769/maxscale
[root@host57 ~]#
[root@host57 ~]#
[root@host57 ~]# netstat  -utnlp  | grep  maxscale
tcp6       0      0 :::4006                 :::*                    LISTEN      3769/maxscale
tcp6       0      0 :::4016                 :::*                    LISTEN      3769/maxscale
[root@host57 ~]#
[root@host57 ~]# ps -C maxscale
  PID TTY          TIME CMD
 3769 ?        00:00:00 maxscale
[root@host57 ~]#
[root@host57 ~]# ls /var/log/maxscale/
maxscale.log
[root@host57 ~]#

		在代理服务器本机 访问管理服务查看监控信息 练习到14：41
[root@host57 ~]# maxadmin  -uadmin -pmariadb -P4016
MaxScale> list servers
Servers.
-------------------+-----------------+-------+-------------+--------------------
Server             | Address         | Port  | Connections | Status
-------------------+-----------------+-------+-------------+--------------------
server1            | 192.168.4.51    |  3306 |           0 | Master, Running
server2            | 192.168.4.52    |  3306 |           0 | Slave, Running
-------------------+-----------------+-------+-------------+--------------------
MaxScale> exit
		排错 (查看日志文件获取报错信息)
		]# tail  -f  /var/log/maxscale/maxscale.log
		killall -9  maxscale
		rm -rf  /etc/maxscale.cnf
			休息+练习 到 15：30

		1.6.6 测试配置  练习到 15:58
			1 在主服务器上添加访问数据连接用户
				create  database gamedb;
				create table gamedb.a(id int);
				grant select ,insert on gamedb.* to yaya66@"%" identified by "123qqq...A";
			2 客户端连接代理服务57 访问数据
			]# mysql -h192.168.4.57 -P4006 -uyaya66 -p123qqq...A
			mysql> select  * from gamedb.a;
			mysql> insert into gamedb.a values(99);
			mysql> select  * from gamedb.a;
mysql> select  * from gamedb.a;
Empty set (0.00 sec)

mysql>
mysql> insert into gamedb.a values(99);
Query OK, 1 row affected (0.06 sec)
mysql>
mysql> select  * from gamedb.a;
+------+
| id   |
+------+
|   99 |
+------+
1 row in set (0.00 sec)
			3 验证57主机的数据读写分离功能   16:35
				3.1 在从服务器添加新纪录
					insert into gamedb.values(52);
					select  * from mysql> select  * from gamedb.a;
+------+
| id   |
+------+
|   99 |
|   52 |
+------+
				   在主服务器查看记录
                                        select  * from mysql> select  * from gamedb.a;
+------+
| id   |
+------+
|   99 |
+------+ 		       3.2  客户端访问代理服务器57 访问数据
				 ]# mysql -h192.168.4.57 -P4006 -uyaya66 -p123qqq...A
select  * from mysql> select  * from gamedb.a;
+------+
| id   |
+------+
|   99 |
|   52 |
+------+

二、多实例服务
	2.1 相关概念 ？
	2.2 配置mysql多实例
克隆1台新的虚拟机 配置ip地址为 192.168.4.56  不需要安装mysql数据库服务

	        ]# systemctl  stop mysqld
		]# mv /etc/my.cnf  /root/

		1 安装软件  休息到 17：10
]# tar -zxvf mysql-5.7.20-linux-glibc2.12-x86_64.tar.gz
]# ls
Desktop  mysql-5.7.20-linux-glibc2.12-x86_64  mysql-5.7.20-linux-glibc2.12-x86_64.tar.gz
[root@host56 ~]#
[root@host56 ~]# mv mysql-5.7.20-linux-glibc2.12-x86_64 /usr/local/mysql
[root@host56 ~]#
[root@host56 ~]# ls /usr/local/mysql
bin  COPYING  docs  include  lib  man  README  share  support-files
[root@host56 ~]#
[root@host56 ~]#
[root@host56 ~]# ls /usr/local/mysql/bin/
innochecksum                mysql_config_editor        mysqlshow
lz4_decompress              mysqld                     mysqlslap
myisamchk                   mysqld-debug               mysql_ssl_rsa_setup
myisam_ftdump               mysqld_multi               mysqltest_embedded
myisamlog                   mysqld_safe                mysql_tzinfo_to_sql
myisampack                  mysqldump                  mysql_upgrade
my_print_defaults           mysqldumpslow              mysqlxtest
mysql                       mysql_embedded             perror
mysqladmin                  mysqlimport                replace
mysqlbinlog                 mysql_install_db           resolveip
mysqlcheck                  mysql_plugin               resolve_stack_dump
mysql_client_test_embedded  mysqlpump                  zlib_decompress
mysql_config                mysql_secure_installation
[root@host56 ~]#


		2 编辑主配置文件
vim /etc/my.cnf
[mysqld_multi]
mysqld = /usr/local/mysql/bin/mysqld_safe
mysqladmin = /usr/local/mysql/bin/mysqladmin
user = root

[mysqld1]
datadir=/dir1
port=3307
log-error=/dir1/mysqld1.err
pid-file=/dir1/mysqld1.pid
socket=/dir1/mysqld1.socket

[mysqld2]
datadir=/dir2
port=3308
log-error=/dir2/mysqld2.err
pid-file=/dir2/mysqld2.pid
socket=/dir2/mysqld2.socket
:wq
		]# mkdir /dir1
		]# mkdir /dir2

		3 启动服务
]# PATH=/usr/local/mysql/bin:$PATH
]# echo  "export PATH=/usr/local/mysql/bin:$PATH" >> /etc/bashrc
]# yum -y  install libaio*
]# useradd mysql
[root@host56 ~]# mysqld_multi start 1


Installing new database in /dir1

2019-06-17T09:47:25.212724Z 0 [Warning] TIMESTAMP with implicit DEFAULT value is deprecated. Please use --explicit_defaults_for_timestamp server option (see documentation for more details).
2019-06-17T09:47:26.855106Z 0 [Warning] InnoDB: New log files created, LSN=45790
2019-06-17T09:47:27.202552Z 0 [Warning] InnoDB: Creating foreign key constraint system tables.
2019-06-17T09:47:27.373187Z 0 [Warning] No existing UUID has been found, so we assume that this is the first time that this server has been started. Generating a new UUID: ea8f92c9-90e4-11e9-866b-5254005c21a9.
2019-06-17T09:47:27.534300Z 0 [Warning] Gtid table is not ready to be used. Table 'mysql.gtid_executed' cannot be opened.
2019-06-17T09:47:27.534981Z 1 [Note] A temporary password is generated for root@localhost: icUjU=&wo73*
[root@host56 ~]#
[root@host56 ~]# ls /dir1
auto.cnf        ib_logfile0  mysql        mysqld1.socket       sys
ib_buffer_pool  ib_logfile1  mysqld1.err  mysqld1.socket.lock
ibdata1         ibtmp1       mysqld1.pid  performance_schema
[root@host56 ~]#
[root@host56 ~]# mysql -uroot -p'icUjU=&wo73*'
mysql: [Warning] Using a password on the command line interface can be insecure.
ERROR 2002 (HY000): Can't connect to local MySQL server through socket '/tmp/mysql.sock' (2)
[root@host56 ~]#
[root@host56 ~]#
[root@host56 ~]#
[root@host56 ~]#
[root@host56 ~]#
[root@host56 ~]#
[root@host56 ~]# mysql -uroot -p'icUjU=&wo73*' -S /dir1/mysqld1.socket
mysql: [Warning] Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 3
Server version: 5.7.20

Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql> alter user root@"localhost" identified by "123456";
Query OK, 0 rows affected (0.00 sec)

mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
4 rows in set (0.00 sec)

mysql> exit
Bye
[root@host56 ~]# mysql -uroot -p123456 -S /dir1/mysqld1.socket
mysql: [Warning] Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 4
Server version: 5.7.20 MySQL Community Server (GPL)

Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql>

mysql> create database db1;
Query OK, 1 row affected (0.00 sec)

mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| db1                |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
5 rows in set (0.00 sec)

mysql> exit
Bye
[root@host56 ~]# ls /dir1
auto.cnf        ibdata1      ibtmp1       mysqld1.pid          performance_schema
db1             ib_logfile0  mysql        mysqld1.socket       sys
ib_buffer_pool  ib_logfile1  mysqld1.err  mysqld1.socket.lock
[root@host56 ~]#

mysql> create database db1;
Query OK, 1 row affected (0.00 sec)

mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| db1                |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
5 rows in set (0.00 sec)

mysql> exit
Bye
[root@host56 ~]# ls /dir1
auto.cnf        ibdata1      ibtmp1       mysqld1.pid          performance_schema
db1             ib_logfile0  mysql        mysqld1.socket       sys
ib_buffer_pool  ib_logfile1  mysqld1.err  mysqld1.socket.lock
[root@host56 ~]#

[root@host56 ~]# mysqld_multi start 2


Installing new database in /dir2

2019-06-17T09:55:45.321627Z 0 [Warning] TIMESTAMP with implicit DEFAULT value is deprecated. Please use --explicit_defaults_for_timestamp server option (see documentation for more details).
2019-06-17T09:55:47.146785Z 0 [Warning] InnoDB: New log files created, LSN=45790
2019-06-17T09:55:47.477451Z 0 [Warning] InnoDB: Creating foreign key constraint system tables.
2019-06-17T09:55:47.597242Z 0 [Warning] No existing UUID has been found, so we assume that this is the first time that this server has been started. Generating a new UUID: 14b7b4f3-90e6-11e9-996f-5254005c21a9.
2019-06-17T09:55:47.612981Z 0 [Warning] Gtid table is not ready to be used. Table 'mysql.gtid_executed' cannot be opened.
2019-06-17T09:55:47.613535Z 1 [Note] A temporary password is generated for root@localhost: x/fx9tf<JwO-
[root@host56 ~]# mysql -uroot -p'x/fx9tf<JwO-' -S /dir2/mysqld2.socket
mysql: [Warning] Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 3
Server version: 5.7.20

Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql>
mysql> alter user root@"localhost" identified by "123456";
Query OK, 0 rows affected (0.00 sec)

mysql> exit
Bye
[root@host56 ~]# mysql -uroot -p123456 -S /dir2/mysqld2.socket
mysql> create database db2;
Query OK, 1 row affected (0.00 sec)

mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| db2                |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
5 rows in set (0.00 sec)

mysql> exit
Bye
[root@host56 ~]# ls /dir2
auto.cnf        ib_logfile0  mysqld2.err          performance_schema
db2             ib_logfile1  mysqld2.pid          sys
ib_buffer_pool  ibtmp1       mysqld2.socket
ibdata1         mysql        mysqld2.socket.lock
[root@host56 ~]#

[root@host56 ~]# netstat -utnlp  | grep  mysqld
tcp6       0      0 :::3307                 :::*                    LISTEN      1250/mysql
tcp6       0      0 :::3308                 :::*                    LISTEN      1451/mysql
[root@host56 ~]#

[root@host56 ~]#
[root@host56 ~]# mysqld_multi  --user=root --password=123456  stop 2
[root@host56 ~]#
[root@host56 ~]# netstat -utnlp  | grep  mysqld
tcp6       0      0 :::3307                 :::*                    LISTEN      1250/mysql
[root@host56 ~]#

++++++++++++++++++++++++++++++++++++++++多实例启动失败解决办法+
1 检查配置的编写 及数据库目录是否创建
2 killall  -9  mysqld
3 rm -rf /dir1  ;  rf -rf /dir2
4 重新执行启动实例的命令


++++++++++++++RDBMS2_DAY03----配置数据分片服务器
一、相关概念：
		1.1 什么是数据分片？


]# scp Mycat-server-1.6-RELEASE-20161028204710-linux.tar.gz  root@192.168.4.56:/root/

		1.2 部署MyCAT服务
			1 安装提供服务的软件包
]# yum  -y  install  java-1.8.0-openjdk

已安装:
  java-1.8.0-openjdk.x86_64 1:1.8.0.161-2.b14.el7

作为依赖被安装:
  alsa-lib.x86_64 0:1.1.4.1-2.el7
  copy-jdk-configs.noarch 0:3.3-2.el7
  giflib.x86_64 0:4.1.6-9.el7
  java-1.8.0-openjdk-headless.x86_64 1:1.8.0.161-2.b14.el7
  javapackages-tools.noarch 0:3.4.1-11.el7
  libXtst.x86_64 0:1.2.3-1.el7
  libxslt.x86_64 0:1.1.28-5.el7
  lksctp-tools.x86_64 0:1.0.17-2.el7
  python-javapackages.noarch 0:3.4.1-11.el7
  python-lxml.x86_64 0:3.2.1-4.el7
  tzdata-java.noarch 0:2018c-1.el7

完毕！

[root@mycat56 ~]# which java
/usr/bin/java

[root@mycat56 ~]# java -version
openjdk version "1.8.0_161"
OpenJDK Runtime Environment (build 1.8.0_161-b14)
OpenJDK 64-Bit Server VM (build 25.161-b14, mixed mode)
[root@mycat56 ~]#


tar -zxvf Mycat-server-1.6-RELEASE-20161028204710-linux.tar.gz
[root@mycat56 ~]# ls Mycat-server-1.6-RELEASE-20161028204710-linux.tar.gz
Mycat-server-1.6-RELEASE-20161028204710-linux.tar.gz
[root@mycat56 ~]# tar -zxvf Mycat-server-1.6-RELEASE-20161028204710-linux.tar.gz
mycat/bin/wrapper-linux-ppc-64
mycat/bin/wrapper-linux-x86-64
mycat/bin/wrapper-linux-x86-32
mycat/bin/mycat
mycat/lib/zookeeper-3.4.6.jar
mycat/lib/jline-0.9.94.jar
mycat/lib/ehcache-core-2.6.11.jar
mycat/lib/log4j-1.2.17.jar
mycat/lib/fastjson-1.2.12.jar
mycat/lib/curator-client-2.11.0.jar
mycat/lib/joda-time-2.9.3.jar
mycat/lib/log4j-slf4j-impl-2.5.jar
mycat/lib/libwrapper-linux-x86-32.so
mycat/lib/netty-3.7.0.Final.jar
mycat/lib/druid-1.0.26.jar
mycat/lib/log4j-api-2.5.jar
mycat/lib/mapdb-1.0.7.jar
mycat/lib/slf4j-api-1.6.1.jar
mycat/lib/univocity-parsers-2.2.1.jar
mycat/lib/hamcrest-core-1.3.jar
mycat/lib/Mycat-server-1.6-RELEASE.jar
mycat/lib/objenesis-1.2.jar
mycat/lib/leveldb-api-0.7.jar
mycat/lib/hamcrest-library-1.3.jar
mycat/lib/wrapper.jar
mycat/lib/commons-lang-2.6.jar
mycat/lib/reflectasm-1.03.jar
mycat/lib/mongo-java-driver-2.11.4.jar
mycat/lib/guava-19.0.jar
mycat/lib/curator-recipes-2.11.0.jar
mycat/lib/curator-framework-2.11.0.jar
mycat/lib/libwrapper-linux-ppc-64.so
mycat/lib/log4j-core-2.5.jar
mycat/lib/leveldb-0.7.jar
mycat/lib/sequoiadb-driver-1.12.jar
mycat/lib/mysql-binlog-connector-java-0.4.1.jar
mycat/lib/kryo-2.10.jar
mycat/lib/jsr305-2.0.3.jar
mycat/lib/commons-collections-3.2.1.jar
mycat/lib/disruptor-3.3.4.jar
mycat/lib/log4j-1.2-api-2.5.jar
mycat/lib/velocity-1.7.jar
mycat/lib/libwrapper-linux-x86-64.so
mycat/lib/dom4j-1.6.1.jar
mycat/lib/minlog-1.2.jar
mycat/lib/asm-4.0.jar
mycat/conf/wrapper.conf
mycat/conf/
mycat/conf/zkconf/
mycat/conf/zkdownload/
mycat/conf/sequence_time_conf.properties
mycat/conf/sharding-by-enum.txt
mycat/conf/migrateTables.properties
mycat/conf/zkconf/sequence_time_conf.properties
mycat/conf/zkconf/sharding-by-enum.txt
mycat/conf/zkconf/ehcache.xml
mycat/conf/zkconf/index_to_charset.properties
mycat/conf/zkconf/partition-range-mod.txt
mycat/conf/zkconf/sequence_db_conf.properties
mycat/conf/zkconf/sequence_time_conf-mycat_fz_01.properties
mycat/conf/zkconf/cacheservice.properties
mycat/conf/zkconf/partition-hash-int.txt
mycat/conf/zkconf/autopartition-long.txt
mycat/conf/zkconf/server-mycat_fz_01.xml
mycat/conf/zkconf/auto-sharding-long.txt
mycat/conf/zkconf/rule.xml
mycat/conf/zkconf/auto-sharding-rang-mod.txt
mycat/conf/zkconf/sequence_distributed_conf.properties
mycat/conf/zkconf/sequence_distributed_conf-mycat_fz_01.properties
mycat/conf/zkconf/sequence_conf.properties
mycat/conf/zkconf/schema.xml
mycat/conf/zkconf/server.xml
mycat/conf/ehcache.xml
mycat/conf/index_to_charset.properties
mycat/conf/partition-range-mod.txt
mycat/conf/sequence_db_conf.properties
mycat/conf/cacheservice.properties
mycat/conf/partition-hash-int.txt
mycat/conf/autopartition-long.txt
mycat/conf/auto-sharding-long.txt
mycat/conf/rule.xml
mycat/conf/auto-sharding-rang-mod.txt
mycat/conf/sequence_distributed_conf.properties
mycat/conf/sequence_conf.properties
mycat/conf/myid.properties
mycat/conf/schema.xml
mycat/conf/zkdownload/auto-sharding-long.txt
mycat/conf/server.xml
mycat/version.txt
mycat/conf/log4j2.xml
mycat/bin/init_zk_data.sh
mycat/bin/startup_nowrap.sh
mycat/bin/dataMigrate.sh
mycat/bin/rehash.sh
mycat/logs/
mycat/catlet/
[root@mycat56 ~]#

[root@mycat56 ~]# mv mycat /usr/local/
[root@mycat56 ~]# ls /usr/local/
bin  games    lib    libexec  mysql  share
etc  include  lib64  mycat    sbin   src
[root@mycat56 ~]#
[root@mycat56 ~]# ls /usr/local/mycat/
bin  catlet  conf  lib  logs  version.txt
[root@mycat56 ~]#

			2 修改配置文件
				2.1  ]# vim /usr/local/mycat/conf/server.xml

				2.2  配置数据分片
[root@mycat56 conf]# wc -l schema.xml
77 /root/schema.xml
]# sed -i  '56,77d' schema.xml
]# sed -i  '39,42d' schema.xml
]# sed -i  '16,18d' schema.xml
[root@mycat56 conf]# wc -l schema.xml
48 schema.xml

]# vim /usr/local/mycat/conf/schema.xml
<mycat  >
	<schema >  定义数据分片存储的表
		<table> ...</table>
		<table    />
	</schema>
	<datanode  ...... /> 定义数据库主机名及存储数据的库

	<datahost>......</datahost> 定义数据库服务器ip
</myscat>
			3 配置数据库服器（根据配置文件的设置，配置数据库服务器）
				3.1	创建存储数据库
host55 ~]# mysql -uroot -p123qqq...A -e  "create database db3"
host54 ~]# mysql -uroot -p123qqq...A -e  "create database db2"
host53 ~]# mysql -uroot -p123qqq...A -e  "create database db1"
				3.2	用户授权
host53mysql> grant all on  *.* to adminplj@"%" identified by "123qqq...A" ;
host54mysql> grant all on  *.* to adminplj@"%" identified by "123qqq...A" ;
host55mysql> grant all on  *.* to adminplj@"%" identified by "123qqq...A" ;

			4 启动MyCAT服务，并查看服务信息
4.1 测试数据库服务器的授权用户adminplj
      ]# yum  -y   install mariadb

  318  mysql -h192.168.4.53 -uadminplj -p123qqq...A
  319  mysql -h192.168.4.54 -uadminplj -p123qqq...A
  320  mysql -h192.168.4.55 -uadminplj -p123qqq...A

4.2 启动服务
]# /usr/local/mycat/bin/mycat  start
[root@mycat56 conf]# netstat  -utnlp  | grep  :8066
[root@mycat56 conf]#
[root@mycat56 conf]# ls /usr/local/mycat/logs/
[root@mycat56 conf]#

[root@mycat56 conf]# /usr/local/mycat/bin/mycat  start
Starting Mycat-server...
[root@mycat56 conf]#

4.3 查看状态
[root@mycat56 conf]# netstat  -utnlp  | grep  :8066
tcp6       0      0 :::8066                 :::*                    LISTEN      1125/java
[root@mycat56 conf]#
[root@mycat56 conf]# ls /usr/local/mycat/logs/
mycat.log  mycat.pid  wrapper.log

[root@mycat56 conf]#
[root@mycat56 conf]# ps -C java
  PID TTY          TIME CMD
 1125 ?        00:00:01 java
[root@mycat56 conf]#


NFO   | jvm 1    | 2019/06/18 15:20:07 | Caused by: io.mycat.config.util.ConfigException: dataNode dn3 reference dataHost:localhost55  not exists!

			5 测试配置
				5.1 客户端连接分片服务器访问数据
				]# mysql -h192.168.4.56 -P8066 -uroot -p123456
[root@host50 ~]# mysql -h192.168.4.56 -P8066 -uroot -p123456
mysql: [Warning] Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 1
Server version: 5.6.29-mycat-1.6-RELEASE-20161028204710 MyCat Server (OpenCloundDB)

Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql>
mysql> show databases;
+----------+
| DATABASE |
+----------+
| TESTDB   |
+----------+
1 row in set (0.01 sec)

mysql> use TESTDB;
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Database changed
mysql> show tables;
+------------------+
| Tables in TESTDB |
+------------------+
| company          |
| customer         |
| customer_addr    |
| employee         |
| goods            |
| hotnews          |
| orders           |
| order_items      |
| travelrecord     |
+------------------+
9 rows in set (0.00 sec)

mysql> desc company;
ERROR 1146 (42S02): Table 'db3.company' doesn't exist
mysql>

	3. 存储数据（sharding-by-intfile）
		3.1 修改算法配置文件
]# vim /usr/local/mycat/conf/partition-hash-int.txt
                        10000=0    //数据存储到dn1库里
                        10010=1	  //数据存储到dn2库里
	           	10020=2    //数据存储到dn3库里

:wq
		3.2 重启mycat服务
[root@mycat56 conf]# /usr/local/mycat/bin/mycat  stop
Stopping Mycat-server...
Stopped Mycat-server.
[root@mycat56 conf]# netstat -utnlp  | grep  :8066
[root@mycat56 conf]#
[root@mycat56 conf]# /usr/local/mycat/bin/mycat  start
Starting Mycat-server...
[root@mycat56 conf]#
[root@mycat56 conf]# netstat -utnlp  | grep  :8066
tcp6       0      0 :::8066                 :::*                    LISTEN      1364/java
[root@mycat56 conf]#

		3.3 客户端连接mycat服务器，测试分片存储
			建表
]# mysql -h192.168.4.56 -P8066 -uroot -p123456
mysql> use TESTDB;
mysql> create table  employee( ID int primary key , sharding_id int,
    -> name char(15) , age  int );
Query OK, 0 rows affected (0.68 sec)

mysql> desc employee;
+-------------+----------+------+-----+---------+-------+
| Field       | Type     | Null | Key | Default | Extra |
+-------------+----------+------+-----+---------+-------+
| ID          | int(11)  | NO   | PRI | NULL    |       |
| sharding_id | int(11)  | YES  |     | NULL    |       |
| name        | char(15) | YES  |     | NULL    |       |
| age         | int(11)  | YES  |     | NULL    |       |
+-------------+----------+------+-----+---------+-------+
4 rows in set (0.00 sec)

mysql>

mysql> mysql> show tables; (53/54/55)
+---------------+
| Tables_in_db2 |
+---------------+
| employee      |
+---------------+
1 row in set (0.00 sec)

mysql>

			插入记录



Query OK, 3 rows affected (0.07 sec)
Records: 3  Duplicates: 0  Warnings: 0

insert into employee(ID,sharding_id,name,age) values  (1,10000,"bob2",19), (2,10010,"tom2",21), (3,10020,"lucy2",16);


mysql> select  * from employee;
+----+-------------+------+------+
| ID | sharding_id | name | age  |
+----+-------------+------+------+
|  1 |       10000 | bob  |   19 |
|  2 |       10010 | tom  |   21 |
|  3 |       10020 | lucy |   16 |
+----+-------------+------+------+
3 rows in set (0.06 sec)


mysql> insert into employee(ID,sharding_id,name,age)
values
(4,10000,"bob2",19),
(5,10000,"tom2",21),
(6,10000,"lucy2",16);

>
mysql> select  * from employee;                                              +----+-------------+-------+------+
| ID | sharding_id | name  | age  |
+----+-------------+-------+------+
|  1 |       10000 | bob   |   19 |
|  4 |       10000 | bob2  |   19 |
|  5 |       10000 | tom2  |   21 |
|  6 |       10000 | lucy2 |   16 |
|  3 |       10020 | lucy  |   16 |
|  2 |       10010 | tom   |   21 |
+----+-------------+-------+------+
6 rows in set (0.00 sec)

mysql>

mysql> mysql> select  * from db1.employee; (192.168.4.51)
+----+-------------+-------+------+
| ID | sharding_id | name  | age  |
+----+-------------+-------+------+
|  1 |       10000 | bob   |   19 |
|  4 |       10000 | bob2  |   19 |
|  5 |       10000 | tom2  |   21 |
|  6 |       10000 | lucy2 |   16 |
+----+-------------+-------+------+
4 rows in set (0.00 sec)

mysql>
			求模法分片规则的使用 mod-long
				根据字段值与设定的数字求模结果存储数据
	]#vim  schema.xml
	<table name="hotnews"  dataNode="dn1,dn2,dn3"
                           rule="mod-long" />

	:wq

	]#vim rule.xml
	<tableRule name="mod-long">
                <rule>
                        <columns>num</columns>
                        <algorithm>mod-long</algorithm>
                </rule>
        </tableRule>

	<function name="mod-long" class="io.mycat.route.function.PartitionByMod">
                <!-- how many data nodes -->
                <property name="count">3</property>
        </function>
	:wq


[root@mycat56 ~]# /usr/local/mycat/bin/mycat  stop
Stopping Mycat-server...
Stopped Mycat-server.
[root@mycat56 ~]#
[root@mycat56 ~]# netstat -utnlp  | grep  :8066
[root@mycat56 ~]# ps -C java
  PID TTY          TIME CMD
[root@mycat56 ~]#
[root@mycat56 ~]# /usr/local/mycat/bin/mycat  start
Starting Mycat-server...
[root@mycat56 ~]#
[root@mycat56 ~]# netstat -utnlp  | grep  :8066
tcp6       0      0 :::8066                 :::*                    LISTEN      2253/java
[root@mycat56 ~]# ps -C java
  PID TTY          TIME CMD
 2253 ?        00:00:01 java
[root@mycat56 ~]#
		在客户端验证求模分片规则

]# mysql  -h192.168.4.56 -P8066 -uroot -p123456
mysql> use TESTDB;
mysql> desc hotnews;
ERROR 1146 (42S02): Table 'db2.hotnews' doesn't exist     休息到10：00

mysql> create table hotnews(num int ,title char(30),comment char(200));
Query OK, 0 rows affected (0.79 sec)

mysql> desc hotnews;
+---------+-----------+------+-----+---------+-------+
| Field   | Type      | Null | Key | Default | Extra |
+---------+-----------+------+-----+---------+-------+
| num     | int(11)   | YES  |     | NULL    |       |
| title   | char(30)  | YES  |     | NULL    |       |
| comment | char(200) | YES  |     | NULL    |       |
+---------+-----------+------+-----+---------+-------+
3 rows in set (0.00 sec)
mysql> insert into hotnews(num,title,comment)values(9,"sc","xxxxx");
Query OK, 1 row affected (0.11 sec)

mysql> insert into hotnews(num,title,comment)values(10,"xx","haha");
Query OK, 1 row affected (0.05 sec)

mysql> insert into hotnews(num,title,comment)values(11,"yy","zz");
Query OK, 1 row affected (0.03 sec)

mysql> select  * from hotnews;
+------+-------+---------+
| num  | title | comment |
+------+-------+---------+
|   11 | yy    | zz      |
|   10 | xx    | haha    |
|    9 | sc    | xxxxx   |
+------+-------+---------+
3 rows in set (0.01 sec)

mysql>
ql>  select  * from db1.hotnews;
+------+-------+---------+
| num  | title | comment |
+------+-------+---------+
|    9 | sc    | xxxxx   |
+------+-------+---------+
1 row in set (0.00 sec)

mysql>
mysql>  select  * from db2.hotnews;
+------+-------+---------+
| num  | title | comment |
+------+-------+---------+
|   10 | xx    | haha    |
+------+-------+---------+
1 row in set (0.00 sec)

mysql>
mysql> select  * from db3.hotnews;
+------+-------+---------+
| num  | title | comment |
+------+-------+---------+
|   11 | yy    | zz      |
+------+-------+---------+
1 row in set (0.00 sec)

mysql>
			添加新库新表

[root@mycat56 ~]# vim /usr/local/mycat/conf/server.xml
<user name="root">
                <property name="password">123456</property>
                <property name="schemas">TESTDB,BBSDB</property>

:wq

[root@mycat56 ~]# vim /usr/local/mycat/conf/schema.xml
<mycat:schema xmlns:mycat="http://io.mycat/">
        <schema name="BBSDB" checkSQLschema="false" sqlMaxLimit="100">
          <table name="company" primaryKey="ID" type="global" dataNode="dn1,dn2,dn3" />

          <table name="employee" primaryKey="ID" dataNode="dn1,dn2,dn3"
                           rule="sharding-by-intfile" />
        </schema>

:wq

[root@mycat56 ~]# /usr/local/mycat/bin/mycat  stop
Stopping Mycat-server...
Stopped Mycat-server.
[root@mycat56 ~]# ps -C java
  PID TTY          TIME CMD
[root@mycat56 ~]#
[root@mycat56 ~]# netstat -utnlp  | grep  :8066
[root@mycat56 ~]#
[root@mycat56 ~]# /usr/local/mycat/bin/mycat  start
Starting Mycat-server...
[root@mycat56 ~]#
[root@mycat56 ~]# netstat -utnlp  | grep  :8066
tcp6       0      0 :::8066                 :::*                    LISTEN      2496/java
[root@mycat56 ~]#
[root@mycat56 ~]# ps -C mycat
  PID TTY          TIME CMD
[root@mycat56 ~]# ps -C java
  PID TTY          TIME CMD
 2496 ?        00:00:01 java
[root@mycat56 ~]#
			客户端连接mycat服务器 访问数据

[root@host50 ~]# mysql -h192.168.4.56 -P8066 -uroot -p123456
mysql: [Warning] Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 1
Server version: 5.6.29-mycat-1.6-RELEASE-20161028204710 MyCat Server (OpenCloundDB)

Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql> show databases;
+----------+
| DATABASE |
+----------+
| BBSDB    |
| TESTDB   |
+----------+
2 rows in set (0.00 sec)

mysql> use BBSDB;
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Database changed
mysql> show tables;
+-----------------+
| Tables in BBSDB |
+-----------------+
| company         |
| employee        |
+-----------------+
2 rows in set (0.00 sec)
mysql> desc company;
ERROR 1146 (42S02): Table 'db1.company' doesn't exist
mysql>
mysql> create table company(ID int primary key,name char(50),addr char(50));
Query OK, 0 rows affected (1.01 sec)

mysql> desc company;
+-------+----------+------+-----+---------+-------+
| Field | Type     | Null | Key | Default | Extra |
+-------+----------+------+-----+---------+-------+
| ID    | int(11)  | NO   | PRI | NULL    |       |
| name  | char(50) | YES  |     | NULL    |       |
| addr  | char(50) | YES  |     | NULL    |       |
+-------+----------+------+-----+---------+-------+
3 rows in set (0.00 sec)

mysql> insert into company(ID,name,addr)values(1,"tarena","beijing");
Query OK, 1 row affected (0.10 sec)

mysql> insert into company(ID,name,addr)values(2,"tmall","beijing");
Query OK, 1 row affected (0.15 sec)

mysql> insert into company(ID,name,addr)values(3,"sina","beijing");
Query OK, 1 row affected (0.13 sec)

mysql> select  * from company;
+----+--------+---------+
| ID | name   | addr    |
+----+--------+---------+
|  1 | tarena | beijing |
|  2 | tmall  | beijing |
|  3 | sina   | beijing |
+----+--------+---------+
3 rows in set (0.04 sec)

mysql>

在数据库服务器本机查看

mysql> desc db1.company;
+-------+----------+------+-----+---------+-------+
| Field | Type     | Null | Key | Default | Extra |
+-------+----------+------+-----+---------+-------+
| ID    | int(11)  | NO   | PRI | NULL    |       |
| name  | char(50) | YES  |     | NULL    |       |
| addr  | char(50) | YES  |     | NULL    |       |
+-------+----------+------+-----+---------+-------+
3 rows in set (0.00 sec)

mysql> select  * from db1.company;
+----+--------+---------+
| ID | name   | addr    |
+----+--------+---------+
|  1 | tarena | beijing |
|  2 | tmall  | beijing |
|  3 | sina   | beijing |
+----+--------+---------+
3 rows in set (0.00 sec)

mysql>

++++++++++++++++++++RDBMS2_day04 部署MHA集群（mysql）
集群：多台服务器一起提供相同的服务
集群分类：LB   HA  HPC
集群服务软件：LVS Haproxy nginx   keepalived

一、MHA集群概述
	1.1 MHA介绍

二、部署MHA集群
	2.1 、集群环境准备

准备3台新的数据库服务器 192.168.4.51 192.168.4.52 192.168.4.53
准备2台新的虚拟机 配置ip地址是 192.168.4.57即可 ip地址是 192.168.4.50即可


1、数据库服务器 192.168.4.51 192.168.4.52 192.168.4.53 彼此之间可以root 用户无密码登陆

2、主机192.168.4.57 可以root 用户无密码登陆数据库服务器 192.168.4.51 192.168.4.52 192.168.4.53

[root@host57 ~]# ssh-keygen
Generating public/private rsa key pair.
Enter file in which to save the key (/root/.ssh/id_rsa):
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /root/.ssh/id_rsa.
Your public key has been saved in /root/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:JjmS3YP6UyZNK6PuLiUEPhpUi3c4Soy/DETeYndmk2Y root@host57
The key's randomart image is:
+---[RSA 2048]----+
| ...             |
|*.o o .          |
|+X B E           |
|=+* Oo.+.        |
|o+o o *oS.       |
|.o...o++=.       |
|  oo.. *         |
|  . ...          |
|   =+ ..         |
+----[SHA256]-----+
[root@host57 ~]# ssh-copy-id




[root@host57 ~]# ssh-copy-id root@192.168.4.51
/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: "/root/.ssh/id_rsa.pub"
/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed
/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys
root@192.168.4.51's password:

Number of key(s) added: 1

Now try logging into the machine, with:   "ssh 'root@192.168.4.51'"
and check to make sure that only the key(s) you wanted were added.

[root@host57 ~]# ssh-copy-id root@192.168.4.52
/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: "/root/.ssh/id_rsa.pub"
/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed
/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys
root@192.168.4.52's password:

Number of key(s) added: 1

Now try logging into the machine, with:   "ssh 'root@192.168.4.52'"
and check to make sure that only the key(s) you wanted were added.

[root@host57 ~]# ssh-copy-id root@192.168.4.53
/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: "/root/.ssh/id_rsa.pub"
/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed
/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys
root@192.168.4.53's password:

Number of key(s) added: 1

Now try logging into the machine, with:   "ssh 'root@192.168.4.53'"
and check to make sure that only the key(s) you wanted were added.

[root@host57 ~]#




3、在主机192.168.4.51/52/53/57  yum -y  install perl-*

4 配置一主多从同步结构 192.168.4.51 是主数据库服务器
  192.168.4.52 和 192.168.4.53 做从服务器。

[root@host52 ~]# mysql -uroot -p123qqq...A -e "show slave status\G" | grep -i yes
mysql: [Warning] Using a password on the command line interface can be insecure.
             Slave_IO_Running: Yes
            Slave_SQL_Running: Yes
[root@host52 ~]#
[root@host52 ~]#
[root@host52 ~]# mysql -uroot -p123qqq...A -e "show slave status\G" | grep -i 192
mysql: [Warning] Using a password on the command line interface can be insecure.
                  Master_Host: 192.168.4.51
[root@host52 ~]#
[root@host52 ~]#
[root@host52 ~]#
[root@host52 ~]# mysql -uroot -p123qqq...A -e "show slave status\G" | grep -i repluser
mysql: [Warning] Using a password on the command line interface can be insecure.
                  Master_User: repluser



5 准备软件包
]# scp -r mha-soft-student  root@192.168.4.57:/root/
]# scp -r mha-soft-student  root@192.168.4.51:/root/
]# scp -r mha-soft-student  root@192.168.4.52:/root/
]# scp -r mha-soft-student  root@192.168.4.53:/root/

在主机57/51/52/53 执行安装
]# cd mha-soft-student
]# yum -y  install  perl-*
]# rpm -qa  | grep  -i perl | wc -l




[root@host57 mha-soft-student]# rpm -ivh  mha4mysql-node-0.56-0.el6.noarch.rpm
准备中...                          ################################# [100%]
正在升级/安装...
   1:mha4mysql-node-0.56-0.el6        ################################# [100%]
[root@host57 mha-soft-student]#
[root@host57 mha-soft-student]# rpm -qa | grep  mha
mha4mysql-node-0.56-0.el6.noarch
[root@host57 mha-soft-student]#

[root@host57 mha-soft-student]# tar -zxvf mha4mysql-manager-0.56.tar.gz
mha4mysql-manager-0.56/
mha4mysql-manager-0.56/debian/
mha4mysql-manager-0.56/debian/control
mha4mysql-manager-0.56/debian/copyright
.......


[root@host57 mha-soft-student]# ls
app1.cnf            mha4mysql-manager-0.56         mha4mysql-node-0.56-0.el6.noarch.rpm
master_ip_failover  mha4mysql-manager-0.56.tar.gz
[root@host57 mha-soft-student]# cd mha4mysql-manager-0.56/
[root@host57 mha4mysql-manager-0.56]# ls
AUTHORS  COPYING  inc  Makefile.PL  META.yml  rpm      t
bin      debian   lib  MANIFEST     README    samples  tests
[root@host57 mha4mysql-manager-0.56]#
[root@host57 mha4mysql-manager-0.56]# perl Makefile.PL
*** Module::AutoInstall version 1.03
*** Checking for Perl dependencies...
[Core Features]
- DBI                   ...loaded. (1.627)
- DBD::mysql            ...loaded. (4.023)
- Time::HiRes           ...loaded. (1.9725)
- Config::Tiny          ...loaded. (2.14)
- Log::Dispatch         ...loaded. (2.41)
- Parallel::ForkManager ...loaded. (1.18)
- MHA::NodeConst        ...loaded. (0.56)
*** Module::AutoInstall configuration finished.
Checking if your kit is complete...
Looks good
Writing Makefile for mha4mysql::manager
Writing MYMETA.yml and MYMETA.json
[root@host57 mha4mysql-manager-0.56]#  make
[root@host57 mha4mysql-manager-0.56]#  make install


[root@host57 mha4mysql-manager-0.56]# ls /root/perl5/bin
masterha_check_repl    masterha_conf_host       masterha_master_switch
masterha_check_ssh     masterha_manager         masterha_secondary_check
masterha_check_status  masterha_master_monitor  masterha_stop

 		编写主配置文件
]# mkdir /etc/mha
]# cp mha4mysql-manager-0.56/samples/conf/app1.cnf  /etc/mha/
]# vim  mkdir /etc/mha/app1.cnf
[server default]
manager_workdir=/etc/mha
manager_log=/etc/mha/manager.log
master_ip_failover_script=/etc/mha/master_ip_failover
ssh_user=root
ssh_port=22
repl_user=repluser
repl_password=123qqq...A
user=root
password=123qqq...A
[server1]
hostname=192.168.4.51
port=3306
candidate_master=1
[server2]
hostname=192.168.4.52
port=3306
candidate_master=1
[server3]
hostname=192.168.4.53
port=3306
candidate_master=1
:wq


创建故障切换脚本
[root@host57 ~]# cp mha-soft-student/master_ip_failover /etc/mha/
[root@host57 ~]# vim +35 /etc/mha/master_ip_failover
my $vip = '192.168.4.100/24';  # Virtual IP
my $key = "1";
my $ssh_start_vip = "/sbin/ifconfig eth0:$key $vip";
my $ssh_stop_vip = "/sbin/ifconfig eth0:$key down";
:wq
[root@host57 ~]# chmod +x  /etc/mha/master_ip_failover


在主服务器51  部署VIP地址
host51]#
[root@host51 ~]# ifconfig  eth0:1
eth0:1: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        ether 52:54:00:d8:10:d7  txqueuelen 1000  (Ethernet)

[root@host51 ~]# ifconfig  eth0:1  192.168.4.100

[root@host51 ~]# ifconfig  eth0:1
eth0:1: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.4.100  netmask 255.255.255.0  broadcast 192.168.4.255
        ether 52:54:00:d8:10:d7  txqueuelen 1000  (Ethernet)


ot@host50 ~]# ping -c 2  192.168.4.100
PING 192.168.4.100 (192.168.4.100) 56(84) bytes of data.
64 bytes from 192.168.4.100: icmp_seq=1 ttl=255 time=0.169 ms
64 bytes from 192.168.4.100: icmp_seq=2 ttl=255 time=0.183 ms

--- 192.168.4.100 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 999ms
rtt min/avg/max/mdev = 0.169/0.176/0.183/0.007 ms
[root@host50 ~]#


		2 配置数据节点(192.168.4.51/52/53)
			2.1 安装mha_node软件包
]# cd mha-soft-student/
]# yum -y  install  mha4mysql-node-0.56-0.el6.noarch.rpm

			2.2 添加授权用户
				2.2.1添加从服务器同步数据连接用户
		[root@host51 ~]# mysql -uroot -p123qqq...A -e 'show grants for repluser@"%"'
mysql: [Warning] Using a password on the command line interface can be insecure.
+--------------------------------------------------+
| Grants for repluser@%                            |
+--------------------------------------------------+
| GRANT REPLICATION SLAVE ON *.* TO 'repluser'@'%' |
+--------------------------------------------------+
[root@host51 ~]#
				52]# mysql -uroot -p123qqq...A
				mysql> grant replication slave on *.* to
repluser@"%" identified by "123qqq...A";

				53]# mysql -uroot -p123qqq...A
                                mysql> grant replication slave on *.* to
repluser@"%" identified by "123qqq...A";



				2.2.2、添加57主机的监控连接用户

host51 mysql> grant    all   on  *.*  to  root@"%"  identified  by “123qqq…A”;
host52 mysql> grant    all   on  *.*  to  root@"%"  identified  by “123qqq…A”;
host53 mysql> grant    all   on  *.*  to  root@"%"  identified  by “123qqq…A”;

			2.3 修改数据库服务运行参数

			host51]# vim /etc/my.cnf
				 [mysqld]
					plugin-load = "rpl_semi_sync_master=semisync_master.so;rpl_semi_sync_slave=semisync_slave.so” //加载模块
					rpl_semi_sync_master_enabled=1  //启用master模块
					rpl_semi_sync_slave_enabled=1     //启用slave模块
					relay_log_purge=0   //禁止自动删除中继日志文件
					:wq
			 	]#  systemctl  restart  mysqld

			host52]# vim  /etc/my.cnf
 					[mysqld]
                                        plugin-load = "rpl_semi_sync_master=semisync_master.so;rpl_semi_sync_slave=semisync_slave.so” //加载模块
                                        rpl_semi_sync_master_enabled=1  //启用master模块
                                        rpl_semi_sync_slave_enabled=1     //启用slave模块
                                        relay_log_purge=0   //禁止自动删除中继日志文件
					server_id=52
					log-bin=master52
					relay_log_purge=0
					:wq
				]#  systemctl  restart  mysqld
[root@host52 mysql]#  mysql -uroot -p123qqq...A -e "show slave status\G" | grep -i yes
[root@host52 mysql]#  mysql -uroot -p123qqq...A -e "show slave status\G" | grep 192
		host53]# vim  /etc/my.cnf
                                        [mysqld]
                                        plugin-load = "rpl_semi_sync_master=semisync_master.so;rpl_semi_sync_slave=semisync_slave.so” //加载模块
                                        rpl_semi_sync_master_enabled=1  //启用master模块
                                        rpl_semi_sync_slave_enabled=1     //启用slave模块
                                        relay_log_purge=0   //禁止自动删除中继日志文件
                                        server_id=53
                                        log-bin=master53
                                        relay_log_purge=0
                                        :wq
                                ]#  systemctl  restart  mysqld
[root@host52 mysql]#  mysql -uroot -p123qqq...A -e "show slave status\G" | grep -i yes
[root@host52 mysql]#  mysql -uroot -p123qqq...A -e "show slave status\G" | grep 192

			3 测试配置 (192.168.4.57)
 				3.1  测试SSH配置
[root@host57 ~]# masterha_check_ssh --conf=/etc/mha/app1.cnf
Thu Jun 20 15:33:48 2019 - [warning] Global configuration file /etc/masterha_default.cnf not found. Skipping.
Thu Jun 20 15:33:48 2019 - [info] Reading application default configuration from /etc/mha/app1.cnf..
Thu Jun 20 15:33:48 2019 - [info] Reading server configuration from /etc/mha/app1.cnf..
Thu Jun 20 15:33:48 2019 - [info] Starting SSH connection tests..
Thu Jun 20 15:33:49 2019 - [debug]
Thu Jun 20 15:33:48 2019 - [debug]  Connecting via SSH from root@192.168.4.51(192.168.4.51:22) to root@192.168.4.52(192.168.4.52:22)..
Thu Jun 20 15:33:49 2019 - [debug]   ok.
Thu Jun 20 15:33:49 2019 - [debug]  Connecting via SSH from root@192.168.4.51(192.168.4.51:22) to root@192.168.4.53(192.168.4.53:22)..
Thu Jun 20 15:33:49 2019 - [debug]   ok.
Thu Jun 20 15:33:50 2019 - [debug]
Thu Jun 20 15:33:49 2019 - [debug]  Connecting via SSH from root@192.168.4.52(192.168.4.52:22) to root@192.168.4.51(192.168.4.51:22)..
Thu Jun 20 15:33:49 2019 - [debug]   ok.
Thu Jun 20 15:33:49 2019 - [debug]  Connecting via SSH from root@192.168.4.52(192.168.4.52:22) to root@192.168.4.53(192.168.4.53:22)..
Thu Jun 20 15:33:49 2019 - [debug]   ok.
Thu Jun 20 15:33:51 2019 - [debug]
Thu Jun 20 15:33:49 2019 - [debug]  Connecting via SSH from root@192.168.4.53(192.168.4.53:22) to root@192.168.4.51(192.168.4.51:22)..
Thu Jun 20 15:33:50 2019 - [debug]   ok.
Thu Jun 20 15:33:50 2019 - [debug]  Connecting via SSH from root@192.168.4.53(192.168.4.53:22) to root@192.168.4.52(192.168.4.52:22)..
Thu Jun 20 15:33:50 2019 - [debug]   ok.
Thu Jun 20 15:33:51 2019 - [info] All SSH connection tests passed successfully.

				3.2  测试主从同步
[root@host57 ~]# masterha_check_repl --conf=/etc/mha/app1.cnf
Thu Jun 20 15:37:46 2019 - [warning] Global configuration file /etc/masterha_default.cnf not found. Skipping.
Thu Jun 20 15:37:46 2019 - [info] Reading application default configuration from /etc/mha/app1.cnf..
Thu Jun 20 15:37:46 2019 - [info] Reading server configuration from /etc/mha/app1.cnf..
Thu Jun 20 15:37:46 2019 - [info] MHA::MasterMonitor version 0.56.
Thu Jun 20 15:37:47 2019 - [info] GTID failover mode = 0
Thu Jun 20 15:37:47 2019 - [info] Dead Servers:
Thu Jun 20 15:37:47 2019 - [info] Alive Servers:
Thu Jun 20 15:37:47 2019 - [info]   192.168.4.51(192.168.4.51:3306)
Thu Jun 20 15:37:47 2019 - [info]   192.168.4.52(192.168.4.52:3306)
Thu Jun 20 15:37:47 2019 - [info]   192.168.4.53(192.168.4.53:3306)
Thu Jun 20 15:37:47 2019 - [info] Alive Slaves:
Thu Jun 20 15:37:47 2019 - [info]   192.168.4.52(192.168.4.52:3306)  Version=5.7.17-log (oldest major version between slaves) log-bin:enabled
Thu Jun 20 15:37:47 2019 - [info]     Replicating from 192.168.4.51(192.168.4.51:3306)
Thu Jun 20 15:37:47 2019 - [info]     Primary candidate for the new Master (candidate_master is set)
Thu Jun 20 15:37:47 2019 - [info]   192.168.4.53(192.168.4.53:3306)  Version=5.7.17-log (oldest major version between slaves) log-bin:enabled
Thu Jun 20 15:37:47 2019 - [info]     Replicating from 192.168.4.51(192.168.4.51:3306)
Thu Jun 20 15:37:47 2019 - [info]     Primary candidate for the new Master (candidate_master is set)
Thu Jun 20 15:37:47 2019 - [info] Current Alive Master: 192.168.4.51(192.168.4.51:3306)
Thu Jun 20 15:37:47 2019 - [info] Checking slave configurations..
Thu Jun 20 15:37:47 2019 - [info]  read_only=1 is not set on slave 192.168.4.52(192.168.4.52:3306).
Thu Jun 20 15:37:47 2019 - [info]  read_only=1 is not set on slave 192.168.4.53(192.168.4.53:3306).
Thu Jun 20 15:37:47 2019 - [info] Checking replication filtering settings..
Thu Jun 20 15:37:47 2019 - [info]  binlog_do_db= , binlog_ignore_db=
Thu Jun 20 15:37:47 2019 - [info]  Replication filtering check ok.
Thu Jun 20 15:37:47 2019 - [info] GTID (with auto-pos) is not supported
Thu Jun 20 15:37:47 2019 - [info] Starting SSH connection tests..
Thu Jun 20 15:37:49 2019 - [info] All SSH connection tests passed successfully.
Thu Jun 20 15:37:49 2019 - [info] Checking MHA Node version..
Thu Jun 20 15:37:50 2019 - [info]  Version check ok.
Thu Jun 20 15:37:50 2019 - [info] Checking SSH publickey authentication settings on the current master..
Thu Jun 20 15:37:50 2019 - [info] HealthCheck: SSH to 192.168.4.51 is reachable.
Thu Jun 20 15:37:50 2019 - [info] Master MHA Node version is 0.56.
Thu Jun 20 15:37:50 2019 - [info] Checking recovery script configurations on 192.168.4.51(192.168.4.51:3306)..
Thu Jun 20 15:37:50 2019 - [info]   Executing command: save_binary_logs --command=test --start_pos=4 --binlog_dir=/var/lib/mysql,/var/log/mysql --output_file=/var/tmp/save_binary_logs_test --manager_version=0.56 --start_file=master51.000002
Thu Jun 20 15:37:50 2019 - [info]   Connecting to root@192.168.4.51(192.168.4.51:22)..
  Creating /var/tmp if not exists..    ok.
  Checking output directory is accessible or not..
   ok.
  Binlog found at /var/lib/mysql, up to master51.000002
Thu Jun 20 15:37:50 2019 - [info] Binlog setting check done.
Thu Jun 20 15:37:50 2019 - [info] Checking SSH publickey authentication and checking recovery script configurations on all alive slave servers..
Thu Jun 20 15:37:50 2019 - [info]   Executing command : apply_diff_relay_logs --command=test --slave_user='root' --slave_host=192.168.4.52 --slave_ip=192.168.4.52 --slave_port=3306 --workdir=/var/tmp --target_version=5.7.17-log --manager_version=0.56 --relay_log_info=/var/lib/mysql/relay-log.info  --relay_dir=/var/lib/mysql/  --slave_pass=xxx
Thu Jun 20 15:37:50 2019 - [info]   Connecting to root@192.168.4.52(192.168.4.52:22)..
  Checking slave recovery environment settings..
    Opening /var/lib/mysql/relay-log.info ... ok.
    Relay log found at /var/lib/mysql, up to host52-relay-bin.000006
    Temporary relay log file is /var/lib/mysql/host52-relay-bin.000006
    Testing mysql connection and privileges..mysql: [Warning] Using a password on the command line interface can be insecure.
 done.
    Testing mysqlbinlog output.. done.
    Cleaning up test file(s).. done.
Thu Jun 20 15:37:51 2019 - [info]   Executing command : apply_diff_relay_logs --command=test --slave_user='root' --slave_host=192.168.4.53 --slave_ip=192.168.4.53 --slave_port=3306 --workdir=/var/tmp --target_version=5.7.17-log --manager_version=0.56 --relay_log_info=/var/lib/mysql/relay-log.info  --relay_dir=/var/lib/mysql/  --slave_pass=xxx
Thu Jun 20 15:37:51 2019 - [info]   Connecting to root@192.168.4.53(192.168.4.53:22)..
  Checking slave recovery environment settings..
    Opening /var/lib/mysql/relay-log.info ... ok.
    Relay log found at /var/lib/mysql, up to host53-relay-bin.000006
    Temporary relay log file is /var/lib/mysql/host53-relay-bin.000006
    Testing mysql connection and privileges..mysql: [Warning] Using a password on the command line interface can be insecure.
 done.
    Testing mysqlbinlog output.. done.
    Cleaning up test file(s).. done.
Thu Jun 20 15:37:52 2019 - [info] Slaves settings check done.
Thu Jun 20 15:37:52 2019 - [info]
192.168.4.51(192.168.4.51:3306) (current master)
 +--192.168.4.52(192.168.4.52:3306)
 +--192.168.4.53(192.168.4.53:3306)

Thu Jun 20 15:37:52 2019 - [info] Checking replication health on 192.168.4.52..
Thu Jun 20 15:37:52 2019 - [info]  ok.
Thu Jun 20 15:37:52 2019 - [info] Checking replication health on 192.168.4.53..
Thu Jun 20 15:37:52 2019 - [info]  ok.
Thu Jun 20 15:37:52 2019 - [info] Checking master_ip_failover_script status:
Thu Jun 20 15:37:52 2019 - [info]   /etc/mha/master_ip_failover --command=status --ssh_user=root --orig_master_host=192.168.4.51 --orig_master_ip=192.168.4.51 --orig_master_port=3306
Thu Jun 20 15:37:52 2019 - [info]  OK.
Thu Jun 20 15:37:52 2019 - [warning] shutdown_script is not defined.
Thu Jun 20 15:37:52 2019 - [info] Got exit code 0 (Not master dead).

MySQL Replication Health is OK.


			4 启动管理服务 (192.168.4.57)
[root@host57 ~]# masterha_check_status  --conf=/etc/mha/app1.cnf
app1 is stopped(2:NOT_RUNNING).
[root@host57 ~]#



]# masterha_manager --conf=/etc/mha/app1.cnf  --remove_dead_master_conf \
--ignore_last_failover

Thu Jun 20 17:05:58 2019 - [warning] Global configuration file /etc/masterha_default.cnf not found. Skipping.
Thu Jun 20 17:05:58 2019 - [info] Reading application default configuration from /etc/mha/app1.cnf..
Thu Jun 20 17:05:58 2019 - [info] Reading server configuration from /etc/mha/app1.cnf..




ot@host57 ~]# masterha_check_status  --conf=/etc/mha/app1.cnf
app1 (pid:15806) is running(0:PING_OK), master:192.168.4.51
[root@host57 ~]#


[root@host51 ~]# ifconfig  eth0:1
eth0:1: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.4.100  netmask 255.255.255.0  broadcast 192.168.4.255
        ether 52:54:00:d8:10:d7  txqueuelen 1000  (Ethernet)

[root@host51 ~]#

[root@host57 ~]# cat /etc/mha/app1.master_status.health
15806	0:PING_OK	master:192.168.4.51


查看工作目录
[root@host57 ~]# ls /etc/mha/
app1.cnf  app1.master_status.health  manager.log  master_ip_failover
[root@host57 ~]#
[root@host57 ~]#
[root@host57 ~]# cat /etc/mha/app1.master_status.health
15806	0:PING_OK	master:192.168.4.51[root@host57 ~]#
[root@host57 ~]#



			5 客户端50 连接vip地址访问集群
				5.1 在主服务器51 添加访问数据的连接用户
]# mysql  -uroot -p123qqq...A
mysql> create database db9;
Query OK, 1 row affected (0.05 sec)

mysql> create table db9.a (id int);
Query OK, 0 rows affected (0.63 sec)

mysql> grant select,insert on db9.* to yaya55@"%" identified by "123qqq...A";
Query OK, 0 rows affected, 1 warning (0.08 sec)

mysql>exit

				5.2 客户端50 连接vip地址访问集群
		host50~]# mysql -h192.168.4.100  -uyaya55  -p123qqq...A
		mysql> select  * from  db9.a;
		mysql> insert into db9.a values(100);
mysql> select  * from db9.a;
+------+
| id   |
+------+
|  100 |
+------+
1 row in set (0.00 sec)


[root@host53 ~]# mysql -uroot -p123qqq...A -e "select  * from db9.a"
mysql: [Warning] Using a password on the command line interface can be insecure.
+------+
| id   |
+------+
|  100 |
+------+
[root@host53 ~]#

[root@host52 ~]# mysql -uroot -p123qqq...A -e "select  * from db9.a"
mysql: [Warning] Using a password on the command line interface can be insecure.
+------+
| id   |
+------+
|  100 |
+------+
[root@host53 ~]#


			5 测试高可用
			   5.1 停止主服务器51的mysql服务
   				    host51]# systemctl  stop  mysqld



查看管理服务状态
[root@host57 ~]# masterha_manager --conf=/etc/mha/app1.cnf  --remove_dead_master_conf \
> --ignore_last_failover
Thu Jun 20 17:05:58 2019 - [warning] Global configuration file /etc/masterha_default.cnf not found. Skipping.
Thu Jun 20 17:05:58 2019 - [info] Reading application default configuration from /etc/mha/app1.cnf..
Thu Jun 20 17:05:58 2019 - [info] Reading server configuration from /etc/mha/app1.cnf..


  Creating /var/tmp if not exists..    ok.
  Checking output directory is accessible or not..
   ok.
  Binlog found at /var/lib/mysql, up to master51.000002
Thu Jun 20 17:35:59 2019 - [warning] Global configuration file /etc/masterha_default.cnf not found. Skipping.
Thu Jun 20 17:35:59 2019 - [info] Reading application default configuration from /etc/mha/app1.cnf..
Thu Jun 20 17:35:59 2019 - [info] Reading server configuration from /etc/mha/app1.cnf..
[root@host57 ~]#

[root@host57 ~]# masterha_check_status  --conf=/etc/mha/app1.cnf
app1 is stopped(2:NOT_RUNNING).
[root@host57 ~]#

			   5.2 客户端依然连接vip地址，可以访问到数据
				client50]# ping -c 2 192.168.4.100
				client50]# mysql -h192.168.4.100 -uyaya55 -p123qqq...A
				mysql> insert into db9.a values(200);
				mysql> select  * from db9.a;

[root@host50 ~]# mysql -h192.168.4.100 -uyaya55  -p123qqq...A
mysql: [Warning] Using a password on the command line interface can be insecure.
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 21
Server version: 5.7.17-log MySQL Community Server (GPL)

Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql> select  * from db9.a;
+------+
| id   |
+------+
|  100 |
+------+
1 row in set (0.00 sec)

mysql> insert into db9.a values(200);
Query OK, 1 row affected (0.12 sec)

mysql> select  * from db9.a;
+------+
| id   |
+------+
|  100 |
|  200 |
+------+
2 rows in set (0.00 sec)

mysql>



查看53主机
[root@host53 ~]# ifconfig  eth0:1
eth0:1: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        ether 52:54:00:28:22:2e  txqueuelen 1000  (Ethernet)

[root@host53 ~]# mysql -uroot -p123qqq...A -e "show slave status\G" | grep -i 192
mysql: [Warning] Using a password on the command line interface can be insecure.
                  Master_Host: 192.168.4.52
[root@host53 ~]#
[root@host53 ~]# mysql -uroot -p123qqq...A -e "show slave status\G" | grep -i yes
mysql: [Warning] Using a password on the command line interface can be insecure.
             Slave_IO_Running: Yes
            Slave_SQL_Running: Yes
[root@host53 ~]#
[root@host53 ~]# mysql -uroot -p123qqq...A -e "select  * from db9.a"
mysql: [Warning] Using a password on the command line interface can be insecure.
+------+
| id   |
+------+
|  100 |
|  200 |
+------+


[root@host52 ~]# ifconfig  eth0:1
eth0:1: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.4.100  netmask 255.255.255.0  broadcast 192.168.4.255
        ether 52:54:00:f5:c4:6a  txqueuelen 1000  (Ethernet)


启动 51～53 主机上的数据库服务器
查看管理主机57的app1.cnf文件内容
检查从服务器的状态信息
查看主服务器的vip地址和binlog日志
在管理主机57 , 测试ssh  和 主从同步  ，并启动管理服务 ，查看服务状态


		在宕机的数据库服务器51 添加到集群里？
			1 启动51主机的数据库服务
			2 把51主机配置为当前集群主机的从服务器
			   2.1 与主服务器数据一致
[root@host52 ~]#
[root@host52 ~]#  mysqldump -uroot -p123qqq...A  --master-data  db9 > db9.sql
mysqldump: [Warning] Using a password on the command line interface can be insecure.
[root@host52 ~]#
[root@host52 ~]# scp db9.sql  root@192.168.4.51:/root/
db9.sql                                                  100% 1918     3.1MB/s   00:00
[root@host52 ~]#
			   2.2 指定主服务器信息，启动slave 进程 、查看状态

ot@host51 ~]# mysql -uroot -p123qqq...A db9 < /root/db9.sql
mysql: [Warning] Using a password on the command line interface can be insecure.

[root@host51 ~]# mysql -uroot -p123qqq...A -e "select  * from db9.a"
mysql: [Warning] Using a password on the command line interface can be insecure.
+------+
| id   |
+------+
|  100 |
|  200 |
|  300 |
|  400 |
+------+

[root@host51 ~]# grep master52 /root/db9.sql
CHANGE MASTER TO MASTER_LOG_FILE='master52.000001', MASTER_LOG_POS=895;

[root@host51 ~]# mysql -uroot -p123qqq...A
mysql> change master to master_host="192.168.4.52",master_user="repluser",master_password="123qqq...A",master_log_file="master52.000001",master_log_pos=895;
Query OK, 0 rows affected, 2 warnings (0.14 sec)

mysql> start slave;
Query OK, 0 rows affected (0.01 sec)

mysql> exit

[root@host51 ~]# mysql -uroot -p123qqq...A -e "show slave status\G" |grep 192.168.4.52
mysql: [Warning] Using a password on the command line interface can be insecure.
                  Master_Host: 192.168.4.52

[root@host51 ~]#
[root@host51 ~]# mysql -uroot -p123qqq...A -e "show slave status\G" |grep -i yes
mysql: [Warning] Using a password on the command line interface can be insecure.
             Slave_IO_Running: Yes
            Slave_SQL_Running: Yes
[root@host51 ~]#
			3 把主机51添加到集群里
				3.1 停止57主机的管理服务
					]# masterha_stop  --conf=/etc/mha/app1.cnf

				3.2 修改配置文件
					]# vim /etc/mha/app1.cnf
					   [server1 ]
					hostname=192.168.4.51
					port=3306
					candidate_master=1
					:wq

				3.3 测试配置
					]# masterha_check_ssh  --conf=/etc/mha/app1.cnf
					]# masterha_check_repl  --conf=/etc/mha/app1.cnf
				3.4 启动管理服务
					]# masterha_manager --conf=/etc/mha/app1.cnf   \
--remove_dead_master_conf  --ignore_last_failover

				3.5 查看服务状态
					]# masterha_check_status --conf=/etc/mha/app1.cnf
			练习+休息到  10：20

MHA集群配置总结：
必须配置ssh无密码登陆
必须配置主从同步结构
必须vip地址
宕机的服务器要手动配置为集群的从服务器 才能添加到集群
宕机的服务器无法自动同步宕机期间的数据
当主从同步结构中 没有从服务器时无法实现故障切换

++++++++++++++++++RDBMS2_DAY05
一、PXC
	1.1 相关概念
	    数据库高可用
	    优点 :
	        数据强一致性,无同步延迟
	        没有主从切换 无需使用虚拟ip
	        支持 innodb存储引擎
	        多线程复制
	        部署使用简单
	        支持节点自动加入 无需手动拷贝数据
	1.2 部署PXC集群
	1.3 准备集群环境 (3台服务器之间可以通过主机名通信) 10：45
[root@pxcnode71 ~]# cat /etc/hosts
# ::1		localhost localhost.localdomain localhost6 localhost6.localdomain6
127.0.0.1	localhost localhost.localdomain localhost4 localhost4.localdomain4
192.168.4.71 pxcnode71
192.168.4.72 pxcnode72
192.168.4.73 pxcnode73
[root@pxcnode71 ~]#
[root@pxcnode71 ~]# ping -c 2 pxcnode73
PING pxcnode73 (192.168.4.73) 56(84) bytes of data.
64 bytes from pxcnode73 (192.168.4.73): icmp_seq=1 ttl=255 time=0.129 ms
64 bytes from pxcnode73 (192.168.4.73): icmp_seq=2 ttl=255 time=0.314 ms

--- pxcnode73 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1000ms
rtt min/avg/max/mdev = 0.129/0.221/0.314/0.093 ms
[root@pxcnode71 ~]#
[root@pxcnode71 ~]# ping -c 2 pxcnode72
PING pxcnode72 (192.168.4.72) 56(84) bytes of data.
64 bytes from pxcnode72 (192.168.4.72): icmp_seq=1 ttl=255 time=0.188 ms
64 bytes from pxcnode72 (192.168.4.72): icmp_seq=2 ttl=255 time=0.314 ms

--- pxcnode72 ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 999ms
rtt min/avg/max/mdev = 0.188/0.251/0.314/0.063 ms
[root@pxcnode71 ~]#


				测试集群

72]#mysql>  添加授权用户
mysql> grant all on  gamedb.*  to yaya@"%" identified by "123456";
Query OK, 0 rows affected, 1 warning (0.18 sec)

mysql> select  * from gamedb.a;

50客户端连接集群存取数据
50]# mysql -h192.168.4.73 -uyaya -p123456
mysql>
mysql> create database gamedb;
Query OK, 1 row affected (0.19 sec)

mysql>  create table  gamedb.a(id int primary key auto_increment,name char(10));
Query OK, 0 rows affected (1.02 sec)

mysql> insert into gamedb.a(name)values("bob"),("tom");
mysql> insert into gamedb.a(name)values("bob2"),("tom2");
mysql> insert into gamedb.a(name)values("jerry"),("jack");
Query OK, 2 rows affected (0.20 sec)
Records: 2  Duplicates: 0  Warnings: 0

mysql> select  * from  gamedb.a;
mysql> select  * from  gamedb.a;
+----+-------+
| id | name  |
+----+-------+
|  2 | bob   |
|  5 | tom   |
|  8 | bob2  |
| 11 | tom2  |
| 14 | jerry |
| 17 | jack  |
+----+-------+
6 rows in set (0.00 sec)

在另外2台数据库服务器查看数据

[root@pxcnode71 ~]# mysql -uroot -p123456 -e "select  * from gamedb.a"
mysql: [Warning] Using a password on the command line interface can be insecure.
+----+-------+
| id | name  |
+----+-------+
|  2 | bob   |
|  5 | tom   |
|  8 | bob2  |
| 11 | tom2  |
| 14 | jerry |
| 17 | jack  |
+----+-------+
[root@pxcnode71 ~]#


[root@pxcnode73 ~]# mysql -uroot -p123456 -e "select  * from gamedb.a"
mysql: [Warning] Using a password on the command line interface can be insecure.
+----+-------+
| id | name  |
+----+-------+
|  2 | bob   |
|  5 | tom   |
|  8 | bob2  |
| 11 | tom2  |
| 14 | jerry |
| 17 | jack  |
+----+-------+
[root@pxcnode71 ~]#


二、MySQL存储引擎 192.168.4.50
	2.1 存储引擎介绍?

	2.2 查看数据库服务器可以使用的存储引擎 mysql> show  engines;

	2.3 修改数据库服务使用的存储引擎
		]# vim /etc/my.cnf
		[mysqld]
		default-storage-engine=myisam
		:wq
		]# systemctl  restart mysqld
		]# mysql -uroot -p123456 -e "show engines"




	2.4 修改表的存储引擎
		mysql> create database db10
		mysql> create table db10.a3(name char(10))engine=memory;
		mysql> show create table db10.a3\G;
		mysql> alter table  db10.a3 engine=myisam;

建表时指定存储引擎
mysql> use db10
mysql> create table  a1(id int)；

mysql> create table  a2(name char(10))engine=myisam ;
mysql> show create table a2\G;

	2.5 常用存储引擎的特点
		1 myisam 特点

		2 innodb 特点

	2.6 建表时如何决定表使用那种存储引擎
		查询操作多的表，适合使用myisam存储引擎，节省硬件资源。
			表级锁
PC1		select * from a1;或 select  * from a1  where  id<=3;
		读锁（共享锁）
PC2


		写操作多的表，适合使用Innodb存储引擎，并发访问量大。
			行级锁：只给访问的行分别加锁。

	pc1  update a1 set age=19 where id<=3;
		innodb			1 2 3

	pc2 update  a1 set age=21 where id>3;


RDBMS2 课程内容总结
DAY01  mysql主从同步（主从概念 工作过程 结构类型 复制模式）
DAY02  数据读写分离（概念 软件 配置maxscale  测试）  mysql多实例 1台
DAY03  数据分片 （概念  软件 工作过程 配置mycat  测试）
DAY04  MHA集群 (概念 软件  工作过程  配置管理主机 配置数据库服务器 测试配置 启动服务 测试集群)
DAY05  PXC 存储引擎

+++++++++++++++++++++++++NoSQL_DAY01
一、部署Redis服务
	1.1 相关概念
	1.2 Redis介绍
	    高性能分布式内存数据库
	    支持数据持久化
	    支持多种数据内心
	    支持master/slave 模式
	1.3 搭建redid服务器 192.168.4.50
		1 安装源码redis软件
		2 服务初始化配置
		3 查看服务状态
		4 停止/启动服务脚本
		5 连接redis服务存取数据

	1.4 常用命令 192.168.4.50

[root@host50 redis-4.0.8]# redis-cli
127.0.0.1:6379>
127.0.0.1:6379> keys *
1) "school"
127.0.0.1:6379>
127.0.0.1:6379> type school
string
127.0.0.1:6379>
127.0.0.1:6379> mset x 100 y 200  z 99
OK
127.0.0.1:6379> type x
string
127.0.0.1:6379> type y
string
127.0.0.1:6379> type z
string
127.0.0.1:6379>

127.0.0.1:6379> get x y
(error) ERR wrong number of arguments for 'get' command
127.0.0.1:6379>
127.0.0.1:6379> mget x y
1) "100"
2) "200"
127.0.0.1:6379>

127.0.0.1:6379> select 1
OK
127.0.0.1:6379[1]> select 0
OK
127.0.0.1:6379> select 16
(error) ERR DB index is out of range
127.0.0.1:6379>


127.0.0.1:6379> keys *
1) "z"
2) "school"
3) "y"
4) "x"
127.0.0.1:6379>  keys ?
1) "z"
2) "y"
3) "x"
127.0.0.1:6379>
127.0.0.1:6379>  keys ??
(empty list or set)
127.0.0.1:6379>
127.0.0.1:6379>  keys a?
(empty list or set)
127.0.0.1:6379>

127.0.0.1:6379> EXISTS name
(integer) 0
127.0.0.1:6379> EXISTS school
(integer) 1
127.0.0.1:6379>

127.0.0.1:6379> set name bob
OK
127.0.0.1:6379> ttl name
(integer) -1
127.0.0.1:6379> EXPIRE name 10
(integer) 1
127.0.0.1:6379> ttl name
(integer) 6

127.0.0.1:6379> ttl name
(integer) -2
127.0.0.1:6379

127.0.0.1:6379> keys *
1) "z"
2) "school"
3) "y"
4) "x"
127.0.0.1:6379> move y 1
(integer) 1
127.0.0.1:6379> keys *
1) "z"
2) "school"
3) "x"
127.0.0.1:6379> select 1
OK
127.0.0.1:6379[1]> keys *
1) "y"
127.0.0.1:6379[1]>

127.0.0.1:6379[1]> keys *
1) "y"
127.0.0.1:6379[1]> del y
(integer) 1
127.0.0.1:6379[1]> keys *
(empty list or set)
127.0.0.1:6379[1]>

127.0.0.1:6379[1]> keys *
1) "y"
127.0.0.1:6379[1]> del y
(integer) 1
127.0.0.1:6379[1]> keys *
(empty list or set)
127.0.0.1:6379[1]> select  0
OK
127.0.0.1:6379> keys *
1) "z"
2) "school"
3) "x"
127.0.0.1:6379> flushdb
OK
127.0.0.1:6379> keys *
(empty list or set)
127.0.0.1:6379>
127.0.0.1:6379> flushall
OK
127.0.0.1:6379>
127.0.0.1:6379> keys *
(empty list or set)
127.0.0.1:6379> save
OK
127.0.0.1:6379> shutdown
not connected> exit
[root@host50 redis-4.0.8]#
not connected> exit
[root@host50 redis-4.0.8]# netstat -utnlp  | grep  :6379
[root@host50 redis-4.0.8]#
[root@host50 redis-4.0.8]# ls /var/lib/redis/6379/
dump.rdb
[root@host50 redis-4.0.8]# /etc/init.d/redis_6379  start
Starting Redis server...
[root@host50 redis-4.0.8]# redis-cli
127.0.0.1:6379> keys *
(empty list or set)
127.0.0.1:6379>



























































二、部署LNMP+Redis


]# scp redis-4.0.8.tar.gz  root@192.168.4.50:/root/
]# scp redis-4.0.8.tar.gz  root@192.168.4.51:/root/
]# scp -r lnmp  root@192.168.4.50:/root/

		1.4 配置文件解析 /etc/redis/6379.conf



[root@host50 redis-4.0.8]# /etc/init.d/redis_6379 stop
Stopping ...
Redis stopped
[root@host50 redis-4.0.8]# /etc/init.d/redis_6379 start
Starting Redis server...
[root@host50 redis-4.0.8]# netstat -utnlp  | grep :6379
tcp        0      0 127.0.0.1:6379          0.0.0.0:*               LISTEN      4267/redis-server 1
[root@host50 redis-4.0.8]#
[root@host50 redis-4.0.8]# redis-cli
127.0.0.1:6379> keys *
(error) NOAUTH Authentication required.
127.0.0.1:6379>
127.0.0.1:6379> set y 91
(error) NOAUTH Authentication required.
127.0.0.1:6379>
127.0.0.1:6379> auth 123456\
(error) ERR invalid password
127.0.0.1:6379> auth 123456
OK
127.0.0.1:6379> set y 91
OK
127.0.0.1:6379> keys *
1) "x"
2) "y"
127.0.0.1:6379> exit
[root@host50 redis-4.0.8]#

ot@host50 ~]# /etc/init.d/redis_6379 stop
Stopping ...
(error) NOAUTH Authentication required.
Waiting for Redis to shutdown ...
Waiting for Redis to shutdown ...
Waiting for Redis to shutdown ...
Waiting for Redis to shutdown ...

[root@host50 ~]# netstat -utnlp  | grep  :6379
tcp        0      0 127.0.0.1:6379          0.0.0.0:*               LISTEN      4267/redis-server 1
[root@host50 ~]#


[root@host50 ~]# redis-cli   -a 123456  shutdown
[root@host50 ~]# netstat -utnlp  | grep  :6379
[root@host50 ~]#

		修改服务的ip地址和端口号        练习到14：20
[root@host50 ~]# vim  /etc/redis/6379.conf
70 bind 192.168.4.50
93 port 6350
		:wq
[root@host50 ~]# /etc/init.d/redis_6379 start
Starting Redis server...
[root@host50 ~]#
[root@host50 ~]# netstat -utnlp  | grep  :6350
tcp     0      0 192.168.4.50:6350       0.0.0.0:*    LISTEN      4403/redis-server 1

[root@host50 ~]# redis-cli
Could not connect to Redis at 127.0.0.1:6379: Connection refused
Could not connect to Redis at 127.0.0.1:6379: Connection refused
not connected> exit

[root@host50 ~]# redis-cli  -h 192.168.4.50 -p 6350 -a 123456
192.168.4.50:6350> ping
PONG
192.168.4.50:6350> keys *
1) "x"
2) "y"
192.168.4.50:6350> exit


ot@host50 ~]#
[root@host50 ~]# /etc/init.d/redis_6379  stop
Stopping ...
Could not connect to Redis at 127.0.0.1:6379: Connection refused
Waiting for Redis to shutdown ...
Waiting for Redis to shutdown ...
Waiting for Redis to shutdown ...
^C
[root@host50 ~]# redis-cli  -h 192.168.4.50 -p 6350 -a 123456 shutdown
[root@host50 ~]#
[root@host50 ~]# /etc/init.d/redis_6379  start
Starting Redis server...
[root@host50 ~]#
[root@host50 ~]# netstat  -utnlp  | grep  :6350
tcp        0      0 192.168.4.50:6350       0.0.0.0:*               LISTEN      4424/redis-server 1
[root@host50 ~]#

		修改脚本代码，可以使用脚本停止服务    （练习到 14：33）
[root@host50 ~]# vim +43 /etc/init.d/redis_6379

    $CLIEXEC -h 192.168.4.50 -p 6350 -a 123456  shutdown

:wq

[root@host50 ~]# /etc/init.d/redis_6379  stop
Stopping ...
Redis stopped
[root@host50 ~]# netstat  -utnlp  | grep  :6350
[root@host50 ~]#

二、部署LNMP+Redis
	]# scp  -r  lnmp root@192.168.4.71:/root/
	2.1 部署LNMP （192.168.4.71）
		1 安装源码nginx软件包
[root@localhost lnmp]# rpm -q gcc
未安装软件包 gcc
[root@localhost lnmp]# rpm -q pcre-devel
pcre-devel-8.32-17.el7.x86_64
[root@localhost lnmp]# rpm -q zlib-devel
zlib-devel-1.2.7-17.el7.x86_64
[root@localhost lnmp]#
[root@localhost lnmp]# yum -y  install gcc


checking for zlib library ... found
creating objs/Makefile

Configuration summary
  + using system PCRE library
  + OpenSSL library is not used
  + using system zlib library

  nginx path prefix: "/usr/local/nginx"
  nginx binary file: "/usr/local/nginx/sbin/nginx"
  nginx modules path: "/usr/local/nginx/modules"
  nginx configuration prefix: "/usr/local/nginx/conf"
  nginx configuration file: "/usr/local/nginx/conf/nginx.conf"
  nginx pid file: "/usr/local/nginx/logs/nginx.pid"
  nginx error log file: "/usr/local/nginx/logs/error.log"
  nginx http access log file: "/usr/local/nginx/logs/access.log"
  nginx http client request body temporary files: "client_body_temp"
  nginx http proxy temporary files: "proxy_temp"
  nginx http fastcgi temporary files: "fastcgi_temp"
  nginx http uwsgi temporary files: "uwsgi_temp"
  nginx http scgi temporary files: "scgi_temp"

[root@localhost nginx-1.12.2]#
objs/src/http/modules/ngx_http_upstream_zone_module.o \
objs/ngx_modules.o \
-ldl -lpthread -lcrypt -lpcre -lz \
-Wl,-E
sed -e "s|%%PREFIX%%|/usr/local/nginx|" \
	-e "s|%%PID_PATH%%|/usr/local/nginx/logs/nginx.pid|" \
	-e "s|%%CONF_PATH%%|/usr/local/nginx/conf/nginx.conf|" \
	-e "s|%%ERROR_LOG_PATH%%|/usr/local/nginx/logs/error.log|" \
	< man/nginx.8 > objs/nginx.8
make[1]: 离开目录“/root/lnmp/nginx-1.12.2”
[root@localhost nginx-1.12.2]#

test -d '/usr/local/nginx/logs' \
	|| mkdir -p '/usr/local/nginx/logs'
test -d '/usr/local/nginx/html' \
	|| cp -R html '/usr/local/nginx'
test -d '/usr/local/nginx/logs' \
	|| mkdir -p '/usr/local/nginx/logs'
make[1]: 离开目录“/root/lnmp/nginx-1.12.2”
[root@localhost nginx-1.12.2]#
[root@localhost nginx-1.12.2]# ls /usr/local/
bin  etc  games  include  lib  lib64  libexec  nginx  sbin  share  src
[root@localhost nginx-1.12.2]#
[root@localhost nginx-1.12.2]#
[root@localhost nginx-1.12.2]# ls /usr/local/nginx/
conf  html  logs  sbin
[root@localhost nginx-1.12.2]#
		2 安装php-fpm
]# yum list  | grep  -i php-fpm

]# cd /root
]# yum -y  install  php-fpm
已安装:
  php-fpm.x86_64 0:5.4.16-45.el7

作为依赖被安装:
  libzip.x86_64 0:0.10.1-8.el7              php-common.x86_64 0:5.4.16-45.el7

完毕！
[root@localhost ~]#

		3 修改nginx服务配置文件
[root@localhost ~]# vim  +65 /usr/local/nginx/conf/nginx.conf

       location ~ \.php$ {
            root           html;
            fastcgi_pass   127.0.0.1:9000;
            fastcgi_index  index.php;
        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
           include        fastcgi.conf;
        }
:wq
		4 启动nginx服务
[root@localhost ~]# /usr/local/nginx/sbin/nginx  -t
nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok
nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful

[root@localhost ~]#
[root@localhost ~]# /usr/local/nginx/sbin/nginx
[root@localhost ~]#
[root@localhost ~]# netstat -utnlp  | grep  :80
tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      6489/nginx: master

		5 启动php-fpm服务
[root@localhost ~]# systemctl  start php-fpm
[root@localhost ~]#
[root@localhost ~]# netstat -utnlp  | grep  :9000
tcp        0      0 127.0.0.1:9000          0.0.0.0:*               LISTEN      6499/php-fpm: maste
[root@localhost ~]#
		6 编写php网页文件，测试配置 练习到 16：00

[root@localhost ~]# vim /usr/local/nginx/html/test.php
<?php
	echo  "hello  boy!!!";
?>
:wq

[root@localhost ~]# ls /usr/local/nginx/html/
50x.html  index.html  test.php

[root@localhost ~]#
[root@localhost ~]# curl  http://localhost/test.php
hello boy!!!


	2.2 配置PHP支持Redis

[root@host71 ~]# rpm -q php php-devel
未安装软件包 php
未安装软件包 php-devel
[root@host71 ~]#
[root@host71 ~]# rpm -q automake autoconf
未安装软件包 automack
未安装软件包 autoconf
[root@host71 ~]#
[root@host71 ~]# yum -y  install php php-devel automake autoconf


[root@host71 ~]# rpm -q automake
automake-1.13.4-3.el7.noarch
[root@host71 ~]#
[root@host71 ~]# rpm -q autoconf
autoconf-2.69-11.el7.noarch
[root@host71 ~]#
[root@host71 ~]# rpm -q php
php-5.4.16-45.el7.x86_64
[root@host71 ~]# rpm -q php-devel
php-devel-5.4.16-45.el7.x86_64
[root@host71 ~]#

	2.3 测试配置



[root@host71 phpredis-2.2.4]# phpize
Configuring for:
PHP Api Version:         20100412
Zend Module Api No:      20100525
Zend Extension Api No:   220100525


[root@host71 phpredis-2.2.4]# vim  /etc/php.ini
728 extension_dir = "/usr/lib64/php/modules/"
730 extension = "redis.so"
[root@host71 phpredis-2.2.4]#

[root@host71 phpredis-2.2.4]# systemctl  restart php-fpm
[root@host71 phpredis-2.2.4]#
[root@host71 phpredis-2.2.4]# php -m  | grep  -i redis
redis
[root@host71 phpredis-2.2.4]#

]# cd lnmp/					休息到17：33
]# cp linkredis.php  /usr/local/nginx/html/
]# vim  /usr/local/nginx/html/linkredis.php
<?php
$redis = new redis();
$redis->connect("192.168.4.50","6350");
$redis->auth("123456");
$redis->set("linux","redhat");
echo $redis->get("linux");
?>
:wq
[root@host71 lnmp]# curl  http://localhost/linkredis.php
redhat

[root@host50 ~]# redis-cli  -h 192.168.4.50 -p 6350 -a 123456
192.168.4.50:6350> keys *
1) "y"
2) "x"
192.168.4.50:6350> keys *
1) "y"
2) "x"
3) "linux"
192.168.4.50:6350> get linux
"redhat"

++++++++++++++NoSQL_DAY02
一、创建集群

	准备环境
	部署管理主机
	104  scp  redis-3.2.1.gem  root@192.168.4.57:/root/
        105  scp  redis-4.0.8.tar.gz  root@192.168.4.57:/root/

[root@mgm57 ~]# which gem
/usr/bin/gem
[root@mgm57 ~]# ls  *.gem
redis-3.2.1.gem
[root@mgm57 ~]#
[root@mgm57 ~]# gem install redis-3.2.1.gem
Successfully installed redis-3.2.1
Parsing documentation for redis-3.2.1
Installing ri documentation for redis-3.2.1
1 gem installed
[root@mgm57 ~]#

]#mkdir  /root/bin     //创建命令检索目录
]#tar -zxvf redis-4.0.8.tar.gz
]#cd  redis-4.0.8/src/
]#cp  redis-trib.rb   /root/bin/ //创建管理集群脚本
]#chmod  +x   /root/bin/redis-trib.rb
]#redis-trib.rb   help  //查看命令帮助


清空数据
[root@host51 ~]# /etc/init.d/redis_6379  stop
Stopping ...
Waiting for Redis to shutdown ...
Redis stopped
[root@host51 ~]# rm -rf /var/lib/redis/6379/*
[root@host51 ~]#
[root@host51 ~]# /etc/init.d/redis_6379  start
Starting Redis server...
[root@host51 ~]#

启用集群

[root@host51 ~]# vim /etc/redis/6379.conf
    cluster-enabled  yes        	             //启用集群
    cluster-config-file  nodes-xxxx.conf      //存储集群信息文件
    cluster-node-timeout  5000                  //连接超时时间单位毫秒

[root@host51 ~]# /etc/init.d/redis_6379  stop
Stopping ...
Redis stopped
[root@host51 ~]# /etc/init.d/redis_6379  start
Starting Redis server...
[root@host51 ~]#
[root@host51 ~]# netstat -utnlp  | grep  redis-server
tcp        0      0 192.168.4.51:16351      0.0.0.0:*               LISTEN      29726/redis-server
tcp        0      0 192.168.4.51:6351       0.0.0.0:*               LISTEN      29726/redis-server
[root@host51 ~]#
[root@host51 ~]# ls /var/lib/redis/6379/
dump.rdb  nodes-6351.conf
[root@host51 ~]#


[root@mgm57 ~]# redis-trib.rb create  --replicas 1 \
> 192.168.4.51:6351  192.168.4.52:6352  192.168.4.53:6353 \
> 192.168.4.54:6354  192.168.4.55:6355  192.168.4.56:6356
>>> Creating cluster
>>> Performing hash slots allocation on 6 nodes...
Using 3 masters:
192.168.4.51:6351
192.168.4.52:6352
192.168.4.53:6353
Adding replica 192.168.4.55:6355 to 192.168.4.51:6351
Adding replica 192.168.4.56:6356 to 192.168.4.52:6352
Adding replica 192.168.4.54:6354 to 192.168.4.53:6353
M: d9f8fe6d6d9dd391be8e7904501db1535e4d17cb 192.168.4.51:6351
   slots:0-5460 (5461 slots) master
M: 324e05df3f143ef97e50d09be0328a695e655986 192.168.4.52:6352
   slots:5461-10922 (5462 slots) master
M: 9e44139cffb8ebd7ed746aabbf4bcea9bf207645 192.168.4.53:6353
   slots:10923-16383 (5461 slots) master
S: d9634ba0aa5c1a07193da4a013da6051c1515922 192.168.4.54:6354
   replicates 9e44139cffb8ebd7ed746aabbf4bcea9bf207645
S: 2d343a9df48f6f6e207949e980ef498466a44dad 192.168.4.55:6355
   replicates d9f8fe6d6d9dd391be8e7904501db1535e4d17cb
S: 894dd0008053f6fb65e9e4a36b755d9351607500 192.168.4.56:6356
   replicates 324e05df3f143ef97e50d09be0328a695e655986
Can I set the above configuration? (type 'yes' to accept): yes
>>> Nodes configuration updated
>>> Assign a different config epoch to each node
>>> Sending CLUSTER MEET messages to join the cluster
Waiting for the cluster to join...
>>> Performing Cluster Check (using node 192.168.4.51:6351)
M: d9f8fe6d6d9dd391be8e7904501db1535e4d17cb 192.168.4.51:6351
   slots:0-5460 (5461 slots) master
   1 additional replica(s)
S: d9634ba0aa5c1a07193da4a013da6051c1515922 192.168.4.54:6354
   slots: (0 slots) slave
   replicates 9e44139cffb8ebd7ed746aabbf4bcea9bf207645
S: 894dd0008053f6fb65e9e4a36b755d9351607500 192.168.4.56:6356
   slots: (0 slots) slave
   replicates 324e05df3f143ef97e50d09be0328a695e655986
M: 324e05df3f143ef97e50d09be0328a695e655986 192.168.4.52:6352
   slots:5461-10922 (5462 slots) master
   1 additional replica(s)
M: 9e44139cffb8ebd7ed746aabbf4bcea9bf207645 192.168.4.53:6353
   slots:10923-16383 (5461 slots) master
   1 additional replica(s)
S: 2d343a9df48f6f6e207949e980ef498466a44dad 192.168.4.55:6355
   slots: (0 slots) slave
   replicates d9f8fe6d6d9dd391be8e7904501db1535e4d17cb
[OK] All nodes agree about slots configuration.
>>> Check for open slots...
>>> Check slots coverage...
[OK] All 16384 slots covered.
[root@mgm57 ~]#









]# /etc/init.d/redis_6379 stop
]# rm -rf /var/lib/redis/6379/*
]# /etc/init.d/redis_6379 start
]# redis-cli  -h 192.168.4.51  -p 6351
>keys *
>exit
]# netstat -utnlp  | grep  :6351
]# netstat -utnlp  | grep  :16351

二、管理集群
	2.1 在管理主机查看集群信息
[root@mgm57 ~]# redis-trib.rb info 192.168.4.51:6351
192.168.4.51:6351 (d9f8fe6d...) -> 0 keys | 5461 slots | 1 slaves.
192.168.4.52:6352 (324e05df...) -> 0 keys | 5462 slots | 1 slaves.
192.168.4.53:6353 (9e44139c...) -> 0 keys | 5461 slots | 1 slaves.
[OK] 0 keys in 3 masters.
0.00 keys per slot on average.

	2.2 在管理主机检测集群
[root@mgm57 ~]# redis-trib.rb check 192.168.4.51:6351
>>> Performing Cluster Check (using node 192.168.4.51:6351)
M: d9f8fe6d6d9dd391be8e7904501db1535e4d17cb 192.168.4.51:6351
   slots:0-5460 (5461 slots) master
   1 additional replica(s)
S: d9634ba0aa5c1a07193da4a013da6051c1515922 192.168.4.54:6354
   slots: (0 slots) slave
   replicates 9e44139cffb8ebd7ed746aabbf4bcea9bf207645
S: 894dd0008053f6fb65e9e4a36b755d9351607500 192.168.4.56:6356
   slots: (0 slots) slave
   replicates 324e05df3f143ef97e50d09be0328a695e655986
M: 324e05df3f143ef97e50d09be0328a695e655986 192.168.4.52:6352
   slots:5461-10922 (5462 slots) master
   1 additional replica(s)
M: 9e44139cffb8ebd7ed746aabbf4bcea9bf207645 192.168.4.53:6353
   slots:10923-16383 (5461 slots) master
   1 additional replica(s)
S: 2d343a9df48f6f6e207949e980ef498466a44dad 192.168.4.55:6355
   slots: (0 slots) slave
   replicates d9f8fe6d6d9dd391be8e7904501db1535e4d17cb
[OK] All nodes agree about slots configuration.
>>> Check for open slots...
>>> Check slots coverage...
[OK] All 16384 slots covered.
[root@mgm57 ~]#

	2. 在redis服务器本机查看集群信息
[root@host51 ~]# redis-cli  -h 192.168.4.51 -p 6351
192.168.4.51:6351> cluster info
cluster_state:ok
cluster_slots_assigned:16384
cluster_slots_ok:16384
cluster_slots_pfail:0
cluster_slots_fail:0
cluster_known_nodes:6
cluster_size:3
cluster_current_epoch:6
cluster_my_epoch:1
cluster_stats_messages_ping_sent:25763
cluster_stats_messages_pong_sent:21605
cluster_stats_messages_sent:47368
cluster_stats_messages_ping_received:21600
cluster_stats_messages_pong_received:25763
cluster_stats_messages_meet_received:5
cluster_stats_messages_received:47368
192.168.4.51:6351>
192.168.4.51:6351> cluster nodes
d9634ba0aa5c1a07193da4a013da6051c1515922 192.168.4.54:6354@16354 slave 9e44139cffb8ebd7ed746aabbf4bcea9bf207645 0 1561357552212 4 connected
894dd0008053f6fb65e9e4a36b755d9351607500 192.168.4.56:6356@16356 slave 324e05df3f143ef97e50d09be0328a695e655986 0 1561357554216 6 connected
d9f8fe6d6d9dd391be8e7904501db1535e4d17cb 192.168.4.51:6351@16351 myself,master - 0 1561357545000 1 connected 0-5460
324e05df3f143ef97e50d09be0328a695e655986 192.168.4.52:6352@16352 master - 0 1561357553214 2 connected 5461-10922
9e44139cffb8ebd7ed746aabbf4bcea9bf207645 192.168.4.53:6353@16353 master - 0 1561357554216 3 connected 10923-16383
2d343a9df48f6f6e207949e980ef498466a44dad 192.168.4.55:6355@16355 slave d9f8fe6d6d9dd391be8e7904501db1535e4d17cb 0 1561357553716 5 connected
192.168.4.51:6351>


客户端访问集群存 取数据

[root@host50 ~]# redis-cli  -c  -h 192.168.4.51 -p 6351
192.168.4.51:6351>
192.168.4.51:6351> set x 100
-> Redirected to slot [16287] located at 192.168.4.53:6353
OK
192.168.4.53:6353> keys *
1) "x"
192.168.4.53:6353>
192.168.4.53:6353> set y 200
OK
192.168.4.53:6353> keys *
1) "y"
2) "x"
192.168.4.53:6353> set z 300
-> Redirected to slot [8157] located at 192.168.4.52:6352
OK
192.168.4.52:6352> keys *
1) "z"
192.168.4.52:6352> get x
-> Redirected to slot [16287] located at 192.168.4.53:6353
"100"
192.168.4.53:6353> keys *
1) "y"
2) "x"
192.168.4.53:6353> get z
-> Redirected to slot [8157] located at 192.168.4.52:6352
"300"
192.168.4.52:6352> set i 400
-> Redirected to slot [15759] located at 192.168.4.53:6353
OK
192.168.4.53:6353> set j 500
-> Redirected to slot [3564] located at 192.168.4.51:6351
OK
192.168.4.51:6351> exit


	2.4 客户端连接从服务器，查看数据是否同步
[root@host50 ~]# redis-cli  -c  -h 192.168.4.54 -p 6354
192.168.4.54:6354> keys *
1) "i"
2) "y"
3) "x"
192.168.4.54:6354> exit
[root@host50 ~]#
[root@host50 ~]# redis-cli  -c  -h 192.168.4.55 -p 6355
192.168.4.55:6355> keys *
1) "j"
192.168.4.55:6355> exit
[root@host50 ~]#
[root@host50 ~]# redis-cli  -c  -h 192.168.4.56 -p 6356
192.168.4.56:6356> keys *
1) "z"
192.168.4.56:6356> exit
[root@host50 ~]#

	2.5 在管理主机 查看集群信息
[root@mgm57 ~]# redis-trib.rb info 192.168.4.53:6353
192.168.4.53:6353 (9e44139c...) -> 3 keys | 5461 slots | 1 slaves.
192.168.4.52:6352 (324e05df...) -> 1 keys | 5462 slots | 1 slaves.
192.168.4.51:6351 (d9f8fe6d...) -> 1 keys | 5461 slots | 1 slaves.
[OK] 5 keys in 3 masters.
0.00 keys per slot on average.
[root@mgm57 ~]#

	2.6 连接从服务器，查看没有的变量 也可以查看到
[root@host50 ~]# redis-cli  -c  -h 192.168.4.56 -p 6356
192.168.4.56:6356> keys *
1) "z"
192.168.4.56:6356>
192.168.4.56:6356> get x
-> Redirected to slot [16287] located at 192.168.4.53:6353
"100"
192.168.4.53:6353>


		15：10 上课
		2.6 redis集群存储数据和读取数据的工作过程
			hash slots 的总数 16384  范围 0～16383

		redis-cli -c  -h ip    -p port

		> set  age  19
		> get  age

	获取变量名 age   用算法CRC16 做计算得到  数值%16384 得到余数 1028




二、管理集群
	2.1 添加master服务器  192.168.4.58
		192.168.4.58 运行服务并启用集群配置
  211  yum -y  install gcc
  212  tar -zxvf redis-4.0.8.tar.gz
  213  cd redis-4.0.8/
  214  make
  215  make install
  216  ./utils/install_server.sh

  217  /etc/init.d/redis_6379  stop

  218  vim /etc/redis/6379.conf
	bind 192.168.4.58
	port 6358
        cluster-enabled  yes        	             //启用集群
        cluster-config-file  nodes-6358.conf      //存储集群信息文件
        cluster-node-timeout  5000
      :wq
  219  /etc/init.d/redis_6379  start
  220  netstat -utnlp  | grep redis-server
  221  vim +43 /etc/init.d/redis_6379
	 $CLIEXEC -h 192.168.4.58 -p 6358 shutdown
       :wq

	192.168.4.57 执行添加master主机
[root@mgm57 ~]# redis-trib.rb  add-node  192.168.4.58:6358  192.168.4.53:6353
>>> Adding node 192.168.4.58:6358 to cluster 192.168.4.53:6353
>>> Performing Cluster Check (using node 192.168.4.53:6353)
M: 9e44139cffb8ebd7ed746aabbf4bcea9bf207645 192.168.4.53:6353
   slots:10923-16383 (5461 slots) master
   1 additional replica(s)
S: d9634ba0aa5c1a07193da4a013da6051c1515922 192.168.4.54:6354
   slots: (0 slots) slave
   replicates 9e44139cffb8ebd7ed746aabbf4bcea9bf207645
M: 324e05df3f143ef97e50d09be0328a695e655986 192.168.4.52:6352
   slots:5461-10922 (5462 slots) master
   1 additional replica(s)
S: 894dd0008053f6fb65e9e4a36b755d9351607500 192.168.4.56:6356
   slots: (0 slots) slave
   replicates 324e05df3f143ef97e50d09be0328a695e655986
S: d9f8fe6d6d9dd391be8e7904501db1535e4d17cb 192.168.4.51:6351
   slots: (0 slots) slave
   replicates 2d343a9df48f6f6e207949e980ef498466a44dad
M: 2d343a9df48f6f6e207949e980ef498466a44dad 192.168.4.55:6355
   slots:0-5460 (5461 slots) master
   1 additional replica(s)
[OK] All nodes agree about slots configuration.
>>> Check for open slots...
>>> Check slots coverage...
[OK] All 16384 slots covered.
>>> Send CLUSTER MEET to node 192.168.4.58:6358 to make it join the cluster.
[OK] New node added correctly.
[root@mgm57 ~]#


ot@mgm57 ~]# redis-trib.rb info 192.168.4.53:6353
192.168.4.53:6353 (9e44139c...) -> 3 keys | 5461 slots | 1 slaves.
192.168.4.52:6352 (324e05df...) -> 2 keys | 5462 slots | 1 slaves.
192.168.4.58:6358 (4fe1fa46...) -> 0 keys | 0 slots | 0 slaves.
192.168.4.55:6355 (2d343a9d...) -> 3 keys | 5461 slots | 1 slaves.
[OK] 8 keys in 4 masters.
0.00 keys per slot on average.
[root@mgm57 ~]#
[root@mgm57 ~]# redis-trib.rb check 192.168.4.53:6353
>>> Performing Cluster Check (using node 192.168.4.53:6353)
M: 9e44139cffb8ebd7ed746aabbf4bcea9bf207645 192.168.4.53:6353
   slots:10923-16383 (5461 slots) master
   1 additional replica(s)
S: d9634ba0aa5c1a07193da4a013da6051c1515922 192.168.4.54:6354
   slots: (0 slots) slave
   replicates 9e44139cffb8ebd7ed746aabbf4bcea9bf207645
M: 324e05df3f143ef97e50d09be0328a695e655986 192.168.4.52:6352
   slots:5461-10922 (5462 slots) master
   1 additional replica(s)
S: 894dd0008053f6fb65e9e4a36b755d9351607500 192.168.4.56:6356
   slots: (0 slots) slave
   replicates 324e05df3f143ef97e50d09be0328a695e655986
M: 4fe1fa467ad237802021f5aac5f1d5b3e0db47ef 192.168.4.58:6358
   slots: (0 slots) master
   0 additional replica(s)
S: d9f8fe6d6d9dd391be8e7904501db1535e4d17cb 192.168.4.51:6351
   slots: (0 slots) slave
   replicates 2d343a9df48f6f6e207949e980ef498466a44dad
M: 2d343a9df48f6f6e207949e980ef498466a44dad 192.168.4.55:6355
   slots:0-5460 (5461 slots) master
   1 additional replica(s)
[OK] All nodes agree about slots configuration.
>>> Check for open slots...
>>> Check slots coverage...
[OK] All 16384 slots covered.
[root@mgm57 ~]#




        192.168.4.57 执行分配hash槽
ving slot 1348 from 192.168.4.55:6355 to 192.168.4.58:6358:
Moving slot 1349 from 192.168.4.55:6355 to 192.168.4.58:6358:
Moving slot 1350 from 192.168.4.55:6355 to 192.168.4.58:6358:


[root@mgm57 ~]# redis-trib.rb info 192.168.4.53:6353
192.168.4.53:6353 (9e44139c...) -> 2 keys | 4096 slots | 1 slaves.
192.168.4.52:6352 (324e05df...) -> 1 keys | 4096 slots | 1 slaves.
192.168.4.58:6358 (4fe1fa46...) -> 4 keys | 4096 slots | 0 slaves.
192.168.4.55:6355 (2d343a9d...) -> 1 keys | 4096 slots | 1 slaves.
[OK] 8 keys in 4 masters.
0.00 keys per slot on average.
[root@mgm57 ~]#

[root@mgm57 ~]# redis-trib.rb check 192.168.4.53:6353

M: 4fe1fa467ad237802021f5aac5f1d5b3e0db47ef 192.168.4.58:6358
   slots:0-1364,5461-6826,10923-12287 (4096 slots) master
   0 additional replica(s)





[root@host50 ~]# redis-cli  -c -h 192.168.4.58 -p 6358
192.168.4.58:6358> keys *
1) "age"
2) "name2"
3) "y"
4) "name"
192.168.4.58:6358> set shcool tarena
-> Redirected to slot [5095] located at 192.168.4.55:6355
OK
192.168.4.55:6355>
192.168.4.55:6355> set shcool2 tarena
-> Redirected to slot [7047] located at 192.168.4.52:6352
OK
192.168.4.52:6352> set shcool3 tarena
-> Redirected to slot [2982] located at 192.168.4.55:6355
OK
192.168.4.55:6355> set shcool4 tarena
-> Redirected to slot [15169] located at 192.168.4.53:6353
OK
192.168.4.53:6353> set shcool5 tarena
-> Redirected to slot [11104] located at 192.168.4.58:6358
OK
192.168.4.58:6358>

		添加slave服务器	 192.168.4.59
		    192.168.4.59 运行服务并启用集群配置

		    192.168.4.59 执行添加slave服务器
           ]#redis-trib.rb  add-node  --slave  192.168.4.59:6359 192.168.4.51:6351
>>> Adding node 192.168.4.59:6359 to cluster 192.168.4.51:6351
>>> Performing Cluster Check (using node 192.168.4.51:6351)
S: d9f8fe6d6d9dd391be8e7904501db1535e4d17cb 192.168.4.51:6351
   slots: (0 slots) slave
   replicates 2d343a9df48f6f6e207949e980ef498466a44dad
S: 894dd0008053f6fb65e9e4a36b755d9351607500 192.168.4.56:6356
   slots: (0 slots) slave
   replicates 324e05df3f143ef97e50d09be0328a695e655986
M: 2d343a9df48f6f6e207949e980ef498466a44dad 192.168.4.55:6355
   slots:1365-5460 (4096 slots) master
   1 additional replica(s)
M: 9e44139cffb8ebd7ed746aabbf4bcea9bf207645 192.168.4.53:6353
   slots:12288-16383 (4096 slots) master
   1 additional replica(s)
S: d9634ba0aa5c1a07193da4a013da6051c1515922 192.168.4.54:6354
   slots: (0 slots) slave
   replicates 9e44139cffb8ebd7ed746aabbf4bcea9bf207645
M: 324e05df3f143ef97e50d09be0328a695e655986 192.168.4.52:6352
   slots:6827-10922 (4096 slots) master
   1 additional replica(s)
M: 4fe1fa467ad237802021f5aac5f1d5b3e0db47ef 192.168.4.58:6358
   slots:0-1364,5461-6826,10923-12287 (4096 slots) master
   0 additional replica(s)
[OK] All nodes agree about slots configuration.
>>> Check for open slots...
>>> Check slots coverage...
[OK] All 16384 slots covered.
Automatically selected master 192.168.4.58:6358
>>> Send CLUSTER MEET to node 192.168.4.59:6359 to make it join the cluster.
Waiting for the cluster to join.
>>> Configure node as replica of 192.168.4.58:6358.
[OK] New node added correctly.
[root@mgm57 ~]#


[root@mgm57 ~]# redis-trib.rb  info  192.168.4.51:6351
192.168.4.55:6355 (2d343a9d...) -> 3 keys | 4096 slots | 1 slaves.
192.168.4.53:6353 (9e44139c...) -> 3 keys | 4096 slots | 1 slaves.
192.168.4.52:6352 (324e05df...) -> 2 keys | 4096 slots | 1 slaves.
192.168.4.58:6358 (4fe1fa46...) -> 5 keys | 4096 slots | 1 slaves.
[OK] 13 keys in 4 masters.
0.00 keys per slot on average.
[root@mgm57 ~]#


	   ]# redis-trib.rb check 192.168.4.51:6351


ot@mgm57 ~]# redis-trib.rb  check  192.168.4.51:6351
>>> Performing Cluster Check (using node 192.168.4.51:6351)
S: d9f8fe6d6d9dd391be8e7904501db1535e4d17cb 192.168.4.51:6351
   slots: (0 slots) slave
   replicates 2d343a9df48f6f6e207949e980ef498466a44dad
S: 7f3fa4f20c8c516d5b412ecc22550ed8e7bb8d7a 192.168.4.59:6359
   slots: (0 slots) slave
   replicates 4fe1fa467ad237802021f5aac5f1d5b3e0db47ef
S: 894dd0008053f6fb65e9e4a36b755d9351607500 192.168.4.56:6356
   slots: (0 slots) slave
   replicates 324e05df3f143ef97e50d09be0328a695e655986
M: 2d343a9df48f6f6e207949e980ef498466a44dad 192.168.4.55:6355
   slots:1365-5460 (4096 slots) master
   1 additional replica(s)
M: 9e44139cffb8ebd7ed746aabbf4bcea9bf207645 192.168.4.53:6353
   slots:12288-16383 (4096 slots) master
   1 additional replica(s)
S: d9634ba0aa5c1a07193da4a013da6051c1515922 192.168.4.54:6354
   slots: (0 slots) slave
   replicates 9e44139cffb8ebd7ed746aabbf4bcea9bf207645
M: 324e05df3f143ef97e50d09be0328a695e655986 192.168.4.52:6352
   slots:6827-10922 (4096 slots) master
   1 additional replica(s)
M: 4fe1fa467ad237802021f5aac5f1d5b3e0db47ef 192.168.4.58:6358
   slots:0-1364,5461-6826,10923-12287 (4096 slots) master
   1 additional replica(s)
[OK] All nodes agree about slots configuration.
>>> Check for open slots...
>>> Check slots coverage...
[OK] All 16384 slots covered.
[root@mgm57 ~]#


		   192.168.4.50 访问从服务器192.168.4.59
		   ]# redis-cli -c  -h 192.168.4.59 -p 6359
		   > keys *  自动同步主服务器数据
[root@host50 ~]# redis-cli  -c -h 192.168.4.59 -p 6359
192.168.4.59:6359> keys *
1) "name"
2) "name2"
3) "age"
4) "y"
5) "shcool5"
192.168.4.59:6359>

		休息到 17：40
		192.168.4.57 执行移除slave角色服务器
[root@mgm57 ~]# redis-trib.rb  info  192.168.4.51:6351
192.168.4.55:6355 (2d343a9d...) -> 3 keys | 4096 slots | 1 slaves.
192.168.4.53:6353 (9e44139c...) -> 3 keys | 4096 slots | 1 slaves.
192.168.4.52:6352 (324e05df...) -> 2 keys | 4096 slots | 1 slaves.
192.168.4.58:6358 (4fe1fa46...) -> 5 keys | 4096 slots | 1 slaves.
[OK] 13 keys in 4 masters.
0.00 keys per slot on average.
[root@mgm57 ~]#
[root@mgm57 ~]# redis-trib.rb  check  192.168.4.51:6351
>>> Performing Cluster Check (using node 192.168.4.51:6351)
S: d9f8fe6d6d9dd391be8e7904501db1535e4d17cb 192.168.4.51:6351
   slots: (0 slots) slave
   replicates 2d343a9df48f6f6e207949e980ef498466a44dad
S: 7f3fa4f20c8c516d5b412ecc22550ed8e7bb8d7a 192.168.4.59:6359
   slots: (0 slots) slave
   replicates 4fe1fa467ad237802021f5aac5f1d5b3e0db47ef
S: 894dd0008053f6fb65e9e4a36b755d9351607500 192.168.4.56:6356
   slots: (0 slots) slave
   replicates 324e05df3f143ef97e50d09be0328a695e655986
M: 2d343a9df48f6f6e207949e980ef498466a44dad 192.168.4.55:6355
   slots:1365-5460 (4096 slots) master
   1 additional replica(s)
M: 9e44139cffb8ebd7ed746aabbf4bcea9bf207645 192.168.4.53:6353
   slots:12288-16383 (4096 slots) master
   1 additional replica(s)
S: d9634ba0aa5c1a07193da4a013da6051c1515922 192.168.4.54:6354
   slots: (0 slots) slave
   replicates 9e44139cffb8ebd7ed746aabbf4bcea9bf207645
M: 324e05df3f143ef97e50d09be0328a695e655986 192.168.4.52:6352
   slots:6827-10922 (4096 slots) master
   1 additional replica(s)
M: 4fe1fa467ad237802021f5aac5f1d5b3e0db47ef 192.168.4.58:6358
   slots:0-1364,5461-6826,10923-12287 (4096 slots) master
   1 additional replica(s)
[OK] All nodes agree about slots configuration.
>>> Check for open slots...
>>> Check slots coverage...
[OK] All 16384 slots covered.
[root@mgm57 ~]#
[root@mgm57 ~]#
[root@mgm57 ~]#
[root@mgm57 ~]#
[root@mgm57 ~]# redis-trib.rb  check  192.168.4.51:6351
>>> Performing Cluster Check (using node 192.168.4.51:6351)
S: d9f8fe6d6d9dd391be8e7904501db1535e4d17cb 192.168.4.51:6351
   slots: (0 slots) slave
   replicates 2d343a9df48f6f6e207949e980ef498466a44dad
S: 7f3fa4f20c8c516d5b412ecc22550ed8e7bb8d7a 192.168.4.59:6359
   slots: (0 slots) slave
   replicates 4fe1fa467ad237802021f5aac5f1d5b3e0db47ef
S: 894dd0008053f6fb65e9e4a36b755d9351607500 192.168.4.56:6356
   slots: (0 slots) slave
   replicates 324e05df3f143ef97e50d09be0328a695e655986
M: 2d343a9df48f6f6e207949e980ef498466a44dad 192.168.4.55:6355
   slots:1365-5460 (4096 slots) master
   1 additional replica(s)
M: 9e44139cffb8ebd7ed746aabbf4bcea9bf207645 192.168.4.53:6353
   slots:12288-16383 (4096 slots) master
   1 additional replica(s)
S: d9634ba0aa5c1a07193da4a013da6051c1515922 192.168.4.54:6354
   slots: (0 slots) slave
   replicates 9e44139cffb8ebd7ed746aabbf4bcea9bf207645
M: 324e05df3f143ef97e50d09be0328a695e655986 192.168.4.52:6352
   slots:6827-10922 (4096 slots) master
   1 additional replica(s)
M: 4fe1fa467ad237802021f5aac5f1d5b3e0db47ef 192.168.4.58:6358
   slots:0-1364,5461-6826,10923-12287 (4096 slots) master
   1 additional replica(s)
[OK] All nodes agree about slots configuration.
>>> Check for open slots...
>>> Check slots coverage...
[OK] All 16384 slots covered.
[root@mgm57 ~]#
[root@mgm57 ~]# redis-trib.rb  info  192.168.4.51:6351
192.168.4.55:6355 (2d343a9d...) -> 3 keys | 4096 slots | 1 slaves.
192.168.4.53:6353 (9e44139c...) -> 3 keys | 4096 slots | 1 slaves.
192.168.4.52:6352 (324e05df...) -> 2 keys | 4096 slots | 1 slaves.
192.168.4.58:6358 (4fe1fa46...) -> 5 keys | 4096 slots | 1 slaves.
[OK] 13 keys in 4 masters.
0.00 keys per slot on average.
[root@mgm57 ~]# redis-trib.rb  check  192.168.4.51:6351
>>> Performing Cluster Check (using node 192.168.4.51:6351)
S: d9f8fe6d6d9dd391be8e7904501db1535e4d17cb 192.168.4.51:6351
   slots: (0 slots) slave
   replicates 2d343a9df48f6f6e207949e980ef498466a44dad
S: 7f3fa4f20c8c516d5b412ecc22550ed8e7bb8d7a 192.168.4.59:6359
   slots: (0 slots) slave
   replicates 4fe1fa467ad237802021f5aac5f1d5b3e0db47ef
S: 894dd0008053f6fb65e9e4a36b755d9351607500 192.168.4.56:6356
   slots: (0 slots) slave
   replicates 324e05df3f143ef97e50d09be0328a695e655986
M: 2d343a9df48f6f6e207949e980ef498466a44dad 192.168.4.55:6355
   slots:1365-5460 (4096 slots) master
   1 additional replica(s)
M: 9e44139cffb8ebd7ed746aabbf4bcea9bf207645 192.168.4.53:6353
   slots:12288-16383 (4096 slots) master
   1 additional replica(s)
S: d9634ba0aa5c1a07193da4a013da6051c1515922 192.168.4.54:6354
   slots: (0 slots) slave
   replicates 9e44139cffb8ebd7ed746aabbf4bcea9bf207645
M: 324e05df3f143ef97e50d09be0328a695e655986 192.168.4.52:6352
   slots:6827-10922 (4096 slots) master
   1 additional replica(s)
M: 4fe1fa467ad237802021f5aac5f1d5b3e0db47ef 192.168.4.58:6358
   slots:0-1364,5461-6826,10923-12287 (4096 slots) master
   1 additional replica(s)
[OK] All nodes agree about slots configuration.
>>> Check for open slots...
>>> Check slots coverage...
[OK] All 16384 slots covered.
[root@mgm57 ~]#
[root@mgm57 ~]#
[root@mgm57 ~]#
[root@mgm57 ~]# redis-trib.rb  del-node 192.168.4.51:6351 7f3fa4f20c8c516d5b412ecc22550ed8e7bb8d7a
>>> Removing node 7f3fa4f20c8c516d5b412ecc22550ed8e7bb8d7a from cluster 192.168.4.51:6351
>>> Sending CLUSTER FORGET messages to the cluster...
>>> SHUTDOWN the node.
[root@mgm57 ~]#
[root@mgm57 ~]# redis-trib.rb  info  192.168.4.51:6351192.168.4.55:6355 (2d343a9d...) -> 3 keys | 4096 slots | 1 slaves.
192.168.4.53:6353 (9e44139c...) -> 3 keys | 4096 slots | 1 slaves.
192.168.4.52:6352 (324e05df...) -> 2 keys | 4096 slots | 1 slaves.
192.168.4.58:6358 (4fe1fa46...) -> 5 keys | 4096 slots | 0 slaves.
[OK] 13 keys in 4 masters.
0.00 keys per slot on average.
[root@mgm57 ~]#
[root@mgm57 ~]# redis-trib.rb  check  192.168.4.51:6351>>> Performing Cluster Check (using node 192.168.4.51:6351)
S: d9f8fe6d6d9dd391be8e7904501db1535e4d17cb 192.168.4.51:6351
   slots: (0 slots) slave
   replicates 2d343a9df48f6f6e207949e980ef498466a44dad
S: 894dd0008053f6fb65e9e4a36b755d9351607500 192.168.4.56:6356
   slots: (0 slots) slave
   replicates 324e05df3f143ef97e50d09be0328a695e655986
M: 2d343a9df48f6f6e207949e980ef498466a44dad 192.168.4.55:6355
   slots:1365-5460 (4096 slots) master
   1 additional replica(s)
M: 9e44139cffb8ebd7ed746aabbf4bcea9bf207645 192.168.4.53:6353
   slots:12288-16383 (4096 slots) master
   1 additional replica(s)
S: d9634ba0aa5c1a07193da4a013da6051c1515922 192.168.4.54:6354
   slots: (0 slots) slave
   replicates 9e44139cffb8ebd7ed746aabbf4bcea9bf207645
M: 324e05df3f143ef97e50d09be0328a695e655986 192.168.4.52:6352
   slots:6827-10922 (4096 slots) master
   1 additional replica(s)
M: 4fe1fa467ad237802021f5aac5f1d5b3e0db47ef 192.168.4.58:6358
   slots:0-1364,5461-6826,10923-12287 (4096 slots) master
   0 additional replica(s)
[OK] All nodes agree about slots configuration.
>>> Check for open slots...
>>> Check slots coverage...
[OK] All 16384 slots covered.
[root@mgm57 ~]#


		192.168.4.57 执行移除master角色服务器
]# redis-trib.rb reshard 192.168.4.51:6351  释放hash槽
指定移出slots   个数
指定接收slots   主机ID
指定移出slots   主机ID

			移除master主机
]# redis-trib.rb  del-node 192.168.4.51:6351  \  e081313ec843655d9bc5a17f3bed3de1dccb1d2b
>>> Removing node e081313ec843655d9bc5a17f3bed3de1dccb1d2b from cluster 192.168.4.51:6351
>>> Sending CLUSTER FORGET messages to the cluster...
>>> SHUTDOWN the node.

++++++++++++NoSQL_DAY03
一、主从复制
	info replication
	slaveof  master_ip   master_port
        slaveof  no one

	配置文件选项 slaveof  master_ip   master_port

        配置带验证的主从复制


二、数据持久化
	2.1  RDB（默认）
[root@host58 6379]# cp /var/lib/redis/6379/dump.rdb   /root/
[root@host58 6379]# ls /root/dump.rdb
/root/dump.rdb
[root@host58 6379]# scp  /root/dump.rdb  root@192.168.4.59:/tmp/

[root@host59 ~]# /etc/init.d/redis_6379 stop
[root@host59 ~]# cd /var/lib/redis/6379/
[root@host59 6379]# rm -rf dump.rdb
[root@host59 6379]# cp /tmp/dump.rdb ./
[root@host59 6379]# ls
dump.rdb
[root@host59 6379]# /etc/init.d/redis_6379 start
[root@host59 6379]# redis-cli  -h 192.168.4.59 -p 6359
192.168.4.59:6359> keys *

		练习到 14：18

  262  /etc/init.d/redis_6379  stop

  264  rm -rf /var/lib/redis/6379/dump.rdb
  265  vim /etc/redis/6379.conf
	save 900  1
	save  120  10
	save  60 10000
      :wq

  266  /etc/init.d/redis_6379  start
  267  ls /var/lib/redis/6379/

  ]# redis-cli -h 192.168.4.58 -p 6358
      2分钟内 存储大于或等于10个变量后，会自动创建dump.rdb文件

	2.2  AOF
192.168.4.58:
> config  set  appendonly  yes    //启用
> config  rewrite
> save
> exit

]#cd /var/lib/redis/6379/
]#cp  appendonly.aof  /root/
]# scp   /root/appendonly.aof  root@192.168.4.59:/tmp/

192.168.4.59
[root@host59 ~]# redis-cli  -h 192.168.4.59 -p 6359
192.168.4.59:6359> flushall
OK
192.168.4.59:6359> keys *
(empty list or set)
192.168.4.59:6359> config set appendonly yes
OK
192.168.4.59:6359> config rewrite
OK
192.168.4.59:6359> exit
[root@host59 ~]# /etc/init.d/redis_6379 stop

[root@host59 6379]# cp /tmp/appendonly.aof  ./
cp：是否覆盖"./appendonly.aof"？ y
[root@host59 6379]# ls
appendonly.aof  dump.rdb
[root@host59 6379]#
[root@host59 6379]# /etc/init.d/redis_6379 start
Starting Redis server...
[root@host59 6379]# redis-cli  -h 192.168.4.59 -p 6359
192.168.4.59:6359> keys *
			休息到 15：25


三、数据类型


192.168.4.58:6358> set tel 18101918866
OK
192.168.4.58:6358> get tel
"18101918866"
192.168.4.58:6358> SETRANGE tel 4 ***
(integer) 11
192.168.4.58:6358> get tel
"1810***8866"
192.168.4.58:6358> keys *
1) "y"
2) "tel"
3) "x"
192.168.4.58:6358> get x
"77"
192.168.4.58:6358> STRLEN x
(integer) 2
192.168.4.58:6358> APPEND x 88
(integer) 4
192.168.4.58:6358> get x
"7788"
192.168.4.58:6358> APPEND x2 66
(integer) 2
192.168.4.58:6358> keys *
1) "y"
2) "x2"
3) "tel"
4) "x"
192.168.4.58:6358>
192.168.4.58:6358>



nteger) 7787
192.168.4.58:6358> decr x
(integer) 7786
192.168.4.58:6358> decr x
(integer) 7785
192.168.4.58:6358> get x
"7785"
192.168.4.58:6358> decr x3
(integer) -1
192.168.4.58:6358> get x3
"-1"
192.168.4.58:6358> decrby x 5
(integer) 7780
192.168.4.58:6358> decrby x 5
(integer) 7775
192.168.4.58:6358> get x
"7775"
192.168.4.58:6358> 1G=1024M
1M=1024K
1K=1024byte
1字节=8位 11111111
	  00000000
192.168.4.58:6358> setbit  baobao  1 0
(integer) 0
192.168.4.58:6358> setbit  baobao  2 1
(integer) 0
192.168.4.58:6358> setbit  baobao  3 0
(integer) 0
192.168.4.58:6358> setbit  baobao  4 1
(integer) 0
192.168.4.58:6358> setbit  baobao  5 1
(integer) 0
192.168.4.58:6358> setbit  baobao  6 1
(integer) 0
192.168.4.58:6358> setbit  baobao  7 0
(integer) 0
192.168.4.58:6358> BITCOUNT baobao
(integer) 4
i




192.168.4.58:6358> set zm  abcdef
OK
192.168.4.58:6358> get zm
"abcdef"
192.168.4.58:6358> GETRANGE zm -2 -1
"ef"
192.168.4.58:6358> GETRANGE zm -3 -1
"def"
192.168.4.58:6358>
192.168.4.58:6358> GETRANGE zm 1 3
"bcd"
192.168.4.58:6358> GETRANGE zm 0 1
"ab"
192.168.4.58:6358> GETRANGE zm 2 4
"cde"
192.168.4.58:6358>



192.168.4.58:6358> set x 4
OK
192.168.4.58:6358> INCR x
(integer) 5
192.168.4.58:6358> INCR x
(integer) 6
192.168.4.58:6358> get x
"6"
192.168.4.58:6358>
192.168.4.58:6358> incrby x 3
(integer) 9
192.168.4.58:6358> incrby x 3
(integer) 12
192.168.4.58:6358> get x
"12"
192.168.4.58:6358> INCRBY x 0.5
(error) ERR value is not an integer or out of range
192.168.4.58:6358>
192.168.4.58:6358> INCRBYFLOAT x 0.5
"12.5"
192.168.4.58:6358> get x
"12.5"
192.168.4.58:6358>

List列表

192.168.4.58:6358> lpush mstu bob  tom  jim  lucy
(integer) 4
192.168.4.58:6358> keys *
1) "zm"
2) "mstu"
3) "x"
192.168.4.58:6358> type mstu
list
192.168.4.58:6358>
192.168.4.58:6358> get mstu
(error) WRONGTYPE Operation against a key holding the wrong kind of value
192.168.4.58:6358>
192.168.4.58:6358> lpush mstu jack mack
(integer) 6
192.168.4.58:6358> LRANGE mstu 0 -1
1) "mack"
2) "jack"
3) "lucy"
4) "jim"
5) "tom"
6) "bob"
192.168.4.58:6358>

192.168.4.58:6358> LRANGE mstu 0 1
1) "mack"
2) "jack"
192.168.4.58:6358> LRANGE mstu 2 4
1) "lucy"
2) "jim"
3) "tom"
192.168.4.58:6358> LRANGE mstu -2 -1
1) "tom"
2) "bob"
192.168.4.58:6358>


192.168.4.58:6358> LRANGE mstu 0 -1
1) "mack"
2) "jack"
3) "lucy"
4) "jim"
5) "tom"
6) "bob"
192.168.4.58:6358> lpop mstu
"mack"
192.168.4.58:6358> LRANGE mstu 0 -1
1) "jack"
2) "lucy"
3) "jim"
4) "tom"
5) "bob"
192.168.4.58:6358> lpop mstu2
(nil)
192.168.4.58:6358> LLEN mstu
(integer) 5
192.168.4.58:6358>


192.168.4.58:6358> LRANGE mstu 0 -1
1) "jack"
2) "lucy"
3) "jim"
4) "tom"
5) "bob"
192.168.4.58:6358> LINDEX mstu 0
"jack"
192.168.4.58:6358> LINDEX mstu 2
"jim"
192.168.4.58:6358> LINDEX mstu -1
"bob"
192.168.4.58:6358> lset mstu 0 jerry
OK
192.168.4.58:6358> LINDEX mstu 0
"jerry"
192.168.4.58:6358> rpush mstu bob2
(integer) 6
192.168.4.58:6358> LRANGE mstu 0 -1
1) "jerry"
2) "lucy"
3) "jim"
4) "tom"
5) "bob"
6) "bob2"
192.168.4.58:6358>


192.168.4.58:6358> LRANGE mstu 0 -1
1) "jerry"
2) "lucy"
3) "jim"
4) "tom"
5) "bob"
6) "bob2"
192.168.4.58:6358> rpop mstu
"bob2"
192.168.4.58:6358> lpop mstu
"jerry"
192.168.4.58:6358> LRANGE mstu 0 -1
1) "lucy"
2) "jim"
3) "tom"
4) "bob"
192.168.4.58:6358>


Hash表    【 17:25 上课 】

set  bookname  xxx
set  worker    yyy
set  money     21
set  fx        rmcbs

		hmset book bookname xxx worker yyy money 21  fx rmcbs

192.168.4.58:6358>  hmset book bookname xxx worker yyy money 21  fx rmcbs
OK
192.168.4.58:6358> keys *
1) "book"
192.168.4.58:6358> type book
hash
192.168.4.58:6358>
192.168.4.58:6358> get book
(error) WRONGTYPE Operation against a key holding the wrong kind of value
192.168.4.58:6358> hmget book bookname worker
1) "xxx"
2) "yyy"
192.168.4.58:6358>

192.168.4.50:6350> hmset site sina  www.sina.com.cn tarena www.tedu.cn
OK
192.168.4.50:6350> hkeys site
1) "google"
2) "baidu"
3) "sina"
4) "tarena"
192.168.4.50:6350> HVALS site
1) "www.g.cn"
2) "www.baidu.com"
3) "www.sina.com.cn"
4) "www.tedu.cn"
192.168.4.50:6350> HGETALL site
1) "google"
2) "www.g.cn"
3) "baidu"
4) "www.baidu.com"
5) "sina"
6) "www.sina.com.cn"
7) "tarena"
8) "www.tedu.cn"
192.168.4.50:6350>
192.168.4.50:6350> hkeys site
1) "google"
2) "baidu"
3) "sina"
4) "tarena"
192.168.4.50:6350> hdel site baidu sina
(integer) 2
192.168.4.50:6350> hkeys site
1) "google"
2) "tarena"
192.168.4.50:6350>
192.168.4.50:6350> keys *
1) "site"
192.168.4.50:6350> del site
(integer) 1
192.168.4.50:6350> keys *
(empty list or set)
192.168.4.50:6350>

+++++++++++++++++++++++++++++++++++
IDC监控

监控与服务安全_day01
一、监控概述
	1.1 相关概念

二、Zabbix基础
	2.1 Zabbix简介
	2.2 搭建zabbix监控服务器
		2.2.1 部署LNMP
		2.2.2 部署Zabbix
			1 安装源码zabbix软件
			2 初始化准备
			3 初始化配置 http://192.168.2.5/index.php
			  ]# cat /usr/local/nginx/html/conf/zabbix.conf.php
			4 使用初始密码登陆
			5 环境配置
			6 运行zabbix_server服务
				6.1 修改服务主配置文件
				6.2 启动服务

三、Zabbix监控服务
		3.1 监控远端主机 192.168.2.100
			3.1.1 配置客户端 192.168.2.100
				1 安装zabbix源码软件
				2 修改配置文件
				3 启动zabbix_agentd服务

			3.1.2 配置服务器 192.168.2.5
				登陆管理页面做如下操作：
				 1 添加监控主机
				 2 应用监控模板
				 3 查看监控数据

		3.2 自定义监控(在客户端创建监控命令，给监控服务器使用)
			3.2.1 配置客户端 192.168.2.100
				1 启用自定义监控
]# vim /usr/local/etc/zabbix_agentd.conf
264 Include=/usr/local/etc/zabbix_agentd.conf.d/
280 UnsafeUserParameters=1
:wq

				2 定义监控命令
]# cd /usr/local/etc/zabbix_agentd.conf.d/
]# vim  count.line.passwd
   UserParameter=count.line.passwd,wc -l /etc/passwd | awk ' {print $1} '
:wq

				3 重启服务
				]# killall -9  zabbix_agentd
				]# zabbix_agentd

				4 测试监控命令
				若没有zabbix_get命令
				去这里下载
				http://repo.zabbix.com/zabbix/3.2/rhel/7/x86_64/
				或者到 47.94.12.29 的ftp 下载

web100 ~]# zabbix_get  -s 127.0.0.1 -p 10050  -k count.line.passwd


			3.2.2 配置监控服务器
				测试客户端定义的监控命令
zabbix-server ~]# zabbix_get  -s 192.168.2.100 -p 10050  -k count.line.passwd
				登陆web页面做如下操作：
				1 创建监控模板 A_tmp1
				2 创建应用集   user-count
				3 创建监控项(并关联命令)monitor_100_users
				4 将模板关联主机（调用创建的监控模板）
				5 查看监控数据
关于创建监控项目　时填写的 key (键值)
https://www.zabbix.com/documentation/3.0/manual/config/items/itemtypes/zabbix_agent
课外练习：
192.168.2.5 监控服务器，对本机器做监控，
监控本机器nginx服务的运行状态，及系统状态、及系统总用户数量
           80                     0S



########################################
zabbix监控磁盘剩余容量 (被动模式) 可以参考
http://www.zsythink.net/archives/670
在检测 磁盘 剩余容量的	使用的 key 值
vfs.fs.size[/,pused]  使用 zabbix_get 测试
           路径,free/total/pused
           需要注意的是 free/total 返回的值是整数 返回百分比 是浮点
           在创建监控项目的时候需要注意 信息类型
           如果返回的是字节则是整数，如果返回的是百分比则是浮点。
########################################
+++++++++监控与服务安全_day02
监控服务器
	设置IP地址（192.168.2.5）
一、Zabbix报警机制
	1.1 相关概念 ：
		创建触发器   tone

		配置邮件服务:(在监控服务器本机运行邮件服务)
				]# yum -y  install postfix
  				]# rpm -q postfix
  				]# systemctl  start postfix
  				]# netstat -utnlp  | grep  :25
]# vim /etc/hosts
127.0.0.1       zabbix-server  localhost localhost.localdomain localhost4 localhost4.localdomain4
:wq

]# yum -y  install mailx
[root@zabbix-server ~]# which  mailx
/usr/bin/mailx
[root@zabbix-server ~]# mail -s "xxx"  zabbix  < /etc/yum.repos.d/local.repo
[root@zabbix-server ~]#
[root@zabbix-server ~]# su - zabbix
[zabbix@zabbix-server ~]$
[zabbix@zabbix-server ~]$ mail
Heirloom Mail version 12.5 7/5/10.  Type ? for help.
"/var/spool/mail/zabbix": 1 message 1 new
>N  1 root                  Fri Jun 28 09:48  22/734   "xxx"
& exit
[zabbix@zabbix-server ~]$ exit
logout
[root@zabbix-server ~]#

		指定邮件服务器
		创建Media （指定收件人）
		创建Action   名aone
		验证配置： 监控到主机100的用户数量大于28个时,zabbix@localhost邮箱是否收到邮件。



二、Zabbix进阶操作
		2.1 自动发现
			创建自动发现规则
			创建动作




		2.2 主被动监控
			主动监控       server<-------client

			被动监控（默认） server -----> client

			配置主动监控
				1 配置客户端 192.168.2.201
					安装zabbix软件
					修改服务，运行时是主动模式
					启动服务

				2 配置服务器 192.168.2.5
					登陆管理页面做如下配置：
					  1 克隆模板          14：32
					  2 修改监控项模式
					3 添加监控主机 201
					4 查看数据图表
		2.3 拓扑图与聚合图形
			1 拓扑图
			2 聚合图形

三、监控案例
	3.1 监控Nginx  (192.168.2.100)
		 环境准备：部署Nginx时要加载status模块

                 在客户端创建监控命令 nginx.status[*]

	         登陆监控服务的管理页面做如下配置:
				1 创建监控模板 	Atmp2
				2 创建应用集      mon-nginx
				3 创建监控项 并关联到对应的监控命令
				now_link_num  	  nginx.status[Active]
				now_link_req	  nginx.status[accepts]
				now_waiting_num   nginx.status[Waiting]

				4 添加监控主机 并调用监控模板
				5 查看监控数据




监控客户端
	主机192.168.2.5


第三阶段 数据库 (重要) 职业--DBA
静静老师
邮箱: 有问题可以发邮件
panglj@tedu.cn
402er

数据库是可以存储所有的数据,但不是所有的数据都适合保存在数据库中(比如视频),
        SQL语句执顺序
            执行FROM ---> where--->group by--->聚合函数having--->order by (排序)

    关系型数据库-RDBMS        MYSQL       数据库管理员 DBA
    非关系型的数据库-NOsql     Redis       运维工程师  DBA

    学完后可以 做 监控与安全

    基础阶段
        DAY01
                解包
                安装软件包
                启动mysql服务
                查看服务进程和端口
                查看初始登录密码
                使用初始密码登录
                修改登录密码
                断开链接
                使用修改后密码登录
                根据新密码策略设置密码
                使用新密码登录

            1.搭建数据库
                1.1 相关概念
                    DB---database
                    数据库
                    依照某种数据模型进行组织并存放到存储器的数据合集
                    DBMS---database management system
                    数据库管理系统
                    用来操作和管理数据库的服务软件
                    DBS---database system
                    数据库系统
                    指带有数据库并整合了数据库管理软件的计算机系统


                        软件名      开源 跨平台
                    --- Oracle      n   y
                    |   mysql       y   y
                  RDBMS sqlserver   n   y
                    |- -db2         n   y
                        redis       y   y
                        memcache    y   y
                        mongodb     y   y

                    MYSQL 特点:
                                中小型规模,关系型数据库
                                跨平台
                                支持 Python Java perl php 等编程语言

                    应用环境:
                                LAMP 与Apache HTTP Server 组合
                                LNMP 与Nginx 组合

                    相关参数
                           文件               说明
                           /etc/my.conf      主配置文件
                           /var/lib/mysql    数据库主目录
                           默认端口号          3306
                           进程名              mysqld
                           传输协议             tcp
                           进程所有者           mysql
                           进程所属组           mysql
                           错误日志             /var/log/mysqld.log
                    装包

                        tar -xvf mysql-5.7.17.tar
                        yum -y install mysql-community-*.rpm
                        rpm -qa | grep -i mysql

                    起服务
                        systemctl restart mysqld
                        mysql
                        ls /var/lib/mysql/
                    开机自启
                        systemctl enable mysqld
                    查看服务启动
                        ss -antulp | grep mysqld
                1.2 初始密码登录
                        ################用户密码默认由软件生成###########################
                        [root@DBA mysql]# grep 'password' /var/log/mysqld.log
                        2019-06-06T02:11:08.044931Z 1 [Note] A temporary password is generated for root@localhost: lKpqL5QO4+=:
                        2019-06-06T02:11:52.610948Z 3 [Note] Access denied for user 'root'@'localhost' (using password: NO)
                        [root@DBA mysql]# cd
                        #######第一次登录时只能由 hlocalhost  登入 ########################
                        [root@DBA ~]# mysql -hlocalhost -uroot -p'lKpqL5QO4+=:'  ###不能有空格
                        ##########设置root的新密码####################################
                        mysql> alter user root@"localhost" identified by "123qqq...A";
                        Query OK, 0 rows affected (0.00 sec)
                        也可以使用 set passwd="newpasswd" 来实现
                        ###############使用 root 新密码登录, 在本机登录时 -hlocalhost 可以;省略##########
                        [root@DBA ~]# mysql -uroot -p123qqq...A
                1.3 修改密码策略 (可选项)
                        0 or LOW       长度
                        1 or MEDIUM    长度;数字,小写/大写 和特殊字符
                        2 or STRONG    长度;数字,小写/大写 和特殊字符 ;字典文件
                查看变量
                        模糊查找:(只要包含这个字段就行)
                            使用两个%将需要匹配的字段包起来.
                        去掉  两个% 是精确匹配
                        mysql> show variables like "%password%";
                        +---------------------------------------+--------+
                        | Variable_name                         | Value  |
                        +---------------------------------------+--------+
                        | default_password_lifetime             | 0      |
                        | disconnect_on_expired_password        | ON     |
                        | log_builtin_as_identified_by_password | OFF    |
                        | mysql_native_password_proxy_users     | OFF    |
                        | old_passwords                         | 0      |
                        | report_password                       |        |
                        | sha256_password_proxy_users           | OFF    |
                        | validate_password_check_user_name     | OFF    |
                        | validate_password_dictionary_file     |        |
                        | validate_password_length              | 8      |
                        | validate_password_mixed_case_count    | 1      |
                        | validate_password_number_count        | 1      |
                        | validate_password_policy              | MEDIUM |
                        | validate_password_special_char_count  | 1      |
                        +---------------------------------------+--------+
                        14 rows in set (0.01 sec)
                       修改密码策略
                        mysql> set global validate_password_policy=0;
                        Query OK, 0 rows affected (0.00 sec)
                        修改`密码长度
                        mysql> set global validate_password_length=6;
                        Query OK, 0 rows affected (0.00 sec)
                        永久修改配置
                        [root@DBA ~]# vim /etc/my.cnf
                        [mysqld]
                        #手动添加 默认没有
                        validate_password_policy=0
                        validate_password_length=6

                       设置新密码
                        mysql> alter user root@"localhost" identified by "tarena";  Query OK, 0 rows affected (0.00 sec)
                        mysql> exit
                        Bye
                       使用新密码登录
                        [root@DBA ~]# mysql -uroot -ptarena


            2.数据库服务的基本使用
                2.1链接mysql服务
                    1.链接方式
                        1)命令行

                            访问数据库
                            mysql -h服务器ip -u用户名 -p密码[数据库名选填]
                            显示目前位置(我在哪里)
                            mysql> select database();
                            +------------+
                            | database() |
                            +------------+
                            | NULL       |
                            +------------+
                            1 row in set (0.00 sec)

                        2)web界面
                        3)安装图形软件
                        4)编写脚本(php java Python)

                    2.数据存储流程
                         连接数据库服务器
                         建库               库类似于文件夹
                         建表               表类似于文件
                         插入数据
                         断开连接 TCP

                         SQL 结构化查询语句
                            sql语句不区分大小写 (密码,变量除外)
                            语句以 ; 结束 只有少数 不用加 ;
                            只有少数;命令可以tab
                            \c ;之前 或者ctrl + c 结束命令
                         SQL命令分类
                            DDL  数据定义语言  create alter drop
                            DML  数据操作语言  insert update delete
                            DCL  数据控制语言  grant revoke
                            DTL  数据事物语言  commit  rollback
                         什么是事物:
                            事物:一次访问数据库的开始到断开数据库链接,表示一次事物
                            当执行一个操作时,失败后可根据事物日志恢复.

                    2.mysql管理环境
                        1)show databases; 显示已有的库
                            不要删除,修改已有的库 ,新建库存放数据
                        2)select user(); 显示链接用户
                        3)use 库名;       切换库
                        4)select database(); 显示当前所在的库
                        5)create database 库名; 创建新库
                            库名 命名规则
                                只能 用数字 字母 下划线不能纯数字
                                区分字母大小写 具有唯一性
                                不能使用关键词 特殊字符

                                mysql> create table db1.学生表(
                               姓名 char(10),
                               家庭地址 char(20)
                               ) DEFAULT CHARSET=utf8; ####添加参数支持中文,似乎只能在创建表的时候添加,待测试

                                mysql> insert into db1.学生表 values("张三丰","武当山");
                                mysql> insert into db1.学生表 values("张四丰","武台山");
                                mysql> select  * from  db1.学生表;

                        6)show tables ; 显示已有的表
                        7)drop database 库名; 删除库
                    表管理命令
                        1)select * from 库名.表名;
                        2)insert into 库名.表名 values(xxx);
                        3)update 库名.表名 set 字段=值;
                        4)delete from 库名.表名;  删除表单中的所有数据,但不删除表
                        5)create table 库名.表名;
                        7)drop table 表名； 删除表

                        mysql服务提交方式mysql服务提交方式autocommit

            3.Mysql数据类型
                字符
                    char varchar
                数值
                    整型

                        tinyint smallint int bigint
                    浮点
                         float  单精度 0-2^32-1
                         double 双精度 0-2^64-1
                         mysql> create table db1.t5 (name char(10), level  tinyint );
                    mysql> insert into  db1.t5 values ("zbj",-1);
                    mysql> insert into  db1.t5 values ("zbj",-129);
                    mysql> insert into  db1.t5 values ("zbj",198);

                    mysql> create table db1.t6 (name char(10), level  tinyint unsigned);
                    mysql> insert into  db1.t6 values ("zbj",-1);
                    mysql> insert into  db1.t6 values ("zbj",0);
                    mysql> insert into  db1.t6 values ("zbj",256);
                    mysql> insert into  db1.t6 values ("zbj",25);
                    mysql> insert into  db1.t6 values ("zbj",25.22);
                    mysql> insert into  db1.t6 values ("zbj",25.52);

                    mysql> create  table db1.t3(pay float , id double);
                    mysql> insert into db1.t3 values(9999.23,9999.77);

                    mysql> create  table db1.t4( pay float(5,2) , id double(4,2) );
                    mysql> insert into db1.t4 values(9999.23,9999.77);

                    mysql> create table  db1.t7(stu_num int , name char(5) ,
                           age tinyint ,pay float ,money float(7,2) );

                    mysql> desc  db1.t7 ;









                日期时间
                    类型 时间函数
                    年    日期   时间   日期时间
                    year  date   time   datetime/ timestamp

                    create table db1.t8(
                    name  char(15),
                    your_s    year,
                    birthday  date,
                    up_class  time,
                    party  datetime
                    );

                    desc  db1.t8 ;

                    insert into  db1.t8  values
                    ("bob",1990,20191120,083000,20190607203000);

                    当year类型 使用2位数赋值时：
                    0

                枚举  enum  单选
                     set   多选

                     mysql> create table db1.t21(
                                -> name char(10) not null,
                                -> age tinyint unsigned default 25,
                                -> sex enum("m","w") not null default "w");

                插入数据
                mysql> insert into db1.t21 (name,sex) values("tianmao","m");




        DAY02
            1.表结构
                1)约束条件
                    作用:限制给表字段赋值
                    查看字段的约束条件 : desc 库.表;
                        字段名 | 类型 | 空| 键值 | 默认值 |额外设置|
                        mysql> desc db2.t10;
                        +-------+--------------------------------+------+-----+---------+-------+
                        | Field | Type                           | Null | Key | Default | Extra |
                        +-------+--------------------------------+------+-----+---------+-------+
                        | name  | char(10)                       | YES  |     | NULL    |       |
                        | sex   | enum('boy','girl','no')        | YES  |     | NULL    |       |
                        | likes | set('eat','game','pi','sleep') | YES  |     | NULL    |       |
                        +-------+--------------------------------+------+-----+---------+-------+

                    约束条件有那些:
                                 是否为空  not null null
                                 键值     key
                                 默认设置 default  缺省 为null
                                 额外设置 extra
                                mysql>create tabledb1.t7;
                                ->name char(10) not null,
                                ->age tinyint unsignted default 19  //无符号整型(没有负数)
                                ->class char(7) not null default "nsd1903"
                                ->pay float(7,2) default 28000
                                #######float共7位 两位小数
                                );
                               ###################################

                                mysql> create table db1.t21(
                                -> name char(10) not null,
                                -> age tinyint unsigned default 25,
                                -> sex enum("m","w") not null default "w");
                                Query OK, 0 rows affected (0.38 sec)

                                mysql> desc db1.t21;
                                +-------+---------------------+------+-----+---------+-------+
                                | Field | Type                | Null | Key | Default | Extra |
                                +-------+---------------------+------+-----+---------+-------+
                                | name  | char(10)            | NO   |     | NULL    |       |
                                | age   | tinyint(3) unsigned | YES  |     | 25      |       |
                                | sex   | enum('m','w')       | NO   |     | w       |       |
                                +-------+---------------------+------+-----+---------+-------+
                                3 rows in set (0.00 sec)
                                #################插入数据#########################
                                mysql> insert into db1.t21 values("dc",null,"w");
                                Query OK, 1 row affected (0.04 sec)

                                mysql> select * from db1.t21;
                                +------+------+-----+
                                | name | age  | sex |
                                +------+------+-----+
                                | dc   | NULL | w   |
                                +------+------+-----+
                                1 row in set (0.00 sec)
                                mysql> insert into db1.t21 (name,sex) values("tianmao","m");
                                Query OK, 1 row affected (0.03 sec)

                                mysql> select * from db1.t21;
                                +---------+------+-----+
                                | name    | age  | sex |
                                +---------+------+-----+
                                | dc      | NULL | w   |
                                | tianmao |   25 | m   |
                                +---------+------+-----+
                                2 rows in set (0.00 sec)




            2.表结结构
                    1)修改表结构
                        格式  alter table 库.表 执行动作;
                        执行动作:
                            add    添加新字段

                                    新字段默认添加在地段的末尾, 添加 first 后可添加至行首 after xxx 在xxx后添加
                                    alter table db1.t10
                                    add
                                    name char(15) frist;

                                    alter table db1.t10
                                    add age tinyint unsignted not null default 19 after name ;


                            drop   删除已有字段

                                    mysql> alter table db1.t10 drop email , drop stu_num;
                                        Query OK, 0 rows affected (0.62 sec)
                                        Records: 0  Duplicates: 0  Warnings: 0

                                    mysql> select * from db1.t10 ;                                                   +------+-----+------+-------------+
                                        | name | age | sex  | likes       |
                                        +------+-----+------+-------------+
                                        | dc   |  19 | boy  | eat,pi      |
                                        | dc2  |  19 | boy  | eat,game,pi |
                                        +------+-----+------+-------------+
                                        2 rows in set (0.00 sec)

                            modify 修改字段类型 (改类型 调位置)
                                    注意:修改的字段类型与已经存储的数据冲突时,不能修改类型

                                    ###################修改类型###################################
                                    mysql> alter table db1.t10 modify name varchar(15) default "";
                                        Query OK, 2 rows affected (0.73 sec)
                                        Records: 2  Duplicates: 0  Warnings: 0

                                    mysql> desc db1.t10 ;alter
                                        +-------+--------------------------------+------+-----+---------+-------+
                                        | Field | Type                           | Null | Key | Default | Extra |
                                        +-------+--------------------------------+------+-----+---------+-------+
                                        | name  | varchar(15)                    | YES  |     |         |       |
                                        | age   | tinyint(3) unsigned            | NO   |     | 19      |       |
                                        | sex   | enum('boy','gril','no')        | YES  |     | NULL    |       |
                                        | likes | set('eat','game','pi','sleep') | YES  |     | NULL    |       |
                                        +-------+--------------------------------+------+-----+---------+-------+
                                        4 rows in set (0.00 sec)

                                    #############调整位置#######################
                                    mysql> alter table db1.t10 modify age tinyint(3) unsigned not null after sex;
                                        Query OK, 0 rows affected (0.52 sec)
                                        Records: 0  Duplicates: 0  Warnings: 0

                                    mysql> desc db1.10;
                                        +-------+--------------------------------+------+-----+---------+-------+
                                        | Field | Type                           | Null | Key | Default | Extra |
                                        +-------+--------------------------------+------+-----+---------+-------+
                                        | name  | varchar(15)                    | YES  |     |         |       |
                                        | sex   | enum('boy','gril','no')        | YES  |     | NULL    |       |
                                        | age   | tinyint(3) unsigned            | NO   |     | NULL    |       |
                                        | loves | set('eat','game','pi','sleep') | YES  |     | NULL    |       |
                                        +-------+--------------------------------+------+-----+---------+-------+



                            change 修改字段名/修改字段名类型

                                        .....chenge likes .....

                                    mysql> alter table db1.t10 change likes loves set('eat','game','pi','sleep');
                                    Query OK, 0 rows affected (0.08 sec)
                                    Records: 0  Duplicates: 0  Warnings: 0

                                    mysql> desc db1.t10 ;                                                            +-------+--------------------------------+------+-----+---------+-------+
                                        | Field | Type                           | Null | Key | Default | Extra |
                                        +-------+--------------------------------+------+-----+---------+-------+
                                        | name  | varchar(15)                    | YES  |     |         |       |
                                        | age   | tinyint(3) unsigned            | NO   |     | 19      |       |
                                        | sex   | enum('boy','gril','no')        | YES  |     | NULL    |       |
                                        | loves | set('eat','game','pi','sleep') | YES  |     | NULL    |       |
                                        +-------+--------------------------------+------+-----+---------+-------+
                                        4 rows in set (0.00 sec)


                            rename 修改表名

                                    mysql> alter table db1.t10 rename db1.classinfo;
                                    Query OK, 0 rows affected (0.12 sec)

                                    mysql> show tables;
                                    +---------------+
                                    | Tables_in_db1 |
                                    +---------------+
                                    | classinfo     |
                                    | t21           |
                                    +---------------+


            3.mysql键值
                    1)键值类型:
                            普通索引 index
                            唯一索引 unique
                            主键  primary key
                            外键  foreign key
                            全文索引 fulltext
                    作用: 约束如何给字段赋值
                            索引:
                                类似于书中的目录
                                对表中的字段值进行排序
                                索引类型包括Btree B+tree hash
                            索引优缺点:
                                优点:
                                通过创建唯一性索引,可以保证数据库表中 每一行数据的唯一性
                                加快数据查询速度,数据库总是查询多
                                缺点:
                                当对表中数据进行增加 删除 和修改 的时候 索引要动态调整 降低数据维护速度
                                索引需要占物理空间
                                存储在数据库根目录下

                    2)mysql键值使用
                            2.1普通索引 index
                                使用规则:
                                    -一个表中有多个index字段
                                    -字段的只允许重复,且可以赋值null
                                    -通常把查询条件的字段设置为index字段
                                    -index字段 标志为 mul
                                查看:
                                    show index from 表名\G; \G表示 竖着显示
                                创建索引:

                                    在创建表时创建索引:
                                        create table db1.t22(
                                        class char(9),
                                        name char(15),
                                        age int,
                                        index(name),index(age));
                                    查看:
                                        mysql> show index from db1.t22\G;
                                    删除索引:
                                         mysql> drop index aaa on classinfo;
                                    在已有的表中创建索引:
                                        create index 索引名 on 表名(字段名);
                                        mysql> create index aaa on classinfo(name);
                                        drop index 索引名 on 表名;
                            2.2 主键
                                    作用:限制字段赋值
                                    使用规则:
                                        字段值不能从重复,且不能赋null(核心作用)
                                        一个表中只能有一个primary key 字段
                                        多个字段都作为主键,称为复合主键,必须一起创建
                                        主键通常与 auto increment(自增长) 连用
                                        主键字段标志是pri
                                        通常把表中唯一表示的字段设置为主键
                                        [纪录字段编号]
                                    创建主键

                                        mysql> create table db1.t23(
                                        -> name char(10) primary key, ###设定主键
                                        -> age int,
                                        -> pay float(7,2)
                                        -> );

                                        mysql> insert into db1.t23 values("bob","25","2000");
                                             ERROR 1062 (23000): Duplicate entry 'bob' for key 'PRIMARY'

                                        mysql> insert into db1.t23 values("aaa","25","2000");
                                            Query OK, 1 row affected (0.09 sec)

                                        mysql> select * from t23;
                                            +------+------+---------+
                                            | name | age  | pay     |
                                            +------+------+---------+
                                            | aaa  |   25 | 2000.00 |
                                            | bob  |   25 | 2565.00 |
                                            +------+------+---------+

                                        在已有表中创建主键:
                                            创建主键
                                            alter table 表名 add primary key(字段名);

                                            mysql> desc db1.classinfo;
                                            +-------+--------------------------------+------+-----+---------+-------+
                                            | Field | Type                           | Null | Key | Default | Extra |
                                            +-------+--------------------------------+------+-----+---------+-------+
                                            | name  | varchar(15)                    | NO   | PRI |         |       |


                                        删除主键
                                            使用drop 删除
                                              mysql> desc t3;
                                              mysql> alter  table  t3 drop  primary key;
                                              mysql> desc t3;
                                              mysql> insert into t3  values("nsd181101","tom",19);
                                              mysql> insert into t3  values(null,"jerry",19);
                                                ERROR 1048 (23000): Column 'stu_num' cannot be null
                                              mysql> select  * from  t3;


                                    创建复合主键
                                        约束方式: 主键字段的值不可以同时重复
                                        创建主键
                                        在已有表中添加复合主键

                                            alter table db1.t25 add primary key(id,name);

                                            mysql> create table db1.t24(                                                         -> clientip char(15),
                                            -> serport int,
                                            -> clientip char(15),
                                            -> status enum("yes","no"),
                                            #########要创建多少 就在这里添加多少###########
                                            -> primary key(clientip,serport)
                                            -> );
                                            Query OK, 0 rows affected (0.21 sec)

                                        mysql> desc db1.t24;
                                            +----------+------------------+------+-----+---------+-------+
                                            | Field    | Type             | Null | Key | Default | Extra |
                                            +----------+------------------+------+-----+---------+-------+
                                            | clientip | char(15)         | NO   | PRI | NULL    |       |
                                            | serport  | int(11)          | NO   | PRI | NULL    |       |
                                            | status   | enum('yes','no') | YES  |     | NULL    |       |
                                            +----------+------------------+------+-----+---------+-------+

                                        mysql> insert into db1.t24 values ("1.1.1.1",22,"no");
                                        mysql> insert into db1.t24 values ("1.1.1.1",22,"yes");
                                        ERROR 1062 (23000): Duplicate entry '1.1.1.1-22' for key 'PRIMARY'
                                        mysql> insert into db1.t24 values ("1.1.1.1",80,"no");
                                        mysql> insert into db1.t24 values ("1.1.1.2",80,"yes");
                                        mysql> insert into db1.t24 values ("1.1.1.2",22,"no");

                                        mysql> select * from t24;
                                            +----------+---------+--------+
                                            | clientip | serport | status |
                                            +----------+---------+--------+
                                            | 1.1.1.1  |      22 | no     |
                                            | 1.1.1.1  |      80 | no     |
                                            | 1.1.1.2  |      22 | yes    |
                                            | 1.1.1.2  |      80 | yes    |
                                            +----------+---------+--------+


                                    主键通常与 auto increment(自增长) 连用
                                        mysql> create table db1.t25(
                                        -> id int primary key auto_increment,
                                        -> name char(15),
                                        -> age tinyint,
                                        -> sex enum("boy","girl")
                                        -> );
                                        mysql> desc db1.t25;
                                            +-------+--------------------+------+-----+---------+----------------+
                                            | Field | Type               | Null | Key | Default | Extra          |
                                            +-------+--------------------+------+-----+---------+----------------+
                                            | id    | int(11)            | NO   | PRI | NULL    | auto_increment |
                                            | name  | char(15)           | YES  |     | NULL    |                |
                                            | age   | tinyint(4)         | YES  |     | NULL    |                |
                                            | sex   | enum('boy','girl') | YES  |     | NULL    |                |
                                            +-------+--------------------+------+-----+---------+----------------+

                                        mysql> insert into db1.t25(name,age,sex)values("tencen","25","boy");
                                        mysql> insert into db1.t25(name,age,sex)values("bbbb","25","boy");
                                        mysql> insert into db1.t25(name,age,sex)values("aaa","25","boy");

                                        mysql> select * from t25;
                                            +----+----------+------+------+
                                            | id | name     | age  | sex  |
                                            +----+----------+------+------+
                                            |  1 | tencen   |   25 | boy  |
                                            |  2 | bilibili |   25 | boy  |
                                            |  3 | bilibili |   25 | girl |
                                            |  4 | luceey   |   16 | girl |
                                            +----+----------+------+------+
                                            4 rows in set (0.00 sec)
                                            删除表中的数据,生产环境不能这么干 不然跑路啊.
                                        mysql> delete from t25;
                                                Query OK, 6 rows affected (0.12 sec)

                                        mysql> insert into t25(name,age,sex)values("1080","120","girl");
                                               Query OK, 1 row affected (0.03 sec)
                                               除非给id从新设定为1 ,否则依然按照以前的值自加一s
                                        mysql> select * from t25;
                                            +----+------+------+------+
                                            | id | name | age  | sex  |
                                            +----+------+------+------+
                                            |  7 | 1080 |  120 | girl |
                                            +----+------+------+------+
                            2.3 外键
                                    作用:限制给字段赋值
                                        使得字段值在另一个表字段值范围内选择
                                    规则:
                                         表的存储引擎必须是innodb (之后会讲)
                                         字段类型要一致
                                         被参考字段必须要是索引类型的一种(通常为primary key)

                                         mysql> show create table db3.user \G; 可以查看到表引擎
                                    命令格式:
                                            create table 库.表1(
                                                字段列表,
                                                foreign key(字段名) references 表名2(字段名)
                                                ###指定外键 ,,,reference 后的表2代表被参考的表
                                                ###foreign 后的是需要参考表中的字段;;;;   也就是表1中字段   参考  表2中字段
                                                on update cascade  ###同步增加
                                                on delete cascade  ###同步删除
                                                )engine=innodb;
                                            创建外键
                                    eg:
                                                create table db1.yg(
                                                yg_id int primary key auto_increment,
                                                name char(15)
                                                )engine=innodb;

                                                insert into db1.yg(name)values("bob");
                                                insert into db1.yg(name)values("luci");
                                                insert into db1.yg(name)values("cd");


                                                mysql> select * from yg;
                                                        +-------+------+
                                                        | yg_id | name |
                                                        +-------+------+
                                                        |     1 | bob  |
                                                        |     2 | luci |
                                                        |     3 | cd   |
                                                        |     4 | cd   |
                                                        |     5 | bob  |
                                                        +-------+------+

                                                create table db1.gz(
                                                gz_id int,
                                                pay float(7,2),
                                                foreign key(gz_id) references yg(yg_id)  ####创建外键######
                                                on update cascade  ###同步删除
                                                on delete cascade  ###同步增加
                                                )engine=innodb;

                                                mysql> select * from gz;
                                                Empty set (0.00 sec)

                                                mysql> insert into gz values(1,2000);
                                                mysql> insert into gz values(4,200);
                                                mysql> insert into gz values(5,200);
                                                mysql> insert into gz values(6,200);
                                                mysql> insert into gz values(6,500);
                                                mysql> insert into gz values(6,5000);

                                                ##########更新###### 员工id#############
                                                mysql> update db1.yg set yg_id=6 where yg_id=3; ###讲yg_id=3,的换成yg_id=6，两个表中数据自动同步。
                                                Query OK, 1 row affected (0.03 sec)
                                                Rows matched: 1  Changed: 1  Warnings: 0

                                                mysql> select * from gz;
                                                +-------+---------+
                                                | gz_id | pay     |
                                                +-------+---------+
                                                |     4 |  200.00 |
                                                |     5 |  200.00 |
                                                |     6 |  200.00 |
                                                |     6 |  500.00 |
                                                |     6 | 5000.00 |
                                                |     1 | 2000.00 |
                                                +-------+---------+
                                                6 rows in set (0.00 sec)

                                                #########删除id=6 的 员工  gz 表中 也会消失 ##########

                                                mysql> delete from db1.yg where yg_id=6;
                                                Query OK, 1 row affected (0.05 sec)

                                                mysql> select * from gz;
                                                +-------+---------+
                                                | gz_id | pay     |
                                                +-------+---------+
                                                |     4 |  200.00 |
                                                |     5 |  200.00 |
                                                |     1 | 2000.00 |
                                                +-------+---------+
                                                3 rows in set (0.00 sec)

                                        mysql> delete from gz;

                                        mysql> alter table gz add primary key(gz_id);
                                            Query OK, 0 rows affected (0.43 sec)
                                            Records: 0  Duplicates: 0  Warnings: 0

                                            mysql> desc gz;
                                            +-------+------------+------+-----+---------+-------+
                                            | Field | Type       | Null | Key | Default | Extra |
                                            +-------+------------+------+-----+---------+-------+
                                            | gz_id | int(11)    | NO   | PRI | NULL    |       |
                                            | pay   | float(7,2) | YES  |     | NULL    |       |
                                            +-------+------------+------+-----+---------+-------+
                                            2 rows in set (0.00 sec)

                                        mysql> insert into gz values(5,200);
                                            ERROR 1062 (23000): Duplicate entry '5' for key 'PRIMARY'
                                        mysql> insert into gz values(null,200);
                                            ERROR 1048 (23000): Column 'gz_id' cannot be null
                                        mysql> insert into gz values(1,20z00);
                                            ERROR 1054 (42S22): Unknown column '20z00' in 'field list'
                                        mysql> insert into gz values(1,2000);
                                            Query OK, 1 row affected (0.02 sec)
                                            mysql> select * from gz;
                                            +-------+---------+
                                            | gz_id | pay     |
                                            +-------+---------+
                                            |     1 | 2000.00 |
                                            |     5 |  200.00 |
                                            +-------+---------+

                                    删除外键:
                                            show create table db1.gz\G;
                                            alter table db1.gz drop foreign key gz_ibfk_1;

                            在已有的表中添加外键 主键  自加(auto_increment)都是可以的 但是建立外键时需要数据匹配.

                                    ####向已有的表中添加外键#####
                                   alter table db1.gz
                                   add
                                   foreign key(gz_id) references db1.yg(yg_id)
                                   on update cascade on delete cascade
                                   engine=innodb;
                                   ####向已有表的中添加主键####
                                   alter table db1.yg
                                   modify
                                   yg_id int primary key auto_increment;



       DAY03 数据导入导出
            修改搜索路径
                mysql> show variables like "secure_file_priv";
                 默认路径 : /var/lib/mysql-files/
                 修改配置文件 :
                            [root@DBA ~]# mkdir /myload
                            [root@DBA ~]# chown mysql /myload
                            [root@DBA ~]# vim /etc/my.cnf

                                secure_file_priv="/myload"

                 重启服务:    systemctl restart mysqld
                 进入数据库查询位置是否修改:
                            mysql> show variables like "secure_file_priv";
            数据导入
                    默认只有root才能导入数据
                    建表
                    导入
                  注意事项:
                        字段分隔符要和文件一致
                        表字段类型和字段个数要和文件匹配
                        导入数据时指定文件的绝对路径
                  步骤:命令格式

                        mysql>load data infile "目录/文件"
                        into table库名.表名
                        fields terminated by "分隔符" #### 列
                        lines terminated by "\n";    #### 行


                  eg:
                        前面还要 创建文件夹 修改配置文件 重启服务
                    mysql   > load data infile "/myload/passwd" into table db3.usr fields terminated by ":" lines terminated by "\n";

            数据导出
                   作用:把表纪录存储到系统文件里
                   注意:导出数据有sql语句决定
                        导出的是表记录,不包括字段名
                        自动创建存储数据文件
                        存储数据文件,具有唯一性
                        注意导出文件是目录必须与secure_file_priv 目录一致(也就是说只能在这里导出)
                   命令:
                       1)select命令 into outfile "目录名/文件名";  ### 不指定 分隔符时 默认 分别为 \t  \n
                       2)select命令 into outfile "目录名/文件名"
                         fields terminated by "分割符"; ####指定列分隔符
                       3)select命令 into outfile "目录名/文件名"
                         fields terminated by "分割符"
                         lines terminated by "\n"  ####指定行分割符号
                   eg:
                       select * from db1.t23 into outfile "/myload/t23";
                       select * from db3.usr where id<=3 into outfile "/myload/user2.txt";

            表管理记录 (db3.usr)

                1.添加记录
                    命令格式
                    注意事项:
                            字段值与字段类型匹配
                            字符类型的字段 要用 ""括起来
                            依次给所有字段赋值时,字段名可省略
                            只给部分字段赋值时,必须明确对应字段名称
                            没有赋值的字段使用默认值,或自增长
                       添加一条记录给所有字段可以省略
                       insert into 表名 values(字段值列表);

                       mysql> insert into usr values(22,"lc","x",2000,2000,"test user","/home/bob","/bin/bash")

                       添加n行,给所有列赋值
                       insert into 表名 values(字段值列表1),(字段值列表2);

                       添加一条记录,给指定字段赋值
                       insert into 表名(字段名列表) values(字段值列表);

                       添加N条记录,给指定字段赋值
                       insert into 表名(字段名列表) values(字段值列表1),(字段值列表2),(字段值列表3);

                查看记录
                    查看记录注意:
                        * 表示查询所有字段
                        查看当前库表记录时库名可省略
                        字段列表决定显示列个数
                        条件决定显示行的个数
                    查看所有
                            select * from 库名.表名;
                    条件查询
                           select 字段1,字段N from 库名.表名 where 条件表达式;
                修改记录
                    注意:字段值与字段类型匹配
                        对于字符类型,值使用""起来
                        若不使用where限定条件,会更新所有记录字段值
                        限定条件,只更新匹配条件的记录字段的值
                    条件修改
                       update 表名 set 字段名=值,字段名=值,字段名=值,... where 条件;

                    修改所有
                       update 表名 set 字段名=值,字段名=值,字段名=值,... ;


                删除记录
                    注意: 不添加条件删除表中所有
                    条件删除
                        delete  from 库名.表名 where 条件表达式;
                    删除所有
                        delete  from 库名.表名 ;


            匹配条件
               基本匹配条件(适用于select \ update \ delete)

                    数值比较   > < >= <= = !=
                        符号两边要求是数值类型
                        eg
                            select * from usr where id<=6;
                            select * from usr where uid=gid;

                    字符比较
                        =   !=  is null  is not null
                        eg:
                            select name,uid,gid from usr where uid=gid;
                            select from usr where name is null;

                    范围内比较
                         in       not in      between ...  and ....
                         eg:
                            select name from usr where name in ("root","adm","mysql");
                            select name,uid from user where uid in (3,5,7,9);
                            select name,shell from usr where shell not in ("/bin/bash","/sbin/nologin");
                            select name uid from usr where uid between 50 and 100;
                    逻辑比较
                        逻辑与  and  && (多个判断条件同时成立)
                        逻辑或  or   || (多个判断条件,某个条件成立 )
                        逻辑非  not   !
                        eg:
                            select * from usr where name="root" and uid=1 and shell="abc";
                            select * from usr where name="root" && uid=1 && shell="abc";

                    空\非空
                        is null / is not null
                        eg:
                            select id from user where shell is null;
                            select name from usr where shell is not null;
                    去掉重复数据
                            distinct
                            select distinct shell from usr where uid>10;
                            select distinct shell from usr where uid>=10;
                            select distinct shell from usr;
               高级匹配条件(适用于select \ update \ delete)
                    模糊查询
                                              _ 表示一个
                                              % 表示0-n个字符

                        select name from usr where name like "____"; ##匹配任意四个字符 ,这里起始是四个_
                        select name from usr where name like "_%_"; ##匹配任意字符
                        select name from usr where name like "a%";  ##以a开头
                        select name from usr where name like "%a%"; ##必须包含a


                    正则匹配
                        语法: where 字段号 regexp '正则表达式';
                        正则符号:^ $ [] | *
                        select name from usr where name regexp  '^r|y$'; ### r开头 或者 y 结尾
                        select name from usr where name regexp  '^r.*y$';  ### .* 任意字符的任意次数, .任意字符 *前一个字符的任意次数
                        select name,uid from usr where uid regexp  '^....$'; ###四位数字
                        insert into usr(name)values("yaya9"),("7yaya"),("ya8ya");
                        select name,uid from usr where uid regexp  '[0-9]';
                    四则计算
                     + - * /
                     select name,uid,gid,uid+gid sum from usr where name="bin";
                     select name,uid,gid, uid+gid sum from usr; ###将所有的uid和gid相加
                     select name,uid,gid,(uid+gid)/2 ava from usr where name="root";
                         +------+------+------+--------+
                        | name | uid  | gid  | ava    |
                        +------+------+------+--------+
                        | root |    0 |    1 | 0.5000 |
                        +------+------+------+--------+

                     update usr set gid=gid+1; ### 每一个gid+1

                     alter table usr add age tinyint unsigned default 19 after name;
                     select name,age, 2019-age your_age from usr where name="root";
                        +------+------+----------+
                        | name | age  | your_age |
                        +------+------+----------+
                        | root |   19 |     2000 |
                        +------+------+----------+

               操作查询结果(适用于select)

                     select count(字段名) from usr; 求字段值的个数
                     select min(字段名) from usr;   求字段值的最小值
                     select avg(字段名) from usr;   求字段值的平均值
                     select sum(字段名) from usr;   求字段值的总和
                     select max(字段名) from usr;   求字段值的最大值
                     eg:
                         统计表中所有的行数
                         select count(*) from usr;
                         统计uid的 平均数
                         select avg(uid) from usr;


                     查询结果排序

                         SQL查询 order by 字段名 [asc|desc];
                         -asc 升序列 小--->大  ###默认
                         -desc 降序列 大-->小
                         eg:

                            升序排
                            select name,uid from usr where uid>=10 and uid<=500 order by uid; ##默认省略asc
                                    +-----------------+------+
                                    | name            | uid  |
                                    +-----------------+------+
                                    | operator        |   11 |
                                    | games           |   12 |
                                    | ftp             |   14 |

                            降序排
                            select name,uid from usr where uid>=10 and uid<=500 order by uid desc;
                                    +-----------------+------+
                                    | name            | uid  |
                                    +-----------------+------+
                                    | systemd-network |  192 |
                                    | nobody          |   99 |
                                    | dbus            |   81 |
                                    | sshd            |   74 |

                     查询分组
                        SQL查询 group by 字段名;
                        eg:
                            select shell from usr group by shell;
                            select shell from usr where uid<=1000 group by shell;
                            select gid from usr group by gid;
                            mysql> select shell,count(shell)from usr group by shell;
                            +----------------+--------------+
                            | shell          | count(shell) |
                            +----------------+--------------+
                            | NULL           |            0 |
                            | /bin/bash      |            5 |
                            | /bin/false     |            1 |

                     查询结果过滤
                            SQL查询 having 条件;
                       eg:
                        select name from usr where id<20 having name="adm";
                        +------+
                        | name |
                        +------+
                        | adm  |
                        +------+
                     限制查询结果的查询行数
                            SQL查询 limit 数字; ##显示查询结果前多少条记录
                            SQL查询 limit 数字1,数字2; ###显示指定范围内的查询记录
                            数字1 起始行(0表示第一行)
                            数字2 总行数

                            eg:
                                select id,name,password from usr where id<=20; ###默认全部输出
                                select id,name,password from usr where id<=20 limit 10;
                                select id,name,password from usr where id<=20 limit 5;
                                select id,name,password from usr where id<=20 limit 0,2; ###从第一行开始输出 共输出两行
                                select id,name,password from usr where id<=20 limit 1,3; ###从第二行开始输出 共输出三行

            常见的mysql 管理工具

                     phpMyAdmin  浏览器端      需要LNMP支持  开源 免费

                     yum -y install httpd php-mysql php
                     systemctl restart httpd.service
                     systemctl enable httpd.service
                     tar -xf phpMyAdmin-2.11.11-all-languages.tar.gz
                     ls
                     mv phpMyAdmin-2.11.11-all-languages phpMyAdmin
                     cp phpMyAdmin /var/www/html/
                     cd /var/www/html/phpMyAdmin
                     cp config.sample.inc.php config.inc.php
                     vim config.inc.php
                     31  $cfg['blowfish_secret'] = 'plj123';  /* YOU MUST FILL IN THIS FOR COOKIE AUTH! */      ### cookie 认证参数  随便修改为什么
                     17  $cfg['Servers'][$i]['host'] = 'localhost'; ###数据库服务器地址
                     systemctl restart httpd.service

                     访问软件管理数据库服务
                     http://192.168.4.50/phpmyadmin
                     用户名 root
                     密  码 tarena (之前设置的数据可密码)



                     ##########数据库管理员必备知识 (必须会)4, 5################
       DAY04

            用户授权
                1.1 用户授权: 在数据库服务器上添加新用户授权 默认允许数据库管理员本机登录
                    远程访问数据库服务器
                    mysql -h192.168.4.50 -ubob -p123aaa...
                1.2 命令
                    grant 权限列表 on 库名 to 用户名@"客户端地址" identified by "密码"
                    with grant option; ###有授权权限(使该用户可以使用授权命令).可选项

                    权限列表:
                        all //所有权限
                        usage //无权限
                        select,update,insert  //个别权限
                        select,update(字段1,....字段N)  //指定字段权限,只对指定字段有权限
                    库名:
                        *.* //所有数据库
                        库名.* //一个库
                        库名.表名 //一张表
                    用户名:
                        授权时自定义,有标示性
                        存储在mysql库中的user中
                    客户端地址:
                        %           //表示 全部主机
                        192.168.4.% //一个网段
                        192.168.4.253 //一个ip
                        localhost  //数据库服务器主机

                        授权用户
                    eg: mysql> grant all on db4.* to yaya@"%" identified by "123aaa.."

                1.3 相关命令

                    登录用户使用:
                        select user();  ####显示登录用户以及客户端地址

                        show grants;    #####用户显示自身访问权限

                        show grants for #####管理员查看已有授权用户权限, 注意这里 grants 里的s 不要漏写
                        用户名@"客户端地址";

                        set password=   #####授权用户修改连接密码 修改数据库密码
                        password("密码");

                        set password for #####管理员重置用户连接密码
                        用户名@"客户端地址"=
                        password("密码");

                        drop user
                        用户名@"客户端地址";  删除授权用户(必须有管理员权限)

                        grant all on *.* to root@"%" identified by "123qqq...A";
                        *.* 所有库的所有表, 指定某个也可以用  库.表 ,在某个库下对整个库授权授权时,可以不用写 .*,
                        添加用户授权
                1.4 授权库

                    mysql库              记录授权信息
                    user表               记录已有的授权用户
                    db表	                 记录已有的授权用户对数据库的访问权限
                    tables_priv          记录已有的授权用户对表的访问权限
                    columns_priv         记录已有的授权用户对字段的访问权限

                        desc mysql.user; 关注 Host(主机地址) User(用户名) 字段
                        select hosts,name from mysql.user;
                        show grants for user@"host";

                        desc mysql.db;   关注 db字段
                        select host,user,db from mysql.db;
                        select * from mysql.db where db="db3" and user="admin2" and host="localhost" \G;
                        show grants for admin2@"localhost"; ###这条命令结果是上条命令结果的另一种表示
                        ####修改表字段
                        update mysql.db set Drop_priv="Y" where host="localhost" and db="db3" and user="admin2";
                        flush privileges; ####重新加载表记录

                        desc tables_priv;
                        select * from mysql.tables_priv;
                        select host,user,db,Table_name from tables_priv;
                        select * from tables_priv where Table_name="user" and db="db3"\G;  ###查看用户对表有什么权限

                        desc columns_priv;
                        select * from columns_priv;
                        select * from columns_priv;
                        [root@DBA ~]# mysql -uadmin3 -p123qqq...A
                        show grants;
                        select * from db3.user
                        update db3.user set age=18;
                        erro
                        update db3.user set passwd="H";
                        SELECT * FROM db3.user;

                1.5 撤销权限
                    回收授权用户的权限
                    命令:
                        revoke 权限列表 on 库名.表名 from 用户名@"客户端地址";
                    eg:
                        revoke insert,drop on db3.user from admin3@"localhost";
                        show grants for admin3@"localhost";
                        revoke all on *.* from mydba@"%"; ##撤销所有权限
                        select user,host from mysql.user ##查看所有的授权用户
                        show grants for mydba@"%";       ##查看指定用户的权限
                        revoke grant  option on *.* from mydba@"%"; ##撤销权限
                        show grants for mydba@"%";     ##查看权限

                1.6 数据库root密码
                    恢复数据库root密码
                        你需要知道 系统的root 密码
                        方法:
                            1.停止mysql服务程序
                                systemctl stop mysqld.service

                            2.跳过授权启动mysql服务程序
                                vim /etc/my.cnf
                                skip-grant-tables
                                #validate_password_policy=0   ####密码策略

                                #validate_password_length=6   ####密码长度
                                ]# mysql  ###跳过了密码验证,不输入密码 直接进入数据库
                            3.修改数据库ROOT密码
                                authentication_string 为mysql.user 中的字段;作用是储存 用户密码(授权用户)
                                mysql> update mysql.user set authentication_string=password("123qqq...A") where user="root" and host="localhost";
                                Query OK, 1 row affected, 1 warning (0.02 sec)
                                Rows matched: 1  Changed: 1  Warnings: 1

                                mysql> flush privileges; ###刷新配置文件
                                 #skip-grant-tables
                                 validate_password_policy=0

                                 validate_password_length=6
                            4.以正常的方式重启mysql
                                systemctl restart mysqld.service
                                mysql -uroot -p123qqq...A

                    重置数据库root密码
                    mysqladmin -uroot -p password "tarena" ###新密码
                    Enter password:                        ###旧密码
            备份
                2.1数据备份方式
                    物理备份
                        冷备份  cp tar...
                            先停止mysql服务,恢复后重启
                        备份    eg:
                                 cp -r /var/lib/mysql 备份目录/mysql.bak  ### -r 包含文件夹复制
                                 tar -zcvf /root/mysql.tar.gz  /var/lib/mysql
                        恢复    eg:
                                 rm -rf/var/lib/mysql
                                 cp -r 备份目录/mysql.bak /var/lib/mysql
                                 tar -zxvf /root/mysql.tar.gz -C /var/lib/mysql/
                                 chown -R mysql:mysql /var/lib/mysql   ###修改属主属组,由于cp命令 由root执行,所以拷贝过来后属主 为root(不修改属主,属组) ,mysql无法读取
                    逻辑备份
                        完全备份
                            完全备份备份所有数据
                            备份命令:
                                 mysqldump //备份命令
                                 ]# mysqldump -uroot -p密码 库名 > 目录/xxx.sql(目录自己创建)


                                    备份时库名的表示方式  --all-database 或 -A //所有库
                                    数据库名                                 //单个
                                    数据库名 表名                             //单张表, 注意这里没有 .  只是空格
                                    -B 数据库1 数据库2                        //多个库
                                 scp 给其他服务器
                            恢复数据命令
                                完全恢复
                                ]# mysql -uroot -p 密码 [库名] < 目录/xxx.sql

                        增量备份
                            备份上次备份后产生的所有数据  ###和上一次备份比较
                            核心: 使用mysql的binlog日志 进行恢复(重要)
                            1.使用binlog日志恢复数据
                                binlog日志是什么:
                                        1)二进制文件
                                        2)mysql服务日志文件的一种
                                        3)记录出查询之外的sql命令
                                        4)可用于数据备份和恢复
                                        5)配置mysql主从同步的必要条件
                                查看日志格式

                                    mysql> show variables like "%binlog%";
                                    mysql>show variables like "binlog_format";

                                启用日志:
                                        文件类型:
                                        server_id=数字 1-255
                                         log-bin[=目录/文件名]
                                         max_binlog_size=数值m ##默认1G,超过1G后生成新文件
                                         主机名-bin.index 索引文件
                                         主机名-bin.00000001 第一个二进制文件
                                         主机名-bin.00000002 第二个二进制文件
                                        ###############################
                                启用:    vim /etc/my.cnf
                                        [mysql]
                                        log-bin     //启用binlog日志
                                        server_id   //指定id值 唯一
                                手动生成 binlog文件
                                    执行后不管文件是否达到设定的默认值,都会生成新的binlog文件
                                    1.systemctl restart mysqld  ###生产环境 不要用第一个.用2,3
                                    2.mysql> flush logs;
                                        或 ]# mysql -uroot -p密码 -e 'flush logs'
                                        备份数据库时 也可以 重新生成 日志文件
                                    3.mysqldump -uroot -p密码 --flush-logs 库 > /xxx.sql
                                清除日志
                                    清除所有
                                    mysql> reset master;
                                    清除指定编号之前的binlog文件
                                    mysql> purge master logs to "DBA-bin.000004";  ###这里 DBA 是主机名 000004 是文件数(这里是指第四个文件)
                                启用日志时自定义日志文件存储目录和文件名
                                    vim /etc/my.cnf
                                    #############将log_bin 修改为如下 dba50 为文件名###########

                                    log_bin=/mylog/dba50
                                    [root@DBA ~]# mkdir /mylog/
                                    ###################将属主修改为mysql,否则mysql无法读取############3

                                    [root@DBA ~]# chown mysql /mylog
                                    [root@DBA ~]# systemctl restart mysqld
                                    [root@DBA ~]# ls /mylog/*
                                    /mylog/dba50.000001  /mylog/dba50.index
                                    ############显示日志信息##########
                                    mysql>show master status;

                            2.恢复数据 (使用binlog日志恢复)
                                日志格式 (日志如何记录多条命令)
                                    查看日志当前就格式
                                    mysql> show variables like "binlog_format";
                                    ######修改日志格式

                                    [root@DBA ~]# vim /etc/my.cnf
                                    ####添加如下

                                    binlog_format="mixed"   三种记录方式 :statement 报表模式
                                                                        row       行模式
                                                                        mixed     混合模式
                                分析日志
                                    日志如何区分记录多条SQL命令
                                        偏移量
                                        时间点

                                    查看日志内容:
                                       ]# mysqlbinlog [选项] binlog文件
                                        选项:
                                        --start-datetime="yyyy-mm-dd hh:mm:ss"   ###起始时间
                                        --stop-datetime="yyyy-mm-dd hh:mm:ss"    ###结束时间
                                        --start-position=数字                     ###起始偏移量
                                        --stop-position=数字                      ###结束偏移量
                                        基本思路: 使用mysqlbinlog 提取历史mysql 操作日志
                                                 通过mysql 命令执行
                                    命令格式:
                                            mysqlbinlog 日志文件 | mysql -uroot -p密码

                                            日志文件默认位置 : /var/lib/mysql/  但文件位置可以在mysql配置文件修改 /etc/my.cnf 中log_bin=/mylog 字段

                                            //仅执行指定范围内记录的sql命令
                                            ]# mysqlbinlog --start-position=293  --stop-position=958  \

                                eg:使用编号为1的日志恢复数据
                                   mysqlbinlog /tmp/dba50.000001 |mysql -uroot -ptarena
                                   select * from usr;


                        差异备份
                            备份完全备份后,所有新产生的数据 ###只能和上次完全备份,比较



   DAY05  备份
        innobackupex

        查看创建信息
        mysql> show create table db3.user \G; 可以查看到表引擎
        查看软件支持的数据引擎
        mysql> show engines; 注意这里的 s
        常用的mysql备份工具
            物理备份的缺点:
                跨平台差
                备份时间长.冗余备份 浪费存储空间
            mysqldump 备份缺点
                效率低 备份还原慢 锁标
                备份中,数据插入和更新操作被阻塞
        PERCONA
            Xtra Back
                在线热备份工具
                备份过程不锁表 适合生产环境
                专业组织PERCONA 提供 (盖井mysql分支)
            主要包含两个组件
                xtrabackup: c程序支持Innodb/Xtradb
                innobackupex:以per脚本封装的xtrabackup.支持myISAM

            install
                需要依赖包:libev-4.15-1.el6.rf.x86_64.rpm
                安装:
                    yum -y install /root/percona-xtrabackup-24-2.4.7-1.el7.x86_64.rpm
                查看安装列表
                    [root@DBA ~]# rpm -ql percona-xtrabackup-24
                    /usr/bin/innobackupex   //备份innodb \ xtradb \ myisam 引擎表
                    /usr/bin/xtrabackup     //备份innodb \ xtradb 引擎表
                    常用选项:
                            --host        主机名
                            --user        用户名
                            --port        端口
                            --password
                            --databases   --databases="库1 库2" / ---databases="库.表" 不加库则备份全部
                            --no-timestamp  不使用日期时间命名备份文件储存的子目录
                            --redo-only     日志合并
                            --apply-log     准备恢复数据
                            --copy-back     拷贝数据
                            --incremental 目录名               增量备份
                            --incremental-basedir=目录名       增量备份时,指定上一次备份书记的存储目录名
                            --incremental-dir=目录名           准备恢复数据时,指定增量备份数据存储的目录名
                            --export         导出表信息 frm
                            import           导入表空间  idb
                命令:
                    完全备份
                        ]# innobackupex --user 用户名 --password 密码 全备份目录名 --no-timestamp
                    完全恢复
                        ]# innobackupex --apply-log 全备份目录 //准备恢复数据
                        ]# innobackupex --copy-bak 全备份目录  //恢复数据
                    增量备份
                        ]# innobackupex  --user 用户名 --password 密码 --incremental 增量备份目录 --incremental-basedir=全备份目录 --no-timestamp
                    增量恢复
                        ]# innobackupex  --apply-log --redo-only 全备份目录--incremental-dir=增量备份目录 //准备恢复
                        ]# innobackupex --copy-back 全备份目录 //恢复数据


        innobackupex 备份与恢复
            完全备份
                   192.168.4.50
                   ]# innobackupex --user root --password tarena /allback
                   ]# ls /allback/
                   ]# scp -r /allback/ root@192.168.4.51:/root/
            完全恢复
                    4.51
                    安装 软件
                    ]# innobackupex --apply-log allback/2019-06-14_14-56-25/
                    ]# innobackupex --copy-back allback/2019-06-14_14-56-25/
                    ]# chown -R mysql:mysql /var/lib/mysql  #### 由于是root执行的 命令所以 需要修改整个文件夹 属主 属组
                    ]# systemctl restart mysqld


            部分恢复
                删除表空间
                    mysql> alter table 库.表 discard tablespace;
                导出表信息
                    ]# innobackupex --apply-log --export /allback/2019-06-14_14-56-25/
                拷贝表信息文件到数据库目录
                    ]# cp /allback/2019-06-14_14-56-25/db3/usr.{cfg,ibd,exp} /var/lib/mysql/db3
                修改表信息文件所有者改为mysql
                    ]# chown mysql:mysql /var/lib/mysql/db3/usr.*
                导入表空间
                    mysql> alter table 库.表 import tablespace;
                删除数据库目录下的表信息文件
                      308  rm -rf /var/lib/mysql/db3/usr.exp
                      309  rm -rf /var/lib/mysql/db3/usr.cfg

                查看表记录
                    mysql>select * from 库.表;

            增量备份
                192.168.4.50

                增量备份前需要一个全备份,在做增量
                ]# innobackupex --user root --password tarena /fullback  //全备份
                                                                         //创建增量备份
                ]# innobackupex  --user root --password tarena --incremental newdi1 --incremental-basedir=/fullback --no-timestamp
                ]# innobackupex  --user root --password tarena --incremental newdi2 --incremental-basedir=/fullback --no-timestamp




            增量恢复
                192.168.4.51

                将fullback 和 newdir1 newdir2 拷贝到 51

                ]# systemctl stop mysqld.service
                ]# rm -rf /var/lib/mysql/*
                ]# innobackupex --apply-log --redo-only /root/fullback/  //准备备份
                ]# innobackupex --apply-log --redo-only /root/fullback/ --incremental-dir=/root/newdir1   //合并备份
                ]# innobackupex --apply-log --redo-only /root/fullback/ --incremental-dir=/root/newdir2   //合并备份
                ]# innobackupex --copy-back /root/fullback/   //恢复数据
                ]# chown -R mysql:mysql /var/lib/mysql    //赋予权限
                ]# systemctl restart mysqld //重启服务

                ]# mysql -uroot -ptarena



   进阶
       DAY06
            max-connections MySQL服务的最大并发连接数

            mysql 数据库主从同步
                什么是: 实现数据自动同步
                    主服务器:接受客户端访问链接
                    从服务器:自动同步主服务器数据


                拓扑: 主: 192.168.4.51
                     从:  4.52
                     客户端: 4.50
                原理:
                    Master
                          必须开启 binlog日志
                    Slave
                          i/o 线程 : 负责读取master的binlog,存储到relay-log(中继日志文件 )
                          sql 线程 : 执行relay-log 中的 sql语句 保证 数据与主服务器一致
                          线程是进程的最小运行单位


                    如何将配置完成的主从结构恢复到无主从结构的状态

                        删除主服务器中的 /var/lib/mysql/
                          master.info
                          relay-log.info
                          主机名-relay-bin.xxxx
                          主机名-relay-bin.index
                          重启服务即可恢复 没有主从的状态

                构建方案:
                    配置主库
                          51
                        启动binlog日志\授权用户\确保与主服数据库一致
                            启动binlog日志
                                vim /etc/my.cnf
                                    添加如下
                                    log-bin=db51 //启动binlog
                                    server_id=51 //指定server id  //该id唯一
                            授权用户
                                不需要给予全部权限 只需要给予 replication和slave 就好
                                mysql> grant replication slave on *.* to repluser@'%' identified by "123qqq...A";

                        确保与主服数据库一致
                            4.51
                                生成 备份文件
                                ]#  mysqldump -uroot -ptarena --master-data -A > /a.sql
                                将文件传递给52
                                ]# scp /db3.sql /a.sql  root@192.168.4.52:/root/
                            4.52
                                给52中导入51的数据
                                ]# mysql -uroot -ptarena < /root/a.sql

                    配置从服务器
                        设置server_id\指定主库信息\启动slave程序
                            设置server_id
                                4.52
                                server id 区分主从
                                    vim /etc/my.cnf
                                        添加如下
                                        server_id=52
                            指定主库信息
                                需要先确认 主从数据库文件是否一致
                                vim a.sql
                                    22行
                                    找到 `CHANGE MASTER TO MASTER_LOG_FILE='db51.000001', MASTER_LOG_POS=441;`
                                    如果期间 主库重启会导致主库的binlog日志改变,那么这里填的数据将会按照新的binlog日志数据填写
                                mysql> change master to master_host="192.168.4.51",
                                        -> master_user="repluser",master_password="123qqq...A",
                                        -> master_log_file="db51.000001",master_log_pos=441;
                                        //确保主服务器使用的binlog日志与你在这里填写的相同
                                        填入 master|_log_file(binlog日志) 和 master_log_pos(偏移量)
                                        核心:从库链接到主库,按照主库的binlog日志执行,完成后两个数据库就同步完成了.
                            启动slave程序

                                mysql> start slave; //启动slave
                                mysql> show slave status\G;  //查看状态
                                    检查如下是否为yes, host 是否正确
                                    主要抓住两个线程 io线程 sql线程
                                        Slave_IO_Running: Yes
                                        Slave_SQL_Running: Yes

                                    stop slave 停止slave服务

                            从服务器的配置文件
                                位置 /var/lib/mysql/
                                master.info                   主库信息
                                relay-log.info                中继日志信息
                                主机名-relay-bin.xxxx          中继日志
                                主机名-relay-bin.index         索引文件

                            启动slave失败解决方法
                                最简单的方法:
                                    把从库数据可恢复为独立的数据服务器,重新配置
                                    rm -rf master.info relay-log.info host52-relay-bin.*c
                                    systemctl restart mysqld
                                    重新配置主库信息
                                     查看上面笔记



                            测试配置:
                                51的数据库管理员在本机创建新的数据库和表

                                    mysql> create table user4(name char(15));
                                    mysql> insert into user4 values("chihiro");
                                    Query OK, 1 row affected (0.10 sec)

                                    mysql> insert into user4 values("chihiro2");
                                    Query OK, 1 row affected (0.12 sec)

                                    mysql> insert into user4 values("chihiro22");
                                52数据库管理员在本机查看
                                    mysql> select * from db3.user4;
            主从同步模式
                结构类型:
                    一主多从
                    主从从   一个主 一个中继从库(开启级联复制) 一个从库
                    主主


                配置主服务器53
                    ]# vim /etc/my.cnf
                       [mysqld]
                        server_id=53
                        log-bin=db53
                       :wq

                    ]# systemctl  restart mysqld

                    ]# mysql -uroot -p密码
                    mysql> grant replication slave on  *.*
                        to repluser@"%" identified by "123qqq...A";

                    mysql> show  master status;
                    +-------------+----------+--------------+------------------+-------------------+
                    | File        | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
                    +-------------+----------+--------------+------------------+-------------------+
                    | db53.000001 |      441 |              |                  |                   |
                    +-------------+----------+--------------+------------------+-------------------+

                    配置从服务器54

                    ]# vim /etc/my.cnf
                        [mysqld]
                        server_id=54
                        log-bin=db54
                        log_slave_updates  # 允许级联复制
                    :wq
                    ]# systemctl  restart mysqld

                    ]# mysql -uroot -p密码
                    mysql> grant replication slave on  *.*  to  repluser2@"%" identified by "123qqq...A";
                    Query OK, 0 rows affected, 1 warning (0.02 sec)

                    mysql> show master status;
                    +-------------+----------+--------------+------------------+-------------------+
                    | File        | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
                    +-------------+----------+--------------+------------------+-------------------+
                    | db54.000001 |      442 |              |                  |                   |
                    +-------------+----------+--------------+------------------+-------------------+
                    1 row in set (0.00 sec)

                    mysql> change master to  master_host="192.168.4.53",master_user="repluser",
                        -> master_password="123qqq...A",master_log_file="db53.000001",master_log_pos=441;
                    Query OK, 0 rows affected, 2 warnings (0.22 sec)

                    mysql> start slave;
                    Query OK, 0 rows affected (0.03 sec)

                    mysql> show slave status\G;
                     Slave_IO_Running: Yes
                            Slave_SQL_Running: Yes
                    Master_Host: 192.168.4.53

                配置从服务器55
                    ]# vim /etc/my.cnf
                        [mysqld]
                        server_id=55
                    :wq

                    ]# systemctl  restart mysqld
                    ]# mysql  -uroot -p密码
                    mysql> change master to  master_host="192.168.4.54",master_user="repluser2",
                    master_password="123qqq...A",master_log_file="db54.000001",master_log_pos=442;

                    mysql> start slave ;
                    mysql> show slave status\G;
                        Master_Host: 192.168.4.54
                        Slave_IO_Running: Yes
                            Slave_SQL_Running: Yes

                测试配置
                        在主服务器本机创建新库新表插入记录
                        在2台从服务器本机可以查看到同样的库表及记录

                        53 mysql>
                           create database bbsdb;
                           create table bbsdb.a(id int);
                           insert into bbsdb.a values(99);

                        54/55 mysql>
                           select  * from bbsdb.a;



                配置一主多从结构
                    要求把4.53配置为51的从服务器

                    53配置如下:
                            1.验证主服务器授权用户
                            2.指定server id
                            3.与主库数据一致
                            4.配置slave,指定主服务器信息
                            5.启动slave,查看slave信息

            复制模式
                   模式分类:
                            异步复制\全同步复制模式\半同步复制模式

                       异步:主库执行完一次事物后,立即将结果返回给客户端,并不关心库是否已经接受并处理
                       全同步:当主库执行完事物,却所有从库都执行该事物后才将结果返回客户端
                       半同步复制: 主库执行完成事物,等待至少一个库接收并写入relay log中才将结果返回客户端

                       同步中默认为异步模式
                       修该主和从的复制模式,并且模式需要匹配.

                   配置半同步复制模式
                        主 53 从主 54 从55
                                命令行配置 立刻生效,重启失效,配置文件,重启生效,
                        命令行配置

                                加载模块 (主/从模块)
			                        INSTALL PLUGIN rpl_semi_sync_master  SONAME  'semisync_master.so’;
			                        INSTALL PLUGIN rpl_semi_sync_slave  SONAME  'semisync_slave.so’;
                                启用模块
                                      mysql> SET GLOBAL rpl_semi_sync_master_enabled = 1;
                                      mysql> SET GLOBAL rpl_semi_sync_slave_enabled = 1;
                                查看
                                      mysql> show  variables  like  "rpl_semi_sync_%_enabled";

                                修改主配置文件使其永久有效
                                   ]# vim /etc/my.cnf
                                                  [mysqld]
                                                  //加载模块
                                                  plugin-load=rpl_semi_sync_slave=semisync_slave.so;rpl_semi_sync_master=semisync_master.so //加载模块
                                                  rpl_semi_sync_master_enabled=1  //启用半同步复制模式
                                                  rpl_semi_sync_slave_enabled=1  //启用半同步复制模式
                                               :wq
                                            ]# systemctl restart  mysqld
                                            ]# mysql  -uroot -ptarena
                                            //查看插件是否安装
                                            mysql> SELECT  PLUGIN_NAME, PLUGIN_STATUS FROM INFORMATION_SCHEMA.PLUGINS  WHERE PLUGIN_NAME LIKE '%semi%';

                                            mysql> show  variables  like  "rpl_semi_sync_%_enabled";// 查看 两个插件是否启动


       DAY02

            一.数据库读写分离

                1.1数据读写分离介绍

                1.2数据对读写分离的优点
                    减轻主服务器的工作压力,提高服务器的硬件利用率
                1.3配置数据读写分离
                    程序实现      程序员写代码实现
                    部署服务实现  在客户端部署读写分离
                    (主写从库读)
                1.4拓扑结构
                     master--------------  slave
                     4.51                 4.52
                       |
                      读写
                      mysql代理-----------linux客户机
                      4.57                  4.50
                1.5环境准备
                    配置主从
                        主 : 启动binlog 授权用户 配置server id
                        从 : 配置server id 指定主库信息 启动slave
                    配置ip
                1.6配置代理
                    可以提供代理的软件有许多
                        mysql-procy
                        mycat ...

                        maxscale是其中一种 (数据库读写分离)
                    1.6.1 配置软件
                        yum -y install /root/maxscale-2.1.2-1.rhel.7.x86_64.rpm
                        rpm -ql maxscale //检查 生成文件位置
                    1.6.2 修改代理服务的主配置文件
                        cp /etc/maxscale.cnf /root/ //备份主配置文件
                        /var/log/maxscale/ log存放位置
                        vim /etc/maxscale.cnf
                        [maxscale]
                     10 threads=auto//修改线程数量,多少核给多少个,或者直接auto
                      // 定义两台数据库服务器
                     18 [server1]
                     19 type=server
                     20 address=192.168.4.51
                     21 port=3306
                     22 protocol=MySQLBackend

                     25 [server2]
                     26 type=server
                     27 address=192.168.4.52
                     28 port=3306
                     29 protocol=MySQLBackend
                      //指定监控服务器 ,用户, 密码
                     36 [MySQL Monitor]
                     37 type=monitor
                     38 module=mysqlmon
                     39 servers=server1, server2
                     40 user=maxscalemon
                     41 passwd=123qqq...A
                     42 monitor_interval=10000
                      //注销 read only 部分
                      [Read-Only Service]
                      //读写分离
                     64 [Read-Write Service]
                     65 type=service
                     66 router=readwritesplit
                     67 servers=server1, server2  //注意添加server
                     68 user=maxscalerouter   //路由用户
                     69 passwd=123qqq...A
                     70 max_slave_connections=100%
                      //注销  R-O-L
                     86 #[Read-Only Listener]
                     //查看 RWL 端口 与 管理端口必须不同
                     95 port=4006
                      //指定 管理端口
                     98 [MaxAdmin Listener]
                     102 port=4016


                    1.6.3 配置数据库服务器
                        创建监控用户
                            mysql>grant replication slave, replication client on *.* to maxscalemon@"%" identified by "123qqq...A";

                            REPLICATION SLAVE 常用于建立复制时所需要用到的用户权限(非复制必须权限,单独的设置 slave和 client 都是可以复制的  待验证)，也就是slave server必须被master server授权具有该权限的用户，才能通过该用户复制。
                            REPLICATION CLIENT 不可用于建立复制,但是可以检测权限,用来检测和管理复制账户所需的权限
                            并且这两个功能（复制需要的权限，监视和管理复制账号权限）通常会授权给一个用户

                        创建路由用户
                            mysql> grant select on mysql.* to maxscalerouter@"%" identified by "123qqq...A";

                        这两步可以只在主库上做 因为主从同步 这个操作会在从库上同步完成
                    1.6.4 启动代理服务器
                        maxscale -f 配置文件位置
                        [root@dba57 ~]# maxscale -f /etc/maxscale.cnf
                        不要使用 systemctl start maxscale 这么启动 //否则使用 maxadmin 不能进入 管理界面

                    1.6.5 查看服务状态
                        [root@dba57 ~]# ss -antulp | grep 4016
                        tcp    LISTEN     0      128      :::4016                 :::*                   users:(("maxscale",pid=1869,fd=12))
                        [root@dba57 ~]# ss -antulp | grep 4006
                        tcp    LISTEN     0      128      :::4006                 :::*                   users:(("maxscale",pid=1869,fd=11))
                        [root@dba57 ~]# ls /var/log/maxscale/
                        maxscale.log
                        [root@dba57 ~]# ps -C maxscale
                          PID TTY          TIME CMD
                         1869 ?        00:00:00 maxscale
                        //进入软件查看管理服务
                        [root@dba57 ~]# maxadmin  -uadmin -pmariadb -P4016
                        MaxScale> list servers
                        Servers.
                        -------------------+-----------------+-------+-------------+--------------------
                        Server             | Address         | Port  | Connections | Status
                        -------------------+-----------------+-------+-------------+--------------------
                        server1            | 192.168.4.51    |  3306 |           0 | Master, Running
                        server2            | 192.168.4.52    |  3306 |           0 | Slave, Running
                        -------------------+-----------------+-------+-------------+--------------------
                    1.6.6 测试配置
                        1.在主服务器上添加访问数据链接用户
                            mysql> create databases gamedb;
                            mysql> create table a(id int);
                            mysql> grant select,insert on gamedb.* to yaya66@"%" identified by "123qqq...A";
                        2.客户端链接代理服务57 访问数据
                            [root@DBA ~]# mysql -h192.168.4.57 -uyaya66 -P4006 -p123qqq...A
                            mysql> select * from gamedb.a;
                            Empty set (0.00 sec)

                            mysql> insert into gamedb.a values(0214);
                            Query OK, 1 row affected (0.18 sec)

                            mysql> select * from gamedb.a;
                            +------+
                            | id   |
                            +------+
                            |  214 |
                            +------+
                        3.验证57主机的数据读写分离
                            3.1 在从服务器添加新记录
                                mysql> insert into gamedb.a values(52);
                                Query OK, 1 row affected (0.04 sec)

                                mysql> select * from gamedb.a;
                                +------+
                                | id   |
                                +------+
                                |  214 |
                                |   52 |
                                +------+
                                在主服务器查看记录
                                mysql> select * from gamedb.a;
                                +------+
                                | id   |
                                +------+
                                |  214 |
                                +------+
                            3.2客户端访问57 查看
                                [root@DBA ~]# mysql -h192.168.4.57 -uyaya66 -P4006 -p123qqq...A
                                mysql> select * from gamedb.a;
                                +------+
                                | id   |
                                +------+
                                |  214 |
                                |   52 |




            二.多实例服务

                1.添加配置文件
                    vim /etc/my.cnf
                    [mysqld_multi]
                    mysqld = /usr/local/mysql/bin/mysqld_safe
                    mysqladmin = /usr/local/mysql/bin/mysqladmin
                    user = root
                    [mysqld1]
                    datadir=/dir1
                    port=3307
                    log-error=/dir1/mysqld1.err
                    pid-file=/dir1/mysqld1.pid
                    socket=/dir1/mysqld1.socket
                    [mysqld2]
                    datadir=/dir2
                    port=3308
                    log-error=/dir2/mysqld2.err
                    pid-file=/dir2/mysqld2.pid
                    socket=/dir2/mysqld2.socket

                2.添加PATH

                  PATH=/usr/local/mysql/bin:$PATH
                       /usr/local/mysql/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/usr/local/mysql/bin/
                3.启动服务编号是1 的实例服务
                        ]# /usr/local/mysql/bin/mysqld_multi start 1
                    查看服务信息
                        ]# ls /dir1
                        ]# netstat  -utnlp  | grep  :3307
                    访问服务
                        /usr/local/mysql/bin/mysql -uroot -p'k4R+MAfMUgar' -S /dir1/mysqld1.sock
                        mysql> alter user  root@"localhost" identified by  "123456";
                        mysql> show databases;
                        mysql> exit
                        存储数据 创库 插入数据
                        重新登录
                        /usr/local/mysql/bin/mysql -uroot -p123456 -S /dir1/mysqld1.socket
                        没有设置开机自启

            关于mycat读写分离 请查看 https://www.cnblogs.com/kevingrace/p/9365840.html
                部署:
                    mycat jave-1.8.0-openjdk-devel (会附带安装openjdk)

                    mysql-node1 部署主从复制
                    mysql-node2


                    配置 mycat 节点


                实验还没有做完



       DAY03
            一.数据分片
                分片介绍
                1.垂直分割
                    1.1纵向切分
                        将单个数据库的多个表按照业务分类按照业务类型分类,分散存储到不同数据库
                2.水平切分
                    2.1横向切分
                        按照表中指定字段的分片规则,将表记录按行切分,分散存储到不同的的多个数据库
            二.mycat
                1.介绍
                    mycat是基于java的分布式存储数据库系统中间件,为提高并发环境的分布式存储提供解决方案
                        适合数据大量写入存储
                        支持mayql Oracle Salserver mongodb
                        支持数据读写分离
                        支持数据分片

                        maxscale和mycat的区别：
                            maxscale 只能做读写分离
                            mycat可以读写分离和数据分片

                2.分片规则
                    mycat 支持10 中分片规则
                        枚举 固定分片 约定范围 求模 日期列分 通陪取模 ascii码 编程指定 字符拆分hash 解析 一致性hash
                    不同的分片规则需要有特定的字段名存在
                    通过检查 /usr/local/mycat/conf/schema.xml (<table>中的 值)和 rule.xml(<tableRule> </tableRule>)
                    中相匹配的字段 决定 表中一定要存在的字段

                3.拓扑结构
                                             56                 50
                    ----------------------分片服务器------------客户端
                    |                 |                      |
                    数据库服务器      数据库服务器            数据库服务器
                        53           54                      55
                4.工作工程
                    当mycat收到一个sql命令
                        1)解析SQL命令涉及到的表
                        2)查看对表的配置,如国有分片规则,则获取sql命令里分片字段的值,匹配分片函数,获得分片列表
                        3)将sql语句发往对应的分片服务器执行
                        4)收集处理分片结果,返回结果
                5.部署mycat 服务
                    1)安装软件
                         //这个软件需要java的支持
                         yum -y install java-1.8.0-openjdk
                         tar -xvf Mycat-server-1.6-RELEASE-20161028204710-linux.tar.gz -C /usr/local/
                         软件的目录结构
                            -bin     启动命令
                            -catlet  扩展程序
                            -conf    配置文件 /// txt 结尾的是分片规则算法, server.xml 设置链接账户以及逻辑 (逻辑库文件)
                                            ///schemea.xml 配置数据分片   rules.xml 分片规则
                            -lib    mycat 使用的jar包
                            -logs   mycat启动日志和运行日志
                            -wrapper.log    服务启动日志
                            -mycat.log      记录sql脚本执行后的保存内容


                            若启动服务 不报错 但是启动不了 说明内存不够
                    2)修改配置文件
                       分片规则设置为  枚举 sharding-by-intfile
                        vim /usr/local/mycat/conf/server.xml 保持默认 添加(逻辑库)
                        [root@mycat ~]# sed -i "57,77d" /usr/local/mycat/conf/schema.xml // 删除无用行
                        [root@mycat ~]# sed -i "39,42d" /usr/local/mycat/conf/schema.xml
                        [root@mycat ~]# sed -i "16,18d" /usr/local/mycat/conf/schema.xml
                        [root@mycat ~]# wc -l /usr/local/mycat/conf/schema.xml
                        48 /usr/local/mycat/conf/schema.xml

                            文件结构如下:
                            <mycat: >
                                 <schema  >    //定义分片库  name //逻辑库名  databNode  //指定数据节点  rule //指定分片规则  type=global //数据不分片存储
                                    <table />   //表信息 name //逻辑表名 ; schema 中有多少 table 就代表有多少表,有多少schema代表有多少库

                                 </schema>
                                <dataNode />
                                 <dataHost>
                                 </dataHost>
                            </mycat: >

                            添加(逻辑表)
                            ##############################将文件修改如下######################
                             11                 <table name="company" primaryKey="ID" type="global" dataNode="dn1,dn2,dn3" />
                             12                 <table name="goods" primaryKey="ID" type="global" dataNode="dn1,dn2,dn3" />
                             13                 <!-- random sharding using mod sharind rule -->
                             14                 <table name="hotnews" primaryKey="ID" autoIncrement="true" dataNode="dn1,dn2,dn3"
                             15                            rule="mod-long" />
                             16                 <table name="employee" primaryKey="ID" dataNode="dn1,dn2,dn3"
                             17                            rule="sharding-by-intfile" />
                             18                 <table name="customer" primaryKey="ID" dataNode="dn1,dn2,dn3"

                                                ##################指定数据库###################

                             33         <dataNode name="dn1" dataHost="localhost53" database="db1" />
                             34         <dataNode name="dn2" dataHost="localhost54" database="db2" />
                             35         <dataNode name="dn3" dataHost="localhost55" database="db3" />

                                            #########################修改配置节点##############################

                             36         <dataHost name="localhost53" maxCon="1000" minCon="10" balance="0"
                             37                           writeType="0" dbType="mysql" dbDriver="native" switchType="1"  slaveThreshold="100">
                             38                 <heartbeat>select user()</heartbeat>
                             39                 <writeHost host="hostM53" url="192.168.4.53:3306" user="adminplj"
                             40                                    password="123qqq...A">
                             41                 </writeHost>
                             42         </dataHost>
                             43
                             44         <dataHost name="localhost54" maxCon="1000" minCon="10" balance="0"
                             45                           writeType="0" dbType="mysql" dbDriver="native" switchType="1"  slaveThreshold="100">
                             46                 <heartbeat>select user()</heartbeat>
                             47                 <writeHost host="hostM54" url="192.168.4.54:3306" user="adminplj"
                             48                                    password="123qqq...A">
                             49                 </writeHost>
                             50         </dataHost>
                             51         <dataHost name="localhost55" maxCon="1000" minCon="10" balance="0"
                             52                           writeType="0" dbType="mysql" dbDriver="native" switchType="1"  slaveThreshold="100">
                             53                 <heartbeat>select user()</heartbeat>
                             54                 <writeHost host="hostM55" url="192.168.4.55:3306" user="adminplj"
                             55                                    password="123qqq...A">
                             56                 </writeHost>
                             57         </dataHost>


                    3)配置数据库服务器
                        创建授权用户,对应数据库
                        mysql> create database db1;
                        mysql> grant all on *.* to adminplj@"%" identified by "123qqq...A";


                    4)验证
                        [root@mycat bin]# ./mycat start
                        Starting Mycat-server...
                        [root@mycat bin]# ss -antulp | grep 8066
                        tcp    LISTEN     0      100      :::8066                 :::*                   users:(("java",pid=1919,fd=81))
                        //添加path
                        [root@mycat bin]# PATH=/usr/local/mysql/bin:$PATH
                        [root@mycat bin]# mysql -h192.168.4.53/54/55 -uadminplj -p123qqq...A

                6.测试

                    [root@mycat conf]# vim partition-hash-int.txt
                    10000=0
                    10010=1
                    10020=2
                    [root@53 ~]# mysql -h192.168.4.56 -P8066 -uroot -p123456
                    mysql> use TESTDB;
                    create table employee(ID int primary key, sharding_id int, name char(15), age int);

                    ///一般来说给 表的每个字段名添加数据,表后面是可以不用写字段名的 但是这里不添加就不能加入数据

                    insert into employee(ID,sharding_id,name,age) values(1,10000,"BOB",21),(2,10010,"AOA",23),(3,10020,"DOD",23);
                    insert into employee(ID,sharding_id,name,age) values(1,10000,"ZOZ",21),(2,10000,"COC",23),(3,10000,"FOF",23);
                    在54 55 只能查询到对应的 sharding_id的 值





                将分片规则为求模进行验证

                求模mod-long

                    修改schema.xml文件
                        [root@db56 conf]# vim /usr/local/mycat/conf/schema.xml

                        <table name="hotnews" dataNode="dn1,dn2,dn3"
                               rule="mod-long" />
                    修改rule.xml文件
                        [root@db56 conf]# vim /usr/local/mycat/conf/rule.xml
                        <tableRule name="mod-long">
                        <rule>
                            <columns>num</columns>  //对那个字段值求模,建表时必须包含这个字段
                            <algorithm>mod-long</algorithm>
                        </rule>
                        </tableRule>

                        <function name="mod-long" class="io.mycat.route.function.PartitionByMod">
                        <!-- how many data nodes -->
                        <property name="count">3</property>
                        </function>

                客户端验证求模分片规则
                    [root@DBA ~]# mysql -h192.168.4.56 -uroot -P8066 -p123456
                    mysql> create table hotnews(num int, title char(30), comment char(200));
                    Query OK, 0 rows affected (10.80 sec)
                    mysql> insert into hotnews(num,title,comment) values(9,"dchech","marryme");
                    Query OK, 1 row affected (0.08 sec)
                    mysql> insert into hotnews(num,title,comment) values(9,"have a baay","chouyn");
                    Query OK, 1 row affected (0.06 sec)

                    mysql> insert into hotnews(num,title,comment) values(5,"have a baby again","chouynaa  a ");
                    Query OK, 1 row affected (0.03 sec)

                    mysql> insert into hotnews(num,title,comment) values(4,"have a baby again agagin","chouynaa  a ");
                    Query OK, 1 row affected (0.05 sec)
                    53 进入本地数据库
                    [root@dba-53 ~]# mysql -uroot -ptarena
                    mysql> mysql> select * from hotnews;
                    +------+-------------+---------+
                    | num  | title       | comment |
                    +------+-------------+---------+
                    |    9 | dchech      | marryme |
                    |    9 | have a baay | chouyn  |
                    +------+-------------+---------+
                    54
                    [root@dba-54 ~]# mysql -uroot -ptarena
                    mysql> select * from hotnews;
                    +------+--------------------------+-------------+
                    | num  | title                    | comment     |
                    +------+--------------------------+-------------+
                    |    4 | have a baby again agagin | chouynaa  a |
                    +------+--------------------------+-------------+
                    55
                    [root@dba-55 ~]# mysql -uroot -ptarena
                    mysql> select * from db3.hotnews;
                    +------+-------------------+-------------+
                    | num  | title             | comment     |
                    +------+-------------------+-------------+
                    |    5 | have a baby again | chouynaa  a |
                    +------+-------------------+-------------+

                添加新库新表

                    修改配置文件

                        [root@db56 conf]# vim /usr/local/mycat/conf/server.xml
                        <user name="root">
                                <property name="password">123456</property>  //添加一个库(逻辑库)
                                <property name="schemas">TESTDB,BBSDB</property>
                        <user>

                        [root@db56 conf]# vim /usr/local/mycat/conf/schema.xml    //在库中添加表(逻辑表)
                            <schema name="BBSDB" checkSQLschema="false" sqlMaxLimit="100">
                            <table name="company" primaryKey="ID" type="global"  dataNode="dn1,dn2,dn3" />
                            <table name="employee" primaryKey="ID"  dataNode="dn1,dn2,dn3" rule="sharding-by-intfile"  />
                            </schema>


                        [root@db56 conf]# /usr/local/mycat/bin/mycat stop #mycat启动
                        [root@db56 conf]# /usr/local/mycat/bin/mycat start

                        创建表
                            company表是全局存储,没有分表,
                            56
                            mysql> create table company(ID int primary key,name char(20), addr char(20));
                        添加数据
                            mysql> insert into company(ID, name, addr) values(1,"tarena","xian");
                            Query OK, 1 row affected (0.16 sec)

                            mysql> insert into company(ID, name, addr) values(2,"dcjit","xian");
                            Query OK, 1 row affected (0.21 sec)

                            mysql> insert into company(ID, name, addr) values(2,"sic","chengdu");
                        在53 54 55 的本地数据库查看上查看表

                            mysql> mysql> select * from company;
                            +----+--------+---------+
                            | ID | name   | addr    |
                            +----+--------+---------+
                            |  1 | tarena | xian    |
                            |  2 | dcjit  | xian    |
                            |  3 | sic    | chengdu |
                            +----+--------+---------+
       DAY04 MHA集群

            一.环境准备
                3台全新的数据库服务器 51 52 53
                2台新的虚拟机  50 57
                51 52 53 之间相互访问无密码登录
                ssh-key-gen
                ssh-copy-id ipaddress
                57 可无密码登录51 52  53
                51 52 53 57 安装 perl-*
                配置主从 51 主 52 53 从
                集群:多台服务器提供相同的服务
                集群分类 LB(负载均衡) HA(高可用) HPC(高性能计算)
                       lvs Haproxy  nginx ; keeplive

                Master HA mha的全称

                MHA介绍 实现mysql高可用的解决方案
                        数据库的自动切换操作在30s内完成
                        MHA能保证在故障切换过程中最大限度保证数据一致性,达到真正的高可用
                        由perl语言开发
                        依赖主从同步提供高可用
                MHA组成:
                        MHA Manager(管理节点)
                            管理所有数据库服务器
                            可单独部署在一台独立机器上
                            也可以部署在某台数据库服务器
                        MHA Node(数据节点)
                            存储数据的mysql服务器
                            运行在每台mysql服务器上
                MHA工作过程

                        manage 57----------------  master-slave-1
                            |  \
                            |   \
                            |   |___________________
                            |                       |
                        master-slave-2            master-slave-3

                        原理:

                        master定时探测集群中的master节点
                        当master节点故障,manager自动将拥有最新数据的slave提升为新的master.
                        50 客户端
                        51 主    当前主库
                        52 从    备用主库   一主多存
                        53 从    备用主库
                        57       管理主机
                        100      VIP地址(虚拟ip)  浮动ip
            二.部署MHA集群
                    软件准备
                        51 52 53 57 执行
                    scp -r mha-soft-student/ root@192.168.4.{51,52,53,57}:/root/
                    cd /root/mha-soft-student
                    yum -y install perl-*.rpm
                    rpm -qa |grep -i perl |wc -l
                    检查主从结构是否正常(57不用检查)
                    mysql -uroot -ptarena -e"show slave status\G" |grep -i yes

                    57
                    配置管理节点
                        [root@dba57 mha-soft-student]# rpm -ivh mha4mysql-node-0.56-0.el6.noarch.rpm

                        [root@dba57 mha-soft-student]# tar -zxf mha4mysql-manager-0.56.tar.gz

                        [root@dba57 mha4mysql-manager-0.56]# perl Makefile.PL //perl 编译

                        [root@dba57 mha4mysql-manager-0.56]# make && make install  //安装

                        [root@dba57 mha4mysql-manager-0.56]# masterha_  //可以使用的命令
                        masterha_check_repl       masterha_conf_host        masterha_master_switch
                        masterha_check_ssh        masterha_manager          masterha_secondary_check
                        masterha_check_status     masterha_master_monitor   masterha_stop
                        [root@dba57 mha4mysql-manager-0.56]# which masterha_check_ssh
                        /root/perl5/bin/masterha_check_ssh

                        [root@dba57 ~]# ls /root/perl5/bin/             //安装路径
                        masterha_check_repl    masterha_conf_host       masterha_master_switch
                        masterha_check_ssh     masterha_manager         masterha_secondary_check
                        masterha_check_status  masterha_master_monitor  masterha_stop

                        [root@dba57 ~]# mkdir /etc/mha   //创建文件夹 将准备好的配置文件拷贝到软件目录
                        [root@dba57 ~]# cp mha-soft-student/mha4mysql-manager-0.56/samples/conf/app1.cnf /etc/mha/

                        修改配置文件如下
                        [root@dba57 ~]# vim /etc/mha/app1.cnf

                            [server default]
                            manager_workdir=/etc/mha     //配置文件日志存放位置
                            manager_log=/etc/mha/manager.log    //日志
                            master_ip_failover_script=/etc/mha/master_ip_failover //当主数据库出现问题时切换主数据库脚本
                            ssh_user=root     //ssh远程管理用户
                            ssh_port=22
                            repl_user=repluser      //同步binlog日志使用的用户
                            repl_password=123qqq...A
                            user=root               //监控用用户
                            password=123qqq...A

                            [server1]

                            hostname=192.168.4.51
                            candidate_master=1
                            port=3306

                            [server2]
                            hostname=192.168.4.52
                            candidate_master=1
                            port=3306

                            [server3]
                            port=3306
                            candidate_master=1
                            hostname=192.168.4.53

                            修改已经准备好的脚本 只添加 vip即可 脚本在tar包里找
                        [root@dba57 ~]# cp mha-soft-student/master_ip_failover /etc/mha/
                        [root@dba57 ~]# chmod +x /etc/mha/master_ip_failover
                        [root@dba57 ~]# vim +35 /etc/mha/master_ip_failover
                            在配置文件中添加如下
                            my $vip = '192.168.4.100/24';  # Virtual IP
                            my $key = "1";
                            my $ssh_start_vip = "/sbin/ifconfig eth0:$key $vip";
                            my $ssh_stop_vip = "/sbin/ifconfig eth0:$key down";

                        51 在主机上配置VIP地址
                            [root@dba-51 ~]# ifconfig eth0:1
                            [root@dba-51 ~]# ifconfig eth0:1 192.168.4.100 //添加虚拟ip地址 //零时添加





                    配置数据节点(51 52 53)
                        安装软件
                            51 52 53 都要装 以52 为例
                            [root@52 ~]# yum -y install mha-soft-student/mha4mysql-node-0.56-0.el6.noarch.rpm
                        添加授权用户
                                57中修改的 /etc/mha/app1.cnf 配置文件

                            同步数据链接用户
                                51 52 53 都要添加,虽然有主从结构
                                mysql> grant replication slave on *.* to repluser@"%" identified by "123qqq...A";
                            57主机监控用户
                                 51 52 53 都要添加
                                MYSQ> grant all on *.* to root@"%" identified by "123qqq...A";
                        修改数据库服务运行参数
                            主库 51
                                [root@dba-51 ~]# vim /etc/my.cnf

                                plugin-load="rpl_semi_sync_slave=semisync_slave.so;rpl_semi_sync_master=semisync_master.so" //加载插件
                                rpl_semi_sync_master_enabled=1      //启动插件
                                rpl_semi_sync_slave_enabled=1
                                relay_log_purge=0           //禁止自动删除binlog日志

                                [root@dba-51 ~]# systemctl restart mysqld
                            从库 52 53 都要做 这里以 52 为例
                                [root@dba-52 ~]# vim /etc/my.cnf
                                plugin-load="rpl_semi_sync_slave=semisync_slave.so;rpl_semi_sync_master=semisync_master.so" //加载插件
                                rpl_semi_sync_master_enabled=1      //启动插件
                                rpl_semi_sync_slave_enabled=1
                                relay_log_purge=0           //禁止自动删除binlog日志


                                [root@dba-52 ~]# systemctl restart mysqld

                                查看主从状态
                                    52 53 都要检查
                                    mysql> show slave status\G;
                                    检查host 和 i/0 sql 线程


                    检查测试
                               排错时间
                            测试SSH配置
                                [root@dba57 ~]# masterha_check_ssh --conf=/etc/mha/app1.cnf
                                All SSH connection tests passed successfully
                            测试主从同步
                                [root@dba57 ~]# masterha_check_repl --conf=/etc/mha/app1.cnf
                                检查  Dead Servers:
                                     Alive Servers:
                                     是否正确

                                MySQL Replication Health is OK

                            启动MHA-MANAGER服务
                             [root@dba57 ~]#   masterha_manager --conf=/etc/mha/app1.cnf --remove_dead_master_conf --ignore_last_failover

                                 --remove_dead_master_conf        删除宕机主库配置
                                 --ignore_last_failover           忽略health文件:取消8小时(自服务启动)内数据库主机宕机不切换主库的限制
                                检查服务是否启动
                                    [root@dba57 ~]# masterha_check_status --conf=/etc/mha/app1.cnf
                                    app1 (pid:19354) is running(0:PING_OK), master:192.168.4.51
                                查看当前数据库主服务器
                                    [root@dba57 ~]# cat /etc/mha/app1.master_status.health

                                客户端50链接vip地址访问集群
                                    51
                                    添加访问数据的链接用户
                                    [root@dba-51 ~]# mysql -uroot -ptarena
                                        mysql> create database db9;
                                        mysql> create table db9.a;

                                        mysql> grant select,insert on db9.* to yaya55@"%" identified by "123qqq...A";

                                    50
                                    添加数据测试
                                    [root@dba-50 ~]# mysql -h192.168.4.100 -uroot -p123qqq...A
                                        mysql> select * from db9.a;
                                        Empty set (0.01 sec)

                                        mysql> insert into db9.a values(100);
                                        Query OK, 1 row affected (0.05 sec)

                                        mysql> select * from db9.a;

                            测试高可用
                                停止51mysql 服务
                                    [root@dba-51 ~]# systemctl stop mysqld.service

                                客户端链接100 访问数据
                                    [root@52 ~]# ifconfig eth0:1  //查看浮动ip
                                    inet 192.168.4.100   (52变成新的主数据库服务器)

                                    [root@DBA ~]# mysql -h192.168.4.100 -uyaya55 -p123qqq...A
                                    mysql> insert into db9.a values(233);
                                    mysql> select * from db9.a;
                                    [root@dba57 ~]# cat /etc/mha/app1.cnf
                                    发现 停掉的 server1 已经在配置文件中删掉了.
                                    只有server2\3

                            将宕机的数据库服务器添加到集群
                                检查状态
                                    在当前数据库主服务器查看 VIP 4.100 是否存在
                                    在52 53 上检查主从状态
                                    在mha管理主机57上
                                        [root@dba57 ~]# masterha_check_status --conf=/etc/mha/app1.cnf  //检查 服务状态
                                        app1 is stopped(2:NOT_RUNNING).
                                        [root@dba57 ~]# masterha_check_ssh --conf=/etc/mha/app1.cnf     //检查ssh
                                        [root@dba57 ~]# masterha_check_repl --conf=/etc/mha/app1.cnf    //检查主从
                                        [root@dba57 ~]# masterha_manager --conf=/etc/mha/app1.cnf       //启动服务


                                同步主库52 的数据到51
                                    52
                                      [root@dba52 ~]# mysqldump -uroot -ptarena --master-data -A > db9.a.sql
                                      [root@dba52 ~]# scp db9.a.sql root@192.168.4.51:/root/

                                    51
                                      [root@dba-51 ~]#  mysql -uroot -ptarena  < db9.a.sql
                                      [root@dba-51 ~]# mysql -uroot -ptarena
                                      [root@dba-51 ~]# vim +22 db9.a.sql

                                      CHANGE MASTER TO MASTER_LOG_FILE='masterdb52.000002', MASTER_LOG_POS=895;

                                      mysql> change master to master_host="192.168.4.51",
                                        -> master_user="repluser",master_password="123qqq...A",
                                        -> master_log_file="masterdb52.000002",master_log_pos=895;
                                      mysql> start slave;
                                      mysql> show slave status\G

                                添加51 到集群 中
                                     停止服务
                                    [root@dba57 ~]# masterha_stop --conf=/etc/mha/app1.cnf
                                     修改配置文件
                                    [root@dba57 ~]# vim /etc/mha/app1.cnf
                                      添加如下
                                      [server1]
                                      candidate_master=1
                                      hostname=192.168.4.51
                                      port=3306
                                     检查ssh
                                    [root@dba57 ~]# masterha_check_ssh --conf=/etc/mha/app1.cnf

                                     检查主从结构
                                    [root@dba57 ~]# masterha_check_repl --conf=/etc/mha/app1.cnf
                                     启动服务
                                    [root@dba57 ~]# masterha_manager --conf=/etc/mha/app1.cnf --remove_dead_master_conf --ignore_last_failover
                                      app1 (pid:3594) is running(0:PING_OK), master:192.168.4.52




       DAY05 PXC 集群
                准备三台全新虚拟机 4.71-4.73
                servername= pxcnode71-73
                配置 hosts 使之间可以使用 servername ping通

            一.PXC介绍
                pxc介绍
                    开源软件
                    pxc集群由两部分: Percona Server wiht XtraDB 和 WriteSet Replication patches
                    同步 多主复制插件
                特点
                  数据强一致性 无同步延迟
                  没有主从切换 无需虚拟ip
                  支持innodb引擎
                  多线程复制
                  部署简单
                  支持节点加入,无需拷贝数据
                端口:
                    3306 数据可端口
                    4444 sst端口
                    4567 集群成员同学端口
                    4568 ist端口
                    sst state snapshot transfer 全增量同步
                    ist incremental state transfer 增量同步
            二.配置
                安装软件
                    //依赖包
                    [root@pxcnode71 PXC]# rpm -ivh libev-4.15-1.el6.rf.x86_64.rpm
                    //安装 在线热备程序
                    [root@pxcnode71 PXC]# yum -y install percona-xtrabackup-24-2.4.13-1.el7.x86_64.rpm
                    //安装依赖--按照顺序来   递归压缩程序
                    [root@pxcnode71 PXC]# rpm -ivh qpress-1.1-14.11.x86_64.rpm
                    //服务端软件
                    [root@pxcnode71 PXC]# tar -xvf Percona-XtraDB-Cluster-5.7.25-31.35-r463-el7-x86_64-bundle.tar
                    //安装集群服务程序
                    [root@pxcnode71 PXC]# yum -y install Percona-XtraDB-Cluster-*.rpm

                配置文件
                    [root@pxconde72 PXC]# ls /etc/percona-xtradb-cluster.conf.d/

                        mysqld.cnf  //数据库服务器配置文件
                        mysqld_safe.cnf //percona server 配置文件
                        wsrep.cnf       //pXc集群配置文件

                    修改配置文件

                        数据配置配置文件

                        修改mysqld.conf

                        71 72 73 都要改 以 73 为例 将server id修改为主机ip末位
                        [root@psconde73 PXC]#  vim /etc/percona-xtradb-cluster.conf.d/mysqld.cnf
                            [client]
                            socket=/var/lib/mysql/mysql.sock

                            [mysqld]
                            server-id=73                            //server id 不能重复
                            datadir=/var/lib/mysql                  //数据库目录
                            socket=/var/lib/mysql/mysql.sock        //sock文件
                            log-error=/var/log/mysqld.log           //日志文件
                            pid-file=/var/run/mysqld/mysqld.pid     //pid文件
                            log-bin                                 //启动binlog日志
                            log_slave_updates                       //启动链式复制
                            expire_logs_days=7                      //日志保存天数

                        修改wsrep.cnf
                            3 台都要做
                            [root@psconde73 PXC]# vim /etc/percona-xtradb-cluster.conf.d/wsrep.cnf
                            修改如下 内容
                                8  wsrep_cluster_address=gcomm://192.168.4.71,192.168.4.72,192.168.4.73
                                25 wsrep_node_address=192.168.4.73  //保证与本地IP一致
                                27 wsrep_cluster_name=pxc-cluster   //设定集群名称 其他两台保持一致
                                30  wsrep_node_name=pxcnode73       //设置与server name 相同
                                39 wsrep_sst_auth="sstuser:123456"  // sst同步授权用户
                    启动服务
                        只在其中一台操作 以73为例子
                        [root@pxconde73 ~]# systemctl start mysql@bootstrap.service
                        查找数据库初始密码

                        [root@pxconde73 ~]# grep pass /var/log/mysqld.log
                        进入数据库
                        [root@pxconde73 ~]# mysql -uroot -pQhTHt-W4Sh4h
                        修改默认密码
                        mysql> alter user root@"localhost" identified by "123456";

                        添加授权用户
                        mysql> grant reload,lock tables,replication client,process on *.* to sstuser@"localhost" identified by "123456";

                        在所有的数据库服务器上 检查 PXC 服务是否启动

                        [root@pxcnode71 PXC]# systemctl start mysql //木有d
                        tcp    LISTEN     0      128       *:4567                  *:*                   users:(("mysqld",pid=1756,fd=11))
                        [root@pxcnode71 PXC]# ss -antulp | grep 3306
                        tcp    LISTEN     0      80       :::3306                 :::*                   users:(("mysqld",pid=1756,fd=34))

                    查看集群状态

                        mysql> SHOW STATUS LIKE "%wsrep%";

                        主要关注 :

                                 wsrep_incoming_addresses   //集群成员列表       | 192.168.4.73:3306,192.168.4.71:3306,192.168.4.72:3306
                                 wsrep_cluster_weight       //集群服务器台数     | 3
                                 wsrep_cluster_status       //服务器状态      | Primary
                                 wsrep_connected            //链接状态      | ON
                                 wsrep_ready                //集群状态      | ON


                测试
                    测试数据插入授权

                        链接任意任意一台数据库
                        mysql> grant all on gamedb.* to yaya@"%" identified by "123456";
                        mysql> create table gamedb.a(id int primary key auto_increment,name char(30));
                        mysql> insert into gamedb.a values(2,"tom*li");   //插入数据
                        mysql> insert into gamedb.a(name) values("tom*lili"); //不指定id 自加步长为3
                        mysql> select * from gamedb.a;
                        +----+----------+
                        | id | name     |
                        +----+----------+
                        |  1 | bob*dc   |
                        |  2 | tom*li   |
                        |  5 | tom*wang |

                    测试数据库服务器高可用
                        停止任意一台数据库服务器,后插入数据,插入完成后重新启动该服务器.再进行检查
                        [root@pxcnode71 ~]# systemctl stop mysql.service
                        [root@pxcnode71 ~]# systemctl start mysql.service
                        [root@pxcnode71 ~]# mysql -uroot -p123456
                        mysql> select * from gamedb.a;

                        52/53

                        mysql> insert into gamedb.a(name) values("tomcat*wang001");
                        Query OK, 1 row affected (0.06 sec)

                        mysql> insert into gamedb.a(name) values("tomcat*wang002");
                        Query OK, 1 row affected (0.04 sec)

                        mysql> insert into gamedb.a(name) values("tomcat*wang003");
                        Query OK, 1 row affected (0.10 sec)

                        mysql> select * from gamedb.a;


            数据库引擎

                存储引擎
                    作为可插拔的组件提供
                    mysql服务软件自带的功能,处理表的处理器
                    不同的存储引擎有不同的功能和数据存储方式
                    mysql5.6以上默认innodb
                查看数据库服务器可以使用的存储引擎
                    mysql> show engines;//查看所有的数据库引擎
                    | Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |
                    +--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
                    | InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |

                是否可以修改数据库服务使用的存储引擎

                    [root@DBA ~]# vim /etc/my.cnf
                        添加如下
                        default-storage-engine=myisam //写引擎的名称
                    [root@DBA ~]# systemctl restart mysqld

                是否可以修改表的存储引擎
                    创建时指定数据库引擎
                        mysql> create table db10.b(name char(30))engine=myisam; //创建时指定引擎
                        Query OK, 0 rows affected (0.05 sec)

                        mysql> show create table db10.b; //查看创建时命令
                    修改已经存在表的引擎

                        mysql> create table db10.c(name char(10))engine=memory; //指定表引擎

                        mysql> show create table db10.c\G
                        ` char(10) DEFAULT NULL
                        ) ENGINE=MEMORY DEFAULT CHARSET=latin1


                        mysql> alter table db10.c engine=myisam;  //修改表引擎
                        Query OK, 0 rows affected (0.05 sec)
                        Records: 0  Duplicates: 0  Warnings: 0

                        mysql> show create table db10.c\G;   //查看数据库创建信息
                        (
                          `name` char(10) DEFAULT NULL
                        ) ENGINE=MyISAM DEFAULT CHARSET=latin1


                常用存储引擎的特点
                    myisam
                        特点 支持表级锁
                            不支持事物 事物回滚 外键
                        .frm 表结构
                        .MYI 表索引
                        .MYD 表数据
                    innodb
                        特点 支持行级锁定
                            支持事物 事物回滚 外键
                        .frm 表结构
                        .ibd 表数据
                        事物日志文件  //只有innodb才支持
                           事物:一次访问数据库的开始到断开数据库链接,表示一次事物
                           当执行一个操作时,失败后可根据事物日志恢复.
                        ibdata1
                        ib_logfile0
                        ib_logfile1

                    nysql锁机制

                        目的:解决并发访问冲突

                        颗粒度:
                            表级锁: 对整张表加锁
                            行级锁: 仅对被访问的行提供加锁
                        锁类型
                            读锁(共享锁):支持并发
                            写锁(互斥锁):是独占锁上锁期间其他线程不能读表\写表
                        查看当前锁状态
                            show status like "table_lock";
                            +-----------------------------------------+-------+
                            | Variable_name                           | Value |
                            +-----------------------------------------+-------+
                            | Performance_schema_table_lock_stat_lost | 0     |
                            | Table_locks_immediate                   | 100   |
                            | Table_locks_waited                      | 0     |  //锁等待
                            +-----------------------------------------+-------+

                    事物特性(ACID)
                        Atomic :原子性
                            事物的整个操作是一个整体,不可分割,要么全成功要么全失败
                        Consistency :一致性
                            事物操作前后,表中记录没有变化
                        Isolation :隔离性
                            事物操作是互相隔离不受印象的
                        Durability :持久性
                            一旦数据提交,不可改变,永久改变数据

                        一致性测试

                            开启新终端
                                 关闭autocommit 测试一致性

                                mysql> show variables like "autocommit";

                                | autocommit    | ON    |

                                mysql> set autocommit=off;  //暂时关闭autocommit
                                Query OK, 0 rows affected (0.00 sec)

                                mysql> show variables like "autocommit";

                                | autocommit    | OFF   |
                                //创建innodb的表之前将 默认引擎修改称为 myism
                                mysql> create table db10.a4(name int)engine=innodb;
                                //插入数据
                                mysql> insert into db10.a4 values(10010);
                            在另一个终端中查看
                                mysql> select * from db10.a4;
                                Empty set (0.00 sec)
                                //在关闭autocommit的终端中
                                mysql> commit;
                                Query OK, 0 rows affected (0.07 sec)
                            在另一个终端中查看
                                mysql> select * from db10.a4;
                                +-------+
                                | name  |
                                +-------+
                                | 10010 |
                                +-------+
                        事务性测试
                            在关闭autocommit的终端中
                            //插入
                                mysql> insert into db10.a4 values(10086);
                                Query OK, 1 row affected (0.00 sec)

                                mysql> insert into db10.a4 values(1008611);
                                Query OK, 1 row affected (0.00 sec)
                                mysql> select * from db10.a4;
                                +---------+
                                | name    |
                                +---------+
                                |   10010 |
                                |   10086 |
                                | 1008611 |
                                +---------+
                                mysql> delete from db10.a4;
                                Query OK, 3 rows affected (0.00 sec)


                            //删除
                                mysql> select * from db10.a4;
                                Empty set (0.00 sec)

                                mysql> rollback;
                                Query OK, 0 rows affected (0.03 sec)
                            //回滚到所有操作之前(commit为界限)

                                mysql> select * from db10.a4;
                                +-------+
                                | name  |
                                +-------+
                                | 10010 |
                                +-------+
                                1 row in set (0.00 sec)
                                mysql> commit;
                            在开机autocommit的终端中数据没有变化
                                mysql> select * from db10.a4;
                                +-------+
                                | name  |
                                +-------+
                                | 10010 |
                                +-------+


                建表时如何决定表使用的存储引擎

                    查询操作多的表推荐使用,myisam存储引擎,节省性能
                        读锁 (表级锁)
                        select *  from a1;
                        select * from a1 where id<=3;

                    写操作多的表推荐使用,innodb存储引擎,并发访问量大.
                        行级锁:只给访问的行分别加锁
                        同时操作
                        pc1  update a1 set age=19 where id<=3;
                        pc2  update a1 set age=21 where id>3;


       DAY06 redis
            部署redis服务器

                相关概念
                    RDBMS 关系型数据库

                    Nosql 非关系型数据库

                    数据库类型
                                    关系型 relation database management system
                                        按照预先设置的组织结构,将数据存储在物理介质上
                                        eg:mysql db2 oracle sql server Mariadb

                                    非关系型 not only sql
                                         泛指非关系型数据库
                                         不需要预先定义数据存储类型 (不需要先建表)
                                         每条记录可以有不同的数据类型和字段个数
                                         eg: memcached mongdb redis

                介绍redis
                        remote dictionary server (远程字典服务器)
                        高性能的(key/values)分布式内存数据库 //分部署
                        支持数据持久化(定期将内存中数据存储到硬盘中) //持久化
                        支持多种数据类型 string list hash
                        支持主从(maser/slave)模式数据备份

                安装

                      338  rpm -q gcc
                      339  yum -y install gcc
                      340  tar -zxvf
                      341  tar -zxvf  redis-4.0.8.tar.gz
                      342  ls
                      343  cd redis-4.0.8/
                      344  make && make install

                初始化

                    redis-4.0.8/utils/insert_server.sh
                                       一路回车使用默认,若要修改则可以输入
                                       安装完成后需要修改的话,修改主配置文件
                      redis默认端口端口6379
                      主配置文件 /etc/redis/6379.conf
                      日志问价  /var/log/redis_6379.log
                      数据库主目录 /var/lib/redis/6379
                      服务启动程序 /usr/local/bin/redis-server
                      命令行链接程序 /usr/local/bin/redis-cli
                      启动脚本      /etc/init.d/redis_6354  stop start //修改密码后无法使用,如果不修改该文件
                redis 管理

                        ss -ntulp |grep 6379
                            tcp    LISTEN     0      128    127.0.0.1:6379             //默认只能本机链接
                        ps -C redis-server
                        /etc/init.d/redis_6379 stop  //停止服务
                        /etc/init.d/redis_6379 start //启动

                        //进入数据库,插入数据

                        [root@DBA ~]# redis-cli
                        127.0.0.1:6379> keys *   //查看所有变量
                        (empty list or set)
                        127.0.0.1:6379> set sechool tarena //插入数据
                        OK
                        127.0.0.1:6379> keys *
                        1) "sechool"
                        127.0.0.1:6379> get sechool    //读取数据
                        "tarena"

                        [root@DBA ~]# ls /var/lib/redis/6379/ //数据库数据
                        dump.rdb
                常用命令
                        set keyname keyvalue //存储一个key值
                        mset                 //存储多个key值
                        get keyname          //获取多个key值
                        mget                 //获取多个key值
                        select 数据库编号(0-15,默认只有16个库) //切换库
                        keys    *            //显示所有key名
                        keys a?              //显示指定key名  //显示以a开头且只有两位的key
                        exists  keyname      //测试key名是否存在
                                    127.0.0.1:6379> EXISTS ch
                                    (integer) 1 //表示存在


                        ttl keyname          //查看key生存时间
                                           127.0.0.1:6379> ttl li
                                            (integer) -1 //表示永久存在


                        type keyname         //查看key 类型

                        move keyname dbname  //移动key到指定库
                                            127.0.0.1:6379> MOVE ch 1
                                            (integer) 1

                        expire keyname 10    //设置key有效时间
                                            127.0.0.1:6379> EXPIRE li 30 (秒)                                            (integer) 1
                                            127.0.0.1:6379> ttl li
                                            (integer) -2 //已过期


                        del keyname          //删除指定key
                                            127.0.0.1:6379> del ch
                                            (integer) 1

                        flushall             //删除所有内存中的key
                                            127.0.0.1:6379> FLUSHALL
                                            OK
                                            127.0.0.1:6379> keys *
                                            (empty list or set)

                        flushdb              //删除所在库中的所有key
                                            127.0.0.1:6379[1]> keys *
                                            1) "ch"
                                            2) "li"
                                            127.0.0.1:6379[1]> FLUSHDB
                                            OK
                                            127.0.0.1:6379[1]> keys *
                                            (empty list or set)

                        save                 //保存所有key到硬盘

                        shutdown             //停止服务

                配置文件分析
                        /etc/redis/6379.conf
                        配置分类


                            常用配置


                        内存管理
                            内初清除策略
                                volatile-lru        //最近最少使用(针对设置了ttl的key)
                                allkeys-lru         //删除最少使用的key(针对所有的key)
                                volatile-lfu        //从所有的key中删除使用最少的key
                                allkeys-lfu         //从所有配置过期时间的key(中清除)删除最少使用的key
                                volatile-random     //在设置了ttl的key里随机删除
                                allkeys-random      //随即删除key
                                volatile-ttl        //删除最近过期的key
                                noeviation          // 不删除,写满是报错 (默认)
                            优化设置
                                maxmemory           //最大内存  默认使用机器剩余全部内存
                                maxmemory-policy    //定义使用策略
                                maxmemory-samples   //选取key模板的个数 (针对lru和ttl 策略)
                        链接密码
                            设置密码 ip地址 端口
                                [root@DBA ~]# vim /etc/redis/6379.conf
                                    503 requirepass 123456
                                    70  bind 192.168.4.50
                                    93  port 6350
                                [root@DBA ~]# /etc/init.d/redis_6379 stop
                                    Stopping ...
                                    Redis stopped
                                [root@DBA ~]# /etc/init.d/redis_6379 start
                                //只修改服务密码
                                [root@DBA ~]# redis-cli
                                127.0.0.1:6379> keys *
                                (error) NOAUTH Authentication required.
                                 127.0.0.1:6379> AUTH 123456
                                OK
                                127.0.0.1:6379> keys *
                                1) "dc"
                                //密码\端口\ip都修改
                                [root@DBA ~]# redis-cli -h 192.168.4.50 -p 6350 -a 123456
                                192.168.4.50:6350> keys *
                                1) "dc"

                        修改密码\端口\IP地址
                        后无法使用   /etc/init.d/redis_6379 stop  停止服务
                        只能在命令行中使用 shutdown 停止,开启不受到密码影响
                                [root@DBA ~]# redis-cli
                                127.0.0.1:6379> AUTH 123456
                                OK
                                127.0.0.1:6379> SHUTDOWN
                                修改脚本使的脚本能够重新停止服务
                                [root@DBA ~]# vim +43 /etc/init.d/redis_6379
                                $CLIEXEC -h 192.168.4.50 -p 6350 -a 123456 shutdown
                                [root@DBA ~]# /etc/init.d/redis_6379 stop
                                Stopping ...
                                Redis stopped



            部署lnmp+redis

                部署lnmp
                    安装nginx
                         yum -y install gcc pcre-devel zlib-devel
                         cd lnmp/
                         tar -xf nginx-1.12.2.tar.gz
                         cd nginx-1.12.2/
                          ./configure
                          make && make install

                    安装php-fpm,启动fpm,查看9000端口
                         yum -y install php-fpm
                         systemctl restart php-fpm.service
                          ss -antulp | grep fpm
                    修改nginx服务配置文件
                        vim +65 /usr/local/nginx/conf/nginx.conf
                        location ~ \.php$ {
                        root           html;
                        fastcgi_pass   127.0.0.1:9000;
                        fastcgi_index  index.php;
                        fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
                        include        fastcgi.conf;
                                 }
                    编写php测试网页,访问测试
                         vim /usr/local/nginx/html/test.php
                            <?php
                            echo "nihao\n"
                            ?>
                         curl http://localhost/test.php

                    配置支持redis
                         yum -y install php php-devel  autoconf automake
                         tar -xf php-redis-2.2.4.tar.gz
                         cd phpredis-2.2.4/
                         phpize //生成php-configure以及configure命令
                         ./configure --with-php-config=/usr/bin/php-config
                         make
                         make install

                         vim +728 /etc/php.ini
                             728 extension_dir = "/usr/lib64/php/modules/"
                             730 extension = "redis.so"
                         systemctl restart php-fpm.service
                         php -m |grep -i redis
                            redis

                         cp linkredis.php /usr/local/nginx/html/

                         将配置文件修改如下
                         vim /usr/local/nginx/html/linkredis.php
                            <?php
                            $redis = new redis();
                            $redis->connect('192.168.4.50',6350);
                            $redis->auth("123456");               //若redis 没有密码则可以不用写
                            $redis->set('redistest','666666');
                            echo $redis->get('redistest');
                            ?>
                            访问测试
                         curl http://localhost/linkredis.php


       DAY07 redis 集群

                准备:
                准备6 台 redis 一台 管理 redis 服务器
                6 台redis 使用上次实验创建的 的 六台  不要设置密码
                软件:
                scp -r ../redis/ root@192.168.4.57:/root/


            部署管理主机
                也可以部署在任意的一台redis上
                    57
                部署ruby脚本

                    yum -y install rubygems    //安装ruby
                    redis]# gem install redis-3.2.1.gem //安装gem
                    rpm -qa | grep -i ruby     //检查是否已经安装 ruby 解释器 没有的话yum 安装
                    ruby-2.0.0.648-33.el7_4.x86_64
                创建管理集群脚本

                      ]# mkdir /root/bin
                      ]# tar -xf redis-4.0.8.tar.gz
                      ]# ls
                      ]# cd redis-4.0.8/src/
                      ]# cp redis-trib.rb /root/bin/
                      ]# chmod +x /root/bin/redis-trib.rb

                      redis-trib 脚本
                      用法
                      ]# redis-trib <command> <options> <argument>

                      create                          //创建集群
                      check                           //检查集群
                      info                            //检查集群信息
                      reshard                         //重新分片
                      del-node                        //删除主机
                      add-node                        //添加slave主机
                      add-node --slave                 //添加master主机
                      rebalance                       //平均分配hash slots

                    51-56

                    ]# rm -rf /var/lib/redis/6351/*  //删除当前数据库下的所有数据,当数据库中有数据,集群会创建失败
                    修改配置文件启动集群
                    vim /etc/redis/xxx.conf          // xxx表示你当前redis的端口

                    815  cluster-enabled yes
                    823 cluster-config-file nodes-xxxx.conf
                    829 cluster-node-timeout 5000

                    重启服务
                    ]# /etc/init.d/redis_6351 stop
                    ]# /etc/init.d/redis_6351 start

                    显示如下表示集群服务开启
                    若少服务请检查配置文件 16351 集群端口
                    [root@redisA-51 redis-4.0.8]# ss -antulp | grep 6351
                        tcp    LISTEN     0      128    192.168.4.51:16351                 *:*                   users:(("redis-server",pid=1415,fd=8))
                        tcp    LISTEN     0      128    192.168.4.51:6351                  *:*                   users:(("redis-server",pid=1415,fd=6))


                    57  管理主机
                    创建集群

                    [root@mgm-57 ~]# redis-trib.rb create --replicas 1 \ // replicas 1 表示,每个主库管理几个从库
                        > 192.168.4.51:6351 192.168.4.52:6352 \
                        > 192.168.4.53:6353 192.168.4.54:6354 \
                        > 192.168.4.55:6355 192.168.4.56:6356
                    随机从中选择三台主机
                        显示如下表示创建成功
                        [OK] All nodes agree about slots configuration.
                        >>> Check for open slots...
                        >>> Check slots coverage...
                        [OK] All 16384 slots covered.



                    查看集群信息
                        在集群中任意以一台服务器
                        [root@redisA-51 ~]# redis-cli -h 192.168.4.51 -p 6351
                        查看集群状态
                            192.168.4.51:6351> CLUSTER INFO
                            cluster_state:ok                //集群状态
                             ...
                            cluster_known_nodes:6      //多少节点
                            cluster_size:3            //多少主机
                            cluster_current_epoch:6
                              ....
                        查看节点状态
                            192.168.4.51:6351> CLUSTER NODES
                            7eb70abf7840917b544cb50c855427710ac5c3f6 192.168.4.52:6352@16352 master - 0 1561356225000 2 connected 5461-10922
                            ea213013e11d0ff2c6e5ba79bfbcba6b9d9d4874 192.168.4.54:6354@16354 slave 4128c44b7cfdfdb8a6ed49a06a4c385af3de5d0e 0 1561356223146 4 connected
                            ...

                        在管理主机上查看集群状态
                            [root@mgm-57 ~]# redis-trib.rb info 192.168.4.51:6351
                                192.168.4.51:6351 (675ee5ad...) -> 0 keys | 5461 slots | 1 slaves.
                                192.168.4.52:6352 (7eb70abf...) -> 0 keys | 5462 slots | 1 slaves.
                                192.168.4.53:6353 (4128c44b...) -> 0 keys | 5461 slots | 1 slaves.
                                [OK] 0 keys in 3 masters.
                                0.00 keys per slot on average.

                        在管理主机上查看集群主从信息
                            [root@mgm-57 ~]# redis-trib.rb check 192.168.4.51:6351
                                >>> Performing Cluster Check (using node 192.168.4.51:6351)
                                M: 675ee5adc4412ccce47cc5862b3b6d85ec5f4c85 192.168.4.51:6351
                                   slots:0-5460 (5461 slots) master
                                   1 additional replica(s)
                                M: 7eb70abf7840917b544cb50c855427710ac5c3f6 192.168.4.52:6352
                                ...

                    测试集群

                        链接集群插入数据
                            链接任意一台服务器, 链接是 -c  表示使用集群模式 不添加链接后无法使用集群
                            [root@redisA-51 ~]# redis-cli -c -h 192.168.4.51 -p 6351
                                192.168.4.51:6351> set x 100
                                ...
                                192.168.4.52:6352> get f
                                -> Redirected to slot [3168] located at 192.168.4.51:6351

                        redis 集群数据的储存
                            slots的值只是决定了数据存储的位置,
                            存储数据
                                获取变量名---->对变量名 进行crc16计算获得hash值---->根据获得的hash值与slots值对比将值存入对应的slots中
                            查询数据
                                反者执行
                                获取变量名---->对变量名 进行crc16计算获得hash值---->根据获得的hash值在对应的slots中查找



            管理集群

                故障切换测试
                    停止master主机的redis服务
                    -master宕机后主机对应的slave自动被选择为master
                    -原master启动后自动配置为当前master的slave


                    一组主从全坏掉(尤其是一主一从,可以添加多个从来解决这个问题)后集群高可用就坏了

                        停止主库
                        [root@redisA-51 ~]# /etc/init.d/redis_6351 stop
                            Stopping ...
                            Waiting for Redis to shutdown ...
                            Redis stopped
                        查看集群状态
                        [root@mgm-57 ~]# redis-trib.rb check 192.168.4.52:6352
                        M: 40f615161c72047777a4a33eeed34e0a4b789763 192.168.4.55:6355
                        slots:0-5460 (5461 slots) master
                        原主停止后,从升级为主,(51为主,55为从)
                        [root@mgm-57 ~]# redis-trib.rb info 192.168.4.52:6352
                            192.168.4.52:6352 (7eb70abf...) -> 2 keys | 5462 slots | 1 slaves.
                            192.168.4.53:6353 (4128c44b...) -> 2 keys | 5461 slots | 1 slaves.
                            192.168.4.55:6355 (40f61516...) -> 3 keys | 5461 slots | 0 slaves.

                        插入数据到55上

                        redis-cli -c -p 6355 -h 192.168.4.55
                        192.168.4.52:6352> set dcc3 1008612
                        -> Redirected to slot [2385] located at 192.168.4.55:6355

                        启动51的redis服务查看集群
                        看到原主51已经成为55的从了
                        51 ~]# /etc/init.d/redis_6351 start
                        [root@mgm-57 ~]# redis-trib.rb info 192.168.4.52:6352
                            192.168.4.52:6352 (7eb70abf...) -> 4 keys | 5462 slots | 1 slaves.
                            192.168.4.53:6353 (4128c44b...) -> 2 keys | 5461 slots | 1 slaves.
                            192.168.4.55:6355 (40f61516...) -> 4 keys | 5461 slots | 1 slaves.

                        [root@mgm-57 ~]# redis-trib.rb check 192.168.4.52:6352
                            S: 675ee5adc4412ccce47cc5862b3b6d85ec5f4c85 192.168.4.51:6351
                            slots: (0 slots) slave
                            replicates 40f615161c72047777a4a33eeed34e0a4b789763


                添加服务器
                    条件:
                        当内存不够时,添加服务器增加数据的存储空间
                    部署一台新的redis服务器
                        -运行服务并配置集群配置
                    准备:
                        安装redis 配置集群 端口 ip
                        修改对应配置文件
                        vim /etc/init.d/redis_6358
                        43
                        vim /etc/init.d/redis_6358
                        70
                        815
                        823
                        829

                    添加master主机步骤
                        准备两台58 59 master主机

                        57<mgm>

                        添加master,分配hash槽

                             51 代表集群,默认添加为主, add-node --slave 表示添加为从
                             [root@mgm-57 ~]# redis-trib.rb add-node 192.168.4.58:6358 192.168.4.51:6351
                             [root@mgm-57 ~]# redis-trib.rb check 192.168.4.51:6351 //检查集群状态
                                 M: a4ae50ccb07b276159f10cba531f347b85abb456 192.168.4.58:6358
                                 slots: (0 slots) master


                        分配hash槽(slots)
                             51 表示集群
                            [root@mgm-57 ~]# redis-trib.rb check 192.168.4.51:6351
                                How many slots do you want to move (from 1 to 16384)? 4096  //需要多少slots
                                What is the receiving node ID? a4ae50ccb07b276159f10cba531f347b85abb456  //谁需要slots
                                Source node #1:all  //从所有的master中平均获取,也可以填 ID
                                Source node #2:xxxx / done //还需要从那个master获取,或者done表示结束
                                         xxxxxx       yes 表示同意
                            查看集群状态
                            [root@mgm-57 ~]# redis-trib.rb info 192.168.4.51:6351
                            192.168.4.58:6358 (a4ae50cc...) -> 3 keys | 4096 slots | 0 slaves.

                    添加slave节点

                         命令: redis-trib.rb add-node --slave [--master-id xxxx] slave-ip:port 集群名称
                              不指定master的化会自动添加到从库最少的master上,当master的从相同时,从库随机分配到 任意的master上

                         ]# redis-trib.rb add-node --slave --master-id a4ae50ccb07b276159f10cba531f347b85abb456 192.168.4.59:6359 192.168.4.51:6351
                         也可以这么写
                         ]# redis-trib.rb add-node --slave 192.168.4.59:6359 192.168.4.51:6351

                    移除slave服务器
                        当从移除服务器后,机器中的redis会默认停止

                        移除slave主机
                            需要在管理主机上执行 57
                        命令:                         ip:port
                            ]# redis-trib.rb del-node 集群名   被移除服务器id
                        eg:
                            ]# redis-trib.rb del-node 192.168.4.51:6351 37fdc2f9b2d1db9b81e9cc90d3a5b7efcf3a33d2
                            >>> Removing node 37fdc2f9b2d1db9b81e9cc90d3a5b7efcf3a33d2 from cluster 192.168.4.51:6351
                            >>> Sending CLUSTER FORGET messages to the cluster...
                            >>> SHUTDOWN the node.
                            ~]# redis-trib.rb info 192.168.4.51:6351
                            192.168.4.58:6358 (a4ae50cc...) -> 3 keys | 4096 slots | 0 slaves

                        移除master主机
                            释放步骤:
                                先释放slots,在删除主
                            eg:
                                //释放slots
                            ]# redis-trib.rb reshard 192.168.4.51:6351 //移除slots
                                How many slots do you want to move (from 1 to 16384)? 4096  //需要多少slots
                                What is the receiving node ID?   37fdc2f9b2d1db9b81e9cc90d3a5b7efcf3a33d2 //将slots给谁
                                Source node #1:a4ae50ccb07b276159f10cba531f347b85abb456   //填写需要删除slots的主机 id
                                Source node #2:xxxx / done //还需要从那个master获取,或者done表示结束
                                         xxxxxx       yes 表示同意

                            ]# redis-trib.rb info 192.168.4.51:6351
                                192.168.4.58:6358 (a4ae50cc...) -> 0 keys | 0 slots | 0 slaves.
                                .//删除master主机
                            ]# redis-trib.rb del-node 192.168.4.51:6351 a4ae50ccb07b276159f10cba531f347b85abb456
                                >>> Removing node a4ae50ccb07b276159f10cba531f347b85abb456 from cluster 192.168.4.51:6351
                                >>> Sending CLUSTER FORGET messages to the cluster...
                                >>> SHUTDOWN the node.

                                //查看集群
                            [root@mgm-57 ~]# redis-trib.rb info 192.168.4.51:6351
                                192.168.4.55:6355 (40f61516...) -> 6 keys | 8192 slots | 1 slaves.
                                192.168.4.52:6352 (7eb70abf...) -> 2 keys | 4096 slots | 1 slaves.
                                192.168.4.53:6353 (4128c44b...) -> 2 keys | 4096 slots | 1 slaves.


       DAY08  主从复制
                概述:
                    主从结构
                        一主一从 一主多从 主从从
                        redis配置好后默认为主,我们只需要配置从库就好
                    原理
                        slave向master请求 sync命令
                        master启动后台存盘进程,收集所有修改数据命令
                        master完成存盘后,传输整个数据文件到slave
                        slave接受数据文件,加载到内存完成首次同步
                        后续有新数据产生,master继续收集数据修改命令传递给slave,完成同步

                配置主从复制

                    配置一主一从
                            查看主信息
                            ~]# redis-cli -h 192.168.4.51 -p 6351
                                192.168.4.51:6351> INFO replication
                                # Replication
                                role:master
                        配置从库
                             ~]# redis-cli -h 192.168.4.52 -p 6352
                                192.168.4.52:6352> SLAVEOF 192.168.4.52 6351  //零时配置重启失效
                                OK
                                192.168.4.52:6352> info replication
                                # Replication
                                role:slave
                                master_host:192.168.4.52
                                master_port:6351
                                修改配置文件永久配置
                             52 ~]# vim +282 /etc/redis/6352.conf
                                slaveof 192.168.4.51 6351

                        如何删除从库配置
                            删除配置文件282行内容,重启服务/在cli下 slaveof no one(零时,不删除配置文件)



                        带验证的主从复制
                            接上面实验
                            51 修改配置文件添加密码重启服务

                                vim +501 /etc/redis/6351.conf
                                    requirepass 123456
                                /etc/init.d/redis_6351 stop
                                /etc/init.d/redis_6351 start
                            52
                                 vim +289 /etc/redis/6352.conf
                                 vim +282 /etc/redis/6352.conf
                                    masterauth 123456
                                    slaveof 192.168.4.51 6351
                                 /etc/init.d/redis_6352 stop
                                 /etc/init.d/redis_6352 start
                    配置主从从

                        接上面实验

                            54 作为53的从
                                 vim +282 /etc/redis/6354.conf
                                    slaveof 192.168.4.53 6353
                                    289 由于53 没设置密码 不需要填写
                                 ~]# /etc/init.d/redis_6354 stop
                                    Stopping ...
                                    Redis stopped
                                [root@redisD-54 ~]# /etc/init.d/redis_6354 start
                                    Starting Redis server...
                                [root@redisD-54 ~]# redis-cli -h 192.168.4.54 -p 6354
                                    192.168.4.54:6354> INFO replication
                                    # Replication
                                    role:slave
                                    master_host:192.168.4.53


                redis哨兵服务

                    在不开启redis集群时,使得redis具有高可用.
                    即当主51 down 哨兵在其从库52 53 中选择新的主

                    原理:
                        监视master服务器
                        发现masterdown后将从库升级为主库
                        主配置文件 sentinel.conf
                        模板文件 redis-4.0.8/sentinel.conf

                    55 上配置哨兵服务
                        vim /etc/sentinel.conf
                            sentinel monitor server51 192.168.4.51 6351 1   //
                                             主机名     ip        服务端口 票属(多少台sentinel发现主down后切换主库,这里只有一台1)
                            bind 0.0.0.0
                            sentinel auth-pass server51  123456

                        redis-sentinel /etc/sentinel.conf  //启动哨兵服务

                        51
                        192.168.4.51:6351> SHUTDOWN
                        not connected>

                        55
                        +switch-master server51 192.168.4.51 6351 192.168.4.52 6352





                持久化

                    RDB
                        redis数据库文件 数据持久化方式之一
                        按照指定时间间隔,将内存中的数据集快照写入硬盘
                        恢复时将快照(Snapshot)直接读到内存



                    将58 59 恢复为独立服务器(按照上面方法)
                        [root@redis-G58 ~]# redis-cli -h 192.168.4.58 -p 6358
                            192.168.4.58:6358>
                            192.168.4.58:6358> keys *
                            (empty list or set)
                            192.168.4.58:6358> set a 123
                            OK
                            192.168.4.58:6358> set b
                            (error) ERR wrong number of arguments for 'set' command
                            192.168.4.58:6358> set b 256
                            OK
                            192.168.4.58:6358> set d dsfs
                            OK
                            192.168.4.58:6358> set jk 54adfs
                            OK
                            192.168.4.58:6358> SAVE
                            OK

                    使用RDB进行数据恢复

                        59  导出数据
                        [root@redis-G58 ~]# cp /var/lib/redis/6358/dump.rdb ./
                        [root@redis-G58 ~]# scp dump.rdb root@192.168.4.59:/root/

                        58 导入数据
                         /etc/init.d/redis_6359 stop
                            Stopping ...
                            Redis stopped
                        [root@redis-H59 ~]# cp ./dump.rdb /var/lib/redis/6359/
                            cp：是否覆盖"/var/lib/redis/6359/dump.rdb"？ yes
                        [root@redis-H59 ~]# /etc/init.d/redis_6359 start
                            Starting Redis server...
                        [root@redis-H59 ~]# redis-cli -h 192.168.4.59 -p 6359
                            192.168.4.59:6359> KEYS *



                RDB优缺点
                    优点
                        高性能的持久化实现

                        适合大规模的数据恢复,适合与数据完整性要求不是特别高的场合
                    缺点:

                        宕机时丢失最后一次持久化的所有数据



                AOF介绍
                    append only file

                        追加方式记录写操作的文件
                        记录redis服务的所有写操作
                        默认不启用
                        可以cat查看
                        不断将新的写操作追加写入到文件末尾

                    AOF优缺点
                        优点:
                            可以灵活设置持久化方式
                            宕机仅仅丢书1 秒的数据
                        缺点:
                            持久化文件体积通常大于rdb方式
                            执行fsync策略时速度会比较慢和rdb相比

                    启动AOF

                       58:6358> config set appendonly yes
                       58:6358> CONFIG rewrite

                       ls /var/lib/redis/6358/
                        appendonly.aof  dump.rdb

                    使用AOF文件恢复数据

                        58 备份aof
                        ~]# cp /var/lib/redis/6358/appendonly.aof ./
                        ~]# scp appendonly.aof root@192.168.4.59:/root/
                        59 启动aof
                        ~]# redis-cli -h 192.168.4.59 -p 6359
                            59:6359> CONFIG SET appendonly yes
                        OK
                            192.168.4.59:6359> CONFIG REWRITE
                        ~]# /etc/init.d/redis_6359 stop
                        ~]# cp appendonly.aof /var/lib/redis/6359/
                        ~]# /etc/init.d/redis_6359 start
                        ~]# redis-cli -h 192.168.4.59 -p 6359
                            192.168.4.59:6359> keys *

                        修复aof文件
                        将文件恢复到最后一次正确操作
                        redis-check-aof --fix /var/lib/redis/6358/appendonly.aof


                字符类型

                    string

                        > set f 18092184237
                        OK
                        192.168.4.58:6358> get f
                        "18092184237"
                        192.168.4.58:6358> SETRANGE f 4 ***  //替换从第4位,将第四位之后的三个字符替换为***
                        (integer) 11
                        192.168.4.58:6358> get f
                        "1809***4237"

                        get x
                        "8888"
                        > APPEND x 88   //追加
                        (integer) 6
                        192.168.4.58:6358> get x
                        "888888"

                        192.168.4.58:6358> setbit  bao 1 0

                            ............

                        192.168.4.58:6358> setbit  bao 8 1
                        (integer) 0

                        192.168.4.58:6358> BITCOUNT bao   //统计字符串中1的数量
                        (integer) 8



                        DECR x    // 变量自减 ,变量不存在会先将变量设定为0再自减1
                        (integer) 888887
                        DECRBY x 5 //自检步长为 5  ,不存在同上.
                        (integer) 888872

                        > SET a abcdefg
                        GETRANGE a 0 3   //取得部分数据
                        "abcd"

                        > GETRANGE a -2 -1
                        "fg"

                        > get x
                        "3"
                        192.168.4.58:6358> INCRBY x 3  //自加 步长为3
                        (integer) 6
                        192.168.4.58:6358> get x
                        "6"
                        > INCRBYFLOAT x 0.5    //自加 浮点型自加
                        "6.5

                    string 总结
                        set
                        mset key value [key value ...]          设置多个key值,空格分割,具有原子型
                        setrange
                        get key                                 返回的key中存储的字符串值,若key不存在则返回null
                        mget key [key]                          获取一个或多个key值
                        getrange key start stop                 返回字符串值中的字符串,截取范围为start和stop
                        strlen key                              统计 字符串长度
                        append key value                        存在则追加,不存在则创建key以及value,返回key长度
                        setbit key offset value                 对key所存储字符串,设置或清除指定位置的value,key不存在则创建
                        bitcount key                            统计字符串被设为1的比特位数量
                        decr    key                             将key中的值减1 key不存在则设置为0再减1
                        decrby  key decrement                   将key中的值,减去decrease
                        incr key                                将key的值增加1,如果key不存在,则初始为0后在加1
                        incrby  key increment                   将key的值增加increment
                        incrbyfloat key increment               为key中所储存的值增加浮点数量

                    list 列表类型

                        字符队列
                        先进后出
                        一个key有多个数值

                        > LPUSH mstu bobo tom jim taena lucy  // 创建表插入数据
                        > LRANGE mstu 0 3
                        1) "lucy"
                        2) "taena"
                        3) "jim"
                        > LPUSH mstu jack mack  //追加插入
                        > LRANGE mstu 0 9
                        1) "mack"
                        2) "jack"
                        3) "lucy"

                        > LPOP mstu  // 移除表头数据 key不存在返回null
                        "mack"
                        > LINDEX mstu 0 //输出指定位置数据
                        "jim"

                        > LSET mstu 2 baba //将mstu的第三个数据修改为 baba
                        OK

                        > RPUSH  mstu tttt   //在末尾添加数值
                        > RPOP mstu          //从表尾开始删除

                    list 操作总结

                    lpush  key value [value]                将一个或多个value插入到 key不存在则创建爱你 key中
                    llen   key                              返回列表key长度
                    lrange key start stop                   从开始位置读取key值到stop结束
                    lpop   key                              移除并返回表头元素数据,key不存在则返回nil
                    lindex key index                        返回表中第index个值
                    lset   key index value                  将key中index位置的值修改为value
                    rpop   key                              删除并返回key末尾的值
                    rpush  key value                        将数值 添加到key的末尾

                    hash 表

                        > hmset boot boookname xxx worker yy money 21 fx rmcbs  //创建hash表
                        > hmget  boot boookname worker          //查看hash表
                        1) "xxx"
                        2) "yy"
                                site 变量名 dc 列名 chuiha 值
                        > HMSET site dc chuiha sina www.sian.cn tarence www.tarence.com //一次插入多条数值
                        > HKEYS site //只获取列名
                        > HVALS site //只获取值
                        > HGETALL site //查看变量的全部信息
                        > DEL site   //删除数值


	主机web2（192.168.2.100）



    监控和服务安全
        DAY01  监控
                准备三台服务器 2.5 2.100 2.200
           监控的目的
                报告系统运行状态
           监控的资源类别
                公开数据(有服务)
                    web ftp ssh 数据库等应用服务
                        tcp或udp
                私有数据(无法通过端口访问的)
                    cpu 内存 磁盘 网络
                    用户 进程等运行信息
           监控软件
                Zabbix 简介
                    高度集成的监控解决方案
                    实现企业级的开源开源分布式监控
                    通过c/s模式采集监控数据
                    通过b/s模式实现web管理

                监控拓扑
                    监控主机
                        监控服务器通过snmp或者agent采集数据
                        数据可以写入mysql oracle等数据库
                        服务器使用lnmp下实现web的前端管理
                    被监控主机
                        安装agent
                        常见的网络设备支持snmp协议


                安装
                    监控主机

                        安装lnmp

                            vim +65 /usr/local/nginx/conf/nginx.conf 动静分类启动fpm后
                                额外添加如下需要写在http下任意地方 不可以写到其他 地方比如location中
                                fastcgi_buffers 8 16k;                      //缓存php生成的页面内容，8个16k
                                fastcgi_buffer_size 32k;                      //缓存php生产的头部信息
                                fastcgi_connect_timeout 300;                 //连接PHP的超时时间
                                fastcgi_send_timeout 300;                     //发送请求的超时时间
                                fastcgi_read_timeout 300;                        //读取请求的超时时间
                            systemctl restart php-fpm
                            systemctl restart mariadb
                            /usr/local/nginx/sbin/nginx
                            vim /usr/local/nginx/html/info.php  //测试网页
                                <?php
                                phpinfo();
                                ?>
                        安装 zabbix
                            [root@zabbixserver lnmp_soft]# yum -y install  net-snmp-devel \
                            > curl-devel
                            //安装相关依赖包
                            [root@zabbixserver lnmp_soft]# yum -y install  \
                            > libevent-devel-2.0.21-4.el7.x86_64.rpm
                            //注意libevent-devel这个软件包在lnmp_soft目录下有提供
                            [root@zabbixserver lnmp_soft]# tar -xf zabbix-3.4.4.tar.gz
                            [root@zabbixserver lnmp_soft]# cd zabbix-3.4.4/
                            [root@zabbixserver zabbix-3.4.4]# ./configure  --enable-server \
                            > --enable-proxy --enable-agent --with-mysql=/usr/bin/mysql_config \
                            > --with-net-snmp --with-libcurl
                            // --enable-server安装部署zabbix服务器端软件
                            // --enable-agent安装部署zabbix被监控端软件
                            // --enable-proxy安装部署zabbix代理相关软件
                            // --with-mysql配置mysql_config路径
                            // --with-net-snmp允许zabbix通过snmp协议监控其他设备
                            // --with-libcurl安装相关curl库文件，这样zabbix就可以通过curl连接http等服务，测试被监控主机服务的状态
                            [root@zabbixserver zabbix-3.4.4]# make && make install

                        导入数据库
                            [root@zabbixserver ~]# mysql
                            mysql> create database zabbix character set utf8;
                            //创建数据库，支持中文字符集
                            mysql> grant all on zabbix.* to zabbix@'localhost' identified by 'zabbix';
                            //创建可以访问数据库的账户与密码
                            [root@zabbixserver ~]# cd lnmp_soft/zabbix-3.4.4/database/mysql/
                            [root@zabbixserver mysql]# mysql -uzabbix -pzabbix zabbix < schema.sql
                            [root@zabbixserver mysql]# mysql -uzabbix -pzabbix zabbix < images.sql
                            [root@zabbixserver mysql]# mysql -uzabbix -pzabbix zabbix < data.sql
                            //刚刚创建是空数据库，zabbix源码包目录下，有提前准备好的数据
                            //使用mysql导入这些数据即可（注意导入顺序）


                        上线Zabbix的Web页面

                            [root@zabbixserver ~]# cd lnmp_soft/zabbix-3.4.4/frontends/php/
                            [root@zabbixserver php]# cp -r * /usr/local/nginx/html/
                            [root@zabbixserver php]# chmod -R 777 /usr/local/nginx/html/


                        修改Zabbix_server配置文件，设置数据库相关参数，启动Zabbix_server服务

                            [root@zabbixserver ~]# vim /usr/local/etc/zabbix_server.conf
                            DBHost=localhost
                            //数据库主机，默认该行被注释
                            DBName=zabbix
                            //设置数据库名称
                            DBUser=zabbix
                            //设置数据库账户
                            DBPassword=zabbix
                            //设置数据库密码，默认该行被注释
                            LogFile=/tmp/zabbix_server.log
                            //设置日志，仅查看以下即可
                            [root@zabbixserver ~]# useradd -s /sbin/nologin zabbix
                            //不创建用户无法启动服务
                            [root@zabbixserver ~]# zabbix_server                      //启动服务
                            [root@zabbixserver ~]# ss -ntulp |grep zabbix_server     //确认连接状态，端口10051
                            tcp LISTEN 0 128 *:10051 *:* users:(("zabbix_server",pid=23275,fd=4),("zabbix_server",pid=23274,fd=4)


                        提示：如果是因为配置文件不对，导致服务无法启动时，不要重复执行zabbix_server，
                        一定要先使用killall zabbix_server关闭服务后，再重新启动一次。
                        修改Zabbix_agent配置文件，启动Zabbix_agent服务



                            [root@zabbixserver ~]# vim /usr/local/etc/zabbix_agentd.conf
                            Server=127.0.0.1,192.168.2.5                    //允许哪些主机监控本机
                            ServerActive=127.0.0.1,192.168.2.5                //允许哪些主机通过主动模式监控本机
                            Hostname=zabbix_server                        //设置本机主机名
                            LogFile=/tmp/zabbix_server.log                    //设置日志文件
                            UnsafeUserParameters=1                        //是否允许自定义key
                            [root@zabbixserver ~]# zabbix_agentd            //启动监控agent
                            [root@zabbixserver ~]# ss -ntulp |grep zabbix_agentd   //查看端口信息为10050
                            tcp    LISTEN     0      128       *:10050                 *:*                   users:(("zabbix_agentd",pid=23505,fd=4),("zabbix_agentd",pid=23504,fd=4)


                        访问安装页面确认

                            Firefox http://192.168.2.5/setup.php


                            环境不满足则修改配置文件 或安装软件,满足

                            [root@zabbixserver ~]# yum -y install  php-gd php-xml
                            [root@zabbixserver ~]# yum install php-bcmath-5.4.16-42.el7.x86_64.rpm
                            [root@zabbixserver ~]# yum install php-mbstring-5.4.16-42.el7.x86_64.rpm
                            [root@zabbixserver ~]# vim /etc/php.ini
                            date.timezone = Asia/Shanghai                //设置时区
                            max_execution_time = 300                    //最大执行时间，秒
                            post_max_size = 32M                        //POST数据最大容量
                            max_input_time = 300                        //服务器接收数据的时间限制
                            memory_limit = 128M                        //内存容量限制

                            [root@zabbixserver ~]# systemctl restart php-fpm




                        配置文件默认在 /usr/local/etc/
                        启动命令      /usr/local/sbin/
                        程序         /usr/local/bin/

                        启动 zabbix_server     启动 zabbix_agentd


                        初始化
                            真机
                                Firefox http://192.168.2.5/setup.php

                            2.5
                                安装必须的依赖包

                                yum -y install php-bcmath.x86_64 php-mbstring.x86_64
                                yum -y install php-gd php-xml

                                修改vim /etc/php.ini
                                    date.timezone = Asia/Shanghai
                                    post_max_size = 16M
                                    max_execution_time = 300
                                    max_input_time = 300
                                systemctl restart php-fpm.service

                                Firefox http://192.168.2.5/setup.php
                                    数据库类型选择对应的
                                    数据库用户 zabbix
                                    数据库密码 zabbix
                                    数据库服务器 localhost

                                    192.168.2.5
                                    登录用户 admin
                                    登录用户密码 zabbix

                                修改配置文件 zabbix 启动服务
                                    监控主机

                                    vim /usr/local/etc/zabbix_server.conf

                                    38 LogFile=/tmp/zabbix_server.log
                                    85 DBHost=localhost
                                    95 DBName=zabbix
                                    111 DBUser=zabbix
                                    119 DBPassword=zabbix

                                    由于源码安装未指定用户

                                    useradd zabbix
                                    zabbix_server
                                    ss -antulp | grep 10051

                                安装zabbix

                                    被监控主机

                                          217  useradd -s /sbin/nologin zabbix
                                          218  yum -y install gcc pcre-devel

                                          220  yum -y install gcc pcre-devel
                                          221  ls
                                          222  tar -xf  zabbix-3.4.4.tar.gz
                                          223  cd zabbix-3.4.4/
                                          226  ./configure --enable-agent
                                          227  make && make install

                                          vim /usr/local/etc/zabbix_agentd.conf
                                              134 ServerActive=192.168.2.5:10051
                                              93  Server=127.0.0.1,192.168.2.5
                                              30  LogFile=/tmp/zabbix_agentd.log
                                          zabbix_agentd //启动agent服务
                                          ss -antulp |grep 10050

                自定义监控

                    配置客户端

                        启动自定义监控
                            vim /usr/local/etc/zabbix_agentd.conf
                                264 Include=/usr/local/etc/zabbix_agentd.conf.d/
                                 280 UnsafeUserParameters=1

                        定义监控命令
                             vim /usr/local/etc/zabbix_agentd.conf.d/user.number
                                UserParameter=user.number,wc -l /etc/passwd | awk ' {print $1} '
                        重启服务
                             killall -9 zabbix_agentd
                             zabbix_agentd
                        本机测试
                            zabbix_get -s 127.0.0.1 -p 10050 -k user.number

                    配置监控服务器
                        测试客户端定义监控
                            zabbix_get -s 192.168.2.100 -p 10050 -k user.number



           Zabbix报警机制
                触发器

                    触发器表达式

                        常用的表达式
                            sum(600) 600s内所有值的总和
                            sum(#)最后5个值的总和
                        {web1:system.cpu.load[all,avg1].last(0)}>5
                        web1主机最新的cpu平均负载大于5,触发器状态为问题状态
                    配置邮件服务器(在监控主机本机运行邮件服务器)
                        # yum -y  install postfix
                        ]# rpm -q postfix
                        ]# systemctl  start postfix
                        ]# netstat -utnlp  | grep  :25

                        //////////确认可以使用hostname访问本机///////////////

                        ]# vim /etc/hosts
                        127.0.0.1       zabbix-server  localhost localhost.localdomain localhost4 localhost4.localdomain4
                        :wq


                        ]# yum -y  install mailx
                        [root@zabbix-server ~]# which  mailx
                        /usr/bin/mailx
                        [root@zabbix-server ~]# mail -s "xxx"  zabbix  < /etc/yum.repos.d/local.repo
                        [root@zabbix-server ~]#
                        [root@zabbix-server ~]# su - zabbix
                        [zabbix@zabbix-server ~]$
                        [zabbix@zabbix-server ~]$ mail
                        Heirloom Mail version 12.5 7/5/10.  Type ? for help.
                        "/var/spool/mail/zabbix": 1 message 1 new
                        >N  1 root                  Fri Jun 28 09:48  22/734   "xxx"
                        & exit
                        [zabbix@zabbix-server ~]$ exit
                        logout

                    指定邮件服务器
                        创建Media （指定收件人）
                        创建Action   名aone
                        验证配置： 监控到主机100的用户数量大于28个时,zabbix@localhost邮箱是否收到邮件。



           Zabbix进阶操作

                自动发现
                    创建自动发现

                    创建动作

                主被动监控
                   主动监控

                   被动监控(默认)

                   配置主动监控
                        配置客户端  192.168.2.201

                            安装zabbix
                                useradd zabbix

                            修改配置文件
                                vim /usr/local/etc/zabbix_agentd.conf
                                93 #Server=127.0.0.1  //
                                118 StartAgents=0   //主动链接服务器,不需要端口
                                134 ServerActive=192.168.2.5  //监控主机
                                145 Hostname=Zabbix client web2 //主动监控模式,依靠hostname区分主机
                                183 RefreshActiveChecks=120     //自动刷新时间
                            启动服务
                                zabbix_agentd
                                ps  aux | grep agentd   //只有服务没有端口
                                ss -antulp | grep 10050

                        配置监控主机
                            登录2.5管理
                            克隆模板
                              全克隆
                            修改监控项模式


                监控案例

                    监控nginx

                        2.100安装lnmp
                            在客户端创建监控命令 nginx.status[*]

                        配置监控服务器

                            登陆监控服务的管理页面做如下配置:
                            1 创建监控模板 	Atmp2
                            2 创建应用集      mon-nginx
                            3 创建监控项 并关联到对应的监控命令
                            now_link_num  	  nginx.status[Active]
                            now_link_req	  nginx.status[accepts]
                            now_waiting_num   nginx.status[Waiting]

                            4 添加监控主机 并调用监控模板
                            5 查看监控数据
                总结:

                搭建zabbix监控服务器 : 部署lnmp 安装源码 zabbix 初始化配置 启动服务
                监控配置: 基本监控 自定义监控 邮件报警(报警媒介 触发器 动作)
                         自动发现 主被动监控
           DAY03


                linux基本防护
                  用户账户安全
                        账户安全
                             chage  更改用户密码过期信息 用户密码有效期
                                 chage –E 时间 账户名称
                                 chage –l    账户名称
                                 chage -l root //显示root的密码信息

                                 chage -l jim  //  /etc/shadow 是保存密码相关信息的文件
                                 chage -d 0 jim // -d 指定密码过期时间
                                 //强制用户使用初始密码登录必须修改密码
                                    最近一次密码修改时间					：密码必须更改
                                    密码过期时间					：密码必须更改
                                    密码失效时间					：密码必须更改


                        账户的锁定
                             passwd
                                -l 锁定账户  锁定账户后用户无法登录(对root无效)
                                -u 解锁账户
                                -S 查看状态

                        强制定期修改密码
                             /etc/login.defs  //账户密码的默认有效期
                             PASS_MAX_DAYS    99999                        //密码最长有效期
                             PASS_MIN_DAYS    0                            //密码最短有效期
                             PASS_MIN_LEN    5                            //密码最短长度
                             PASS_WARN_AGE    7                            //密码过期前几天提示警告信息
                             UID_MIN                  1000                //UID最小值
                             UID_MAX                  60000                //UID最大值

                        伪装登录提示
                             /etc/issue   //本地登录信息  默认包括系统版本 内核版本
                                为了安全,伪装登录,使之不显示 正常的系统版本和内核版本

                             /etc/issue.net  //远程登录信息
                                里面向写啥写啥 //只是伪装登录信息,登录依然可以查看正确的系统版本信息
                  文件系统安全
                        程序和服务控制
                            systemctl (7)

                            checkconfig( redhat 6 5 )   服务名  on /off  开机自启/关闭开机自启


                        锁定/解锁保护文件

                            EXT3/EXT4 文件属性控制

                                命令
                                    chattr 添加/删除
                                    lsattr 查看
                                方法
                                    + - =
                                属性 i 不可变 //可以复制

                                    a 仅可追加 //可以复制

                                当你发现 作为管理员用户 无法对某个文件操作时,
                                记得查看文件的属性
                                比如  useradd dc
                                     提示 权限不够 请检查 /etc/passwd
                                入职时检查  别名的设置 看看有没有坑

                用户切换提权
                    切换与提权的应用场景

                        切换用户
                            su
                            不是所有维护人员使用 root账户登录
                            su 日志文件 /var/log/secure 查看谁使用过 su

                            su 单独使用时 要求 当前管理员 密码 只将用户切换过来,环境没变
                            su -  用户和环境都变化
                             -c 使用命令

                            su - -c "command" user
                            EG:
                            su  -c "/usr/local/nginx/sbin/nginx " root

                        提权
                            sudo

                            配置文件
                                visudo
                                vim /etc/sudoers

                            提权格式
                                修改配置文件
                                用户 主机列表=命令列表
                                %名字 //用户组

                                root    ALL=(ALL)       ALL
                                用户     主机=命令
                                %wheel  ALL=(ALL)       ALL
                                wheel用户组 可以在任何地点使用任何命令以ROOT权限

                            普通用户查看提权命令
                                sudo -l
                                查看用户可以使用的提权命令




                            普通用户执行提权命令
                                vim /etc/sudoers

                                    添加如下,使得可以 sudo时不需要输入密码
                                    mike   localhost,dba=/sbin/* , !/sbin/ifconfig eth0 , NOPASSWD:ALL

                                启用sudo日志
                                    vim /etc/sudoers
                                    添加如下,之后sudo命令将会被记录
                                        Defaults logfile="/var/log/sudo"
                                    cat /var/log/sudo
                                        Jun 29 14:57:35 : mike : command not allowed ; TTY=pts/1 ; PWD=/home/mike ;
                                        USER=root ; COMMAND=/sbin/ifconfig eth0
                        sudo别名设置
                                /etc/sudoers
                            提高利用率 易读性

                                用户 User_Alias OPERATORS=jerry,tom,alice
                                主机 Host_Alias MAILSERVERS=localhost,dba
                                命令 Cmnd_Alias SOFTMGR=/usr/bin/rpm , /usr/bin/yum , /usr/bin/vim , /etc/my.cnf , /usr/bin/systemctl * mysqld

                                调用
                                    OPERATORS MAILSERVERS=SOFTMGR , NOPASSWD:ALL



                ssh访问控制
                    修改ssh默认访问端口
                        vim /etc/ssh/sshd_config
                            17  Port 3389     //登录端口
                            37  LoginGraceTime 2m //登录限时
                            40  MaxAuthTries 3  //最多认证次数
                            115 UseDNS no       //不解析客户机地址
                        systemctl restart sshd

                        使用新终端链接
                             ssh root@192.168.4.50 -p 3389
                    ssh黑白名单

                        修改配置文件

                        vim /etc/ssh/sshd_config

                            DenyUsers user1 user2
                            AllowUsers user1@host user2@localhost
                            DenyGroups  group1 group2
                            AllowGroups group1 group2

                        eg:
                        vim /etc/ssh/sshd_config
                            AllowUsers root@192.168.4.50 alice
                            允许4.50以root登录本机,且 alice用户不受限制登录
                    口令验证

                        PasswordAuthentication yes  //密码验证  默认开启
                    启动密钥对登录
                        PubkeyAuthentication yes    //秘钥检查
                部署ssh公钥
                    生成公钥
                        指定加密算法 -t rsa -t dsa
                    ssh-keygen
                    ssh-keygen -f /root/.ssh/id_rsa -N ''  -f 指定秘钥位置  -N 提供新密码 '' 表示无密码.为空

                    ssh-copy-id ip
                selinux安全

                    sestatus  //查看selinux 状态
                        SELinux status:                 enabled
                        SELinuxfs mount:                /sys/fs/selinux
                        SELinux root directory:         /etc/selinux
                        Loaded policy name:             targeted  //保护常用的服务; mls 全方位保护;
                        Current mode:                   enforcing
                        Mode from config file:          error (Success)
                        Policy MLS status:              enabled
                        Policy deny_unknown status:     allowed
                        Max kernel policy version:      31

                    getenforce
                    setenforce 1/0  //零时开启或者关闭 selinux 强制模式



                策略设置

                    安全上下文
                        属性构成
                            用户:角色:访问类型:选项
                            system_u:object_r:bin_t:s0       /bin/ls

                        查看
                            文件
                                ls -lZ  文件名
                            目录
                                ls -ldZ 目录名
                            进程
                                ps aux -Z
                                ps aux -Z | grep -i 服务名
                        修改安全上下文
                            chcon
                                -t 指定访问类型
                                -R 递归修改
                                                      admin_home_t  为安全上下文的 文件规则
                              -rw-r--r--. root root unconfined_u:object_r:admin_home_t:s0 a3.html
                              html]# chcon -t httpd_sys_content_t a3.html

                        一般操作规则
                            创建的文件,一般是继承父级目录的安全上下文
                            移动的文件,原有的上下文属性不变
                            复制的文件,自动继承目标位置的上下文

                        恢复安全上下文

                            restorecon
                             -R 递归修改


                             html]# ls -Z
                            -rw-r--r--. root root unconfined_u:object_r:admin_home_t:s0 a1.html
                            -rw-r--r--. root root unconfined_u:object_r:admin_home_t:s0 a.html
                             html]# restorecon a.html a1.html
                             html]# ls -Z
                            -rw-r--r--. root root unconfined_u:object_r:httpd_sys_content_t:s0 a1.html
                            -rw-r--r--. root root unconfined_u:object_r:httpd_sys_content_t:s0 a.html
                             html]#

                        重置安全上下文

                             /.autorelable  文件
                             下次重启 安全上下文自动重置
                        调整SElinux 布尔值
                            查看
                                getsebool
                                -a 列出所有的布尔值
                            使用
                                setsebool
                                -P 永久修改 重启有效

                                eg:    54  getsebool |grep ftp
                                            ftpd_anon_write --> off
                                            ftpd_full_access --> off
                                       55  getsebool -a |grep ftp
                                       56  setsebool -P ftpd_anon_write on
                                       57  setsebool -P ftpd_full_access on
                                       58  getsebool -a |grep ftp
                                            ftpd_anon_write --> on
                                            ftpd_full_access --> on

                                在启selinux的系统上修改默认端口
                                     这里以 httpd为例子

                                     systemctl restart httpd.service

                                     在message中有semanage信息需要下面三个软件
                                     rpm -qa | grep setroubleshoot
                                        setroubleshoot-plugins-3.0.66-2.1.el7.noarch
                                        setroubleshoot-server-3.2.29-3.el7.x86_64
                                        setroubleshoot-3.2.29-3.el7.x86_64

                                查看semanage的日志
                                    注意最后面的 sealert -l xxxxxx 这是日志文件
                                       查看日志文件
                                    grep setroubleshoot /var/log/messages | tail -1

                                        Jul  2 09:18:14 localhost setroubleshoot: SELinux is preventing httpd from getattr
                                        access on the file /var/www/html/a3.html.
                                        For complete SELinux messages run: sealert -l 54c353ed-077e-4511-88df-1f0cfd39a4d7

                                    sealert -l 54c353ed-077e-4511-88df-1f0cfd39a4d7
                                        找到 do 如下添加端口命令

                                添加 semanage 管理的端口
                                    semanage -l //查看所有的semange端口
                                    semanage port -a -t http_port_t -p tcp 8089


                            fpt 上传

                                ftp 192.168.4.80
                                    [root@room9pc01 ~]# ftp 192.168.4.80
                                    Connected to 192.168.4.80 (192.168.4.80).
                                    220 (vsFTPd 3.0.2)
                                    Name (192.168.4.80:root): ftp
                                    331 Please specify the password.
                                    Password:
                                    230 Login successful.
                                    Remote system type is UNIX.
                                    Using binary mode to transfer files.

                                    ////////进入fpt共享目录///////

                                    ftp> cd share
                                    250 Directory successfully changed.
                                    ////////目标文件目录/////////

                                    ftp> lcd /var/log/
                                    Local directory now /var/log
                                    ftp> put vmware-vmusr.log
                                    local: vmware-vmusr.log remote: vmware-vmusr.log
                                    227 Entering Passive Mode (192,168,4,80,244,48).
                                    150 Ok to send data.
                                    226 Transfer complete.
                                    47892 bytes sent in 0.0562 secs (852.76 Kbytes/sec)




           DAY04

                加密与解密
                    加密的方式
                        对称加密
                            加密解密使用同一个密钥
                        非对称加密
                            加密解密使用不同密钥
                                公钥 加密
                                私钥 解密

                        保护数据完整性
                            只要数据不发生改变 这个值就不会变化
                                MD5
                                SHA

                        常见的加密算法
                            对称  DES/AES
                            非对称 RSA/DSA

                        GPG 加密解密
                            GnuPG  介绍
                                最流行的数据加密,数字签名工具,支持对称加密和非对称加密

                            安装
                                 ~]$ yum -y install gnupg2
                            检查
                                 ~]$ gpg --version

                            生成秘钥
                                 ~]$ gpg --gen-key
                                  设置用户信息 加密类型
                                  查看已有秘钥
                                     ~]# gpg --list-keys
                                  默认位置
                                      gpg: /home/b/.gnupg/trustdb.gpg：建立了信任度数据库
                                      pubring.gpg 公钥文件  secring.gpg 私钥文件  trustdb.gpg 信任文件

                            传递秘钥
                                将生成的秘钥导出
                                    --export 导入 -a   userb 生成秘钥时填的用户
                                    ~]#  gpg --export -a userb > /tmp/userb.pub
                                导入秘钥
                                    将生成的秘钥传递给需要的机器并导入
                                    ~]# gpg --import /tmp/userb.pub

                            加密
                                 --encrypt    加密操作
                                 --decrypt        解密操作
                                 --recipient  指定用户
                                ~]$ gpg -e -r userb a.txt

                            解密
                                ~]$ gpg -d a.txt.gpg > a.txt
                                    输入 userb.pub 的密码



                        GPG签名
                            软件官方以私钥对文件签名,
                            用户下载软件包 软件官方的公钥
                            以公钥验证软件签名 确保数据来源正确

                            签名
                                分离式签名  --detach-sign / -b
                                   ~]$ gpg -b b.txt
                                验证       --verify
                                   ~]$ gpg --verify /tmp/b.txt.sig


                AIDE入侵检测
                    AIDE 入侵检测软件 配置yum即可安装aide
                        安装
                            ~]$ gpg --verify /tmp/b.txt.sig
                        默认配置文件位置
                            /etc/aide.conf
                        修改配置文件
                            ~]# vim /etc/aide.conf
                                注释 99一下
                                添加/root/ FIPSR   //FIPSR为配置文件检测项目,/root/ 为检测目录
                        初始化配置
                            ~]# aide --init
                            生成检测文件
                        日志文件
                             /var/lib/aide/aide.db.new.gz       由aide生成的检测文件,需要保存好

                             /var/lib/aide/aide.db.gz      aide 对比入侵检测时需要查看的文件,配置文件中定义,该文件是第一次初始化时生成的文件
                        检测
                            ~]# aide --check

                        配合审计功能,就可以谁操作过,成功了没有


                扫描与抓包

                    获取一些公开/非公开信息为目标
                        检测潜在风险
                        查找可攻击目标
                        收集设备/主机/系统/软件
                        发现漏洞


                        有许多开源的扫描软件

                            Scan  主动探测
                            Sniff 被动检测
                            Capture  数据包捕获

                        常见的安全分析工具

                            扫描器
                                NMAP
                                    多端口
                                    ping 扫描
                                    tcp/ip指纹校验
                                    等
                                命令
                                    nmap [扫描类型] [选项] <扫描目标>
                                        默认扫描tcp 连接
                                常用扫描类型
                                    -sS, tcp SYN 半开扫描
                                    -sT  tcp 连接扫描 全开扫描
                                    -sU  UDP 扫描
                                    -sP  ICMP 扫描
                                    -A   目标系统全面分析  复合指令 = -O -sV -sC traceroute跟踪
                                选项
                                    -n 不解析域名,使用ip
                                    -p [端口]
                                    eg: nmap -p 20-110 ip
                                        nmap -p 3306,80 ip
                                安装

                                    yum -y install nmap

                                扫描
                                    nmap -sS 176.233.*  //半开扫描
                                    nmap -p 3306,80 192.168.4.55  //指定端口扫描
                        抓包工具
                                协议分析
                                常见的软件
                                tcpdump WIREShark

                                tcpdump
                                    命令行抓包工具
                                    基本用法
                                        tcpdump [选项] [过滤条件]
                                    常见监控选项
                                        -i 指定监控端口(网卡端口)
                                        -A 转化为ACSII码,以方便阅读
                                        -W 将数据包信息保存到指定文件
                                        -r 从指定文件读取数据包信息
                                        -c 定义抓包个数


                                    过滤条件
                                        -类型 host net port portrange
                                        -方向 src dst
                                        -协议 tcp udp ip wlan arp icmp
                                        -多个条件组合 and or not


                                    eg: tcpdump -c 100 -i private1
                                         ~]$ sudo tcpdump -c 1 -i private1 -w one.cap -A
                                         ~]$ tcpdump -A -r one.cap  //查看



                                        tcpdump -i eth0 tcp port 110 -c 10

                                    搭建并抓包
                                          55
                                        安装ftp
                                               yum -y install vsftpd

                                               systemctl restart vsftpd
                                               ss -antulp | grep 21
                                               useradd test  //设置ftp登录用户
                                               echo 12346 |passwd --stdin test //登录密码

                                               cp mysql-community-client-5.7.17-1.el7.x86_64.rpm /home/test/
                                               chmod +r /home/test/mysql-community-client-5.7.17-1.el7.x86_64.rpm
                                        抓包
                                        ~]# tcpdump -i eth0 -A tcp port 21 -w ftp.cpa

                                        查看
                                            当ftp登录成功后可以有文件查看

                                        ~]# tcpdump -A -r ftp.cpa | egrep -i '(user|pass)'

                                            reading from file ftp.cpa, link-type EN10MB (Ethernet)
                                            //////注意这行 结束明文用户///////////////////////
                                            17:11:31.517723 IP 192.168.4.254.44550 > redisE-55.ftp: Flags [P.], seq 1:12, ack 21, win 229, options [nop,nop,TS val 32432672 ecr 28072882], length 11: FTP: USER test
                                            ... ..[.USER test
                                            17:11:31.517835 IP redisE-55.ftp > 192.168.4.254.44550: Flags [P.], seq 21:55, ack 12, win 227, options [nop,nop,TS val 28076695 ecr 32432672], length 34: FTP: 331 Please specify the password.
                                            ..j.... 331 Please specify the password.
                                            //////注意这行 结束位置明文密码////////////////////
                                            17:11:33.373714 IP 192.168.4.254.44550 > redisE-55.ftp: Flags [P.], seq 12:25, ack 55, win 229, options [nop,nop,TS val 32434528 ecr 28076695], length 13: FTP: PASS 123456
                                            ...`..j.PASS 123456
                                            17:11:36.529689 IP redisE-55.ftp > 192.168.4.254.44550: Flags [P.], seq 77:115, ack 31, win 227, options [nop,nop,TS val 28081707 ecr 32437684], length 38: FTP: 530 Please login with USER and PASS.
                                            ..~+....530 Please login with USER and PASS.



                                        真机 4.254
                                            访问ftp
                                                安装命令行工具
                                                    yum -y install ftp
                                                登录ftp
                                                    ftp 192.168.4.55
                                                    Connected to 192.168.4.55 (192.168.4.55).
                                                    220 (vsFTPd 3.0.2)
                                                    Name (192.168.4.55:student): test
                                                    331 Please specify the password.
                                                    Password:
                                                    530 Login incorrect.
                                                    Login failed.
                                                    ftp>
                                wireshark

                                    需要图形支持

                                    安装软件
                                        yum -y install wireshark wireshark-gnome.x86_64

                                    启动
                                        wireshark

                                        绿色的 选择 网卡 三角(表示监听)


           DAY05

                系统审计
                    什么是审计
                        基于事先配置的规则生成日志,记录可能发生在系统上的事件
                        审计不会为系统提供额外的安全保护,但会发现并记录违法安全策略的人及其对应的行为
                        审计能够记录的日志内容
                            日期,事件 ,结果
                            触发事件的用户
                            所有认证机制的使用都可以被记录 eg:ssh
                            对关键数据文件修改行为


                    部署audit

                        审计系统需要安装audit软件包
                        开启后无法关闭
                        主配置文件
                            /etc/audit/audit.conf
                        日志文件
                            /var/log/audit/audit.log
                        规则文件
                            /etc/audit/audit.rules
                        ausearch 工具  根据条件过滤日志
                        aureport 工具  将记录的信息生成报表

                        安装
                           yum -y install audit
                           systemctl start auditd
                           systemctl enable auditd

                        auditctl常用
                        选项

                            auditctl -l  //查询规则
                            auditctl -s  //查看状态
                            auditctl -D  //删除所有规则

                        定义临时规则
                            auditctl -w  path permission -k key_name
                                 -path 需要审计的文件/目录
                                 权限可以是 rwxa 文件/目录 属性变化
                                 key_name 可选项 方便识别那些规则生成特点日志项目

                                设置规则对所有passwd文件的写和属性修改操作 都会记录于日志文件
                                eg:  auditctl -w /etc/passwd -p wa -k passwd_change ///监控passwd文件,的写/属性修改
                                     auditctl -w /etc/selinux/ -p wa -k selinux_change /// 监控/etc/selinux目录
                        定义永久规则
                            写入配置文件/etc/audit/rules.d/audit.rules

                            vim /etc/audit/rules.d/audit.rules

                                -w /etc/passwd -p wa -k passwd_change







                        搜索日志
                            命令
                                ausearch option -if file_name
                                -i 交互式
                                -if file_name //指定文件名

                            eg: ausearch -k disk_partition
                                arch=c000003e syscall=59 success=yes exit=0 a0=19b5b50 a1=18edd60 a2=198cd50 a3=7ffcc5ec7520
                                items=2 ppid=6429 pid=6479 auid=0 uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0
                                tty=pts2 ses=26 comm="fdisk" exe="/usr/sbin/fdisk"
                                subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 key="disk_partition"

                             我们主要观察 uid gid comm exe  key  a1-a4(命令参数)这几项

                服务安全

                    安装源码
                        nginx 并运行服务
                        这里不在说明,参考project1
                    nginx 优化

                        关闭默认安装时 加入的 两个模块 提高安全性

                            /usr/local/nginx/sbin/nginx -s stop
                            [root@localhost nginx-1.12.2]# ./configure \
                            > --without-http_autoindex_module \   // 会将网站更目录下的全部文件暴露给公网
                            > --without-http_ssi_module
                            make && make install
                            /usr/local/nginx/sbin/nginx

                        修改nginx版本信息

                            修改源码包中的版本信息 (在头部文件)
                                http]# cd /root/nginx-1.12.2/src/http
                                http]# vim +48 ngx_http_header_filter_module.c
                                     修改server后的部分
                                        static u_char ngx_http_server_string[] = "Server: tomcat" CRLF;
                                        static u_char ngx_http_server_full_string[] = "Server:tomcat "  CRLF;
                                        static u_char ngx_http_server_build_string[] = "Server:tomcat "  CRLF;

                            重新安装删除不需要的部分
                                 /usr/local/nginx/sbin/nginx -s stop
                                nginx-1.12.2]# ./configure \
                                > --without-http_autoindex_module \   // 会将网站更目录下的全部文件暴露给公网
                                > --without-http_ssi_module
                                make && make install
                                /usr/local/nginx

                            限制并发

                                由于安装使没有取消ngx_http_limit_req_module的安装导致ddos攻击风险增加
                                     --该模块可降低ddos风险
                                     通过修改配置来限制这个模块

                                    vim /usr/local/nginx/conf/nginx.conf

                                      http{

                                               ////$binary_remote_addr 为 nginx内置的函数 ---记录用户ip
                                               ////zone=one 定义名为 one的内存空间 10 Mb  每秒处理一个请求 r --request
                                        limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;
                                           server{
                                            ....
                                            limit_req zone=one burst=5;
                                            .....
                                              }
                                      }
                                    /usr/local/nginx/sbin/nginx -s stop
                                    /usr/local/nginx/sbin/nginx


                            拒绝非法请求

                                禁用其他只允许  get/post 请求

                                    vim /usr/local/nginx/conf/nginx.conf
                                        http{
                                        server {
                                            listen       80;                 匹配不到 get/post 时为真
                                            if ($request_method !~ ^(GET|POST)$){  ///正则: ~ 表示: 按位取反// ! 逻辑否

                                                    return 444'

                                            }
                                        .....
                                            }
                                        }


                                    测试
                                            curl -i -X HEAD http://192.168.4.80/
                                            curl -i -X GET http://192.168.4.80/

                        防止buff溢出

                            防止客户端请求数据溢出
                            有效降低机器dos攻击风险

                                    vim /usr/local/nginx/conf/nginx.conf

                                        http{
                                            ...
                                        client_body_buffer_size 1K;
                                        client_header_buffer_size 1K;
                                        client_max_body_size 16K;
                                        large_client-header_buffers 4 4K;
                                              ...
                                               }



                数据库安全
                    mysql 就没有这些 问题
                    mariadb
                        初始化安全脚本
                            配置root密码
                            删除匿名账户
                            禁止远程root登录
                            删除测试库
                            刷新权限
                            ///////////
                            #~ mysql_secure_installation
                            输入密码 ....

                        修改数据库密码
                            ~]# mysqladmin -uroot -pgaoyuan password 'mysql'
                                                    旧密码             新密码
                            或者

                            MariaDB [(none)]> set password for root@"localhost"=password('redhat')

                            mariadb 5.6 版本之前的 binlog日志中 有明文密码

                            并且bashde历史记录中也会记录操作命令

                            ]# cat .bash_history
                               ....
                               mysqladmin -uroot -pxxx password 'redhat'
                               ....
                            ]# cat .mysql_history
                                ...
                                grant all on wordpress to wordpress identified by "wordpress";
                                ...
                            需要定时删除历史记录

                        数据安全
                            创建可以远程登录的账户
                                ~]# mysql -uroot -p
                                MariaDB [(none)]> grant allon *.* to t4om@"%" identified by "123";
                            使用tcpdump抓包

                                ~]# tcpdump -w log.cap -i eth0 src or dst port 3306
                            客户端远程登录数据库
                                ~]# mysql -h 192.168.4.23 -utom -p123
                                ~]# tcpdump -A -r log.cap

                            使用ssl/ssh加密数据传输



                    tomcate


                        安装tomcat

                            你需要 openjdk的支持

                                 yum -y install java-1.8.0-openjdk
                                 java -version
                                 解包 tomcat
                                 复制到  /usr/local/tomcat/
                                 确保防火墙关闭 selinux 状态
                                 启动tomcat
                                 /usr/local/tomcat/bin/startup.sh
                                 检查Tomcat的端口
                                 ss -antulp | grep 8080
                                 访问测试
                                 curl -I http://192.168.4.80:8080/a.html

                        修改tomcat配置文件隐藏 tomcat版本信息
                             安装
                                 yum -y install java-1.8.0-openjdk-devel

                                 which jar  //需要使用jar 解压

                             修改配置文件
                                  ~]# /usr/local/tomcat/bin/shutdown.sh
                                  ~]# cd /usr/local/tomcat/lib/
                                  lib]# jar -xf catalina.jar
                                  lib]# vim org/apache/catalina/util/ServerInfo.properties

                                        server.info=APPLE.INC
                                        server.number=7.4.41.0
                                        server.built=2018.01

                                  lib]# vim +69 /usr/local/tomcat/conf/server.xml

                                            <Connector port="8080" protocol="HTTP/1.1"
                                            connectionTimeout="20000"
                                            redirectPort="8443" server="apple" />

                                  lib]# /usr/local/tomcat/bin/startup.sh

                                  访问测试
                                  curl -I http://192.168.4.80:8080/a.html
                                    .....
                                    Server: apple
                                    .....

                             降权启动

                                 添加用户并指定启动用户

                                 useradd tomcat
                                 chmod -R tomcat:tomcat /usr/local/tomcat/
                                 su -c "/usr/local/tomcat/bin/startup.sh"  tomcat

                                开机启动

                                    lib]# chmod +x /etc/rc.local
                                    lib]# vim /etc/rc.local
                                    su -c "/usr/local/tomcat/bin/startup.sh"  tomcat   ##指定用户启动

                                    测试
                                    ps aux | grep tomcat

                                    删除默认测试页面
                                    ]# rm -rf /usr/local/tomcat/webapps/*
                                    默认测试页面可以查看到详细的Tomcat详细




                            EOF end of file


                            cat  << EOF

                                EOF

                            yum -y install expect

                                spawn ssh 192.168.4.80
                                expect  << EOF
                                expect "#"    {send "systemctl restart httpd"}  //需要expect支持
                                EOF

                            eg:
                                    #!/bin/bash
                                    expect <<EOF
                                    spawn ssh 192.168.4.23
                                    expect ":" {send "123456\r"}
                                    expect "#" {send "useradd lisi\r"}
                                    expect "#" {send "id lisi\r"}
                                    expect "#" {send "passwd lisi\r"}
                                    expect " 密码：" {send "gaoyuan\r"}
                                    expect " 密码：" {send "gaoyuan\r"}
                                    expect "#" {send "id lisi\r"}
                                    expect "#" {send "exit\r"}
                                    EOF


                安装补丁

                    diff  逐行比较

                        -u               输出统一内容的头部信息 (打补丁使用)
                        -r或--recursive  递归比较目录中的所有资源 可以比对目录
                        -a               所有文件视为文本 (包括二进制程序)
                        -N               无文件视为空

                        一般者几个选项是连用的



                        环境准备

                              mkdir -p demo/source1 demo/source2
                              cd demo/
                              echo "hello word" > source1/test.sh
                              echo "hello the word" > source2/test.sh
                              echo "test" > source2/tmp.txt
                              cp /bin/find source1/
                              cp /bin/find source2/
                              echo 1 >> source2/find
                              yum -y install tree.x86_64

                              [root@4_80 ~]# tree demo/
                                demo/
                                ├── source1
                                │   ├── find
                                │   └── test.sh
                                └── source2
                                    ├── find
                                    ├── test.sh
                                    └── tmp.txt
                                //创建补丁文件
                              [root@4_80 ~]# diff -rNau demo/source1/ demo/source2/ > /tmp/x2.patch

                                将模拟的第一版程序和补丁文件传递给 客户端,安装补丁需要patch的支持
                                    yum -y install patchutils.x86_64

                              [root@4_80 ~]# scp -r demo/source1/ root@192.168.4.81:/root/demo/

                              [root@4_80 ~]# scp /tmp/x2.patch root@192.168.4.81:/root/

                                      patch -px   补丁文件中的路径与当前目录重复了几个x 就填几个
                                      补丁文件中demo/source1/tmp.txt, 当前我在/ 下则x为0
                              [root@4_81 ~]# patch -p0 < /root/x2.patch
                                       //撤销补丁
                              [root@4_81 ~]# patch -RE  < /root/x2.patch

                              当我们进入/root/demo/source1 后再次使用 patch更新, 补丁文件中demo/source1/tmp.txt
                              所以 -p2
                              [root@4_81 source1]# patch -p2 < /root/x2.patch


           DAY06 防火墙

                 iptables     RHEL7使用Firewalls\IPtables 防火墙实现 软件防火墙\硬件防火墙

                 环境准备
                 准备三台  ip如下 4网段eth0 2网段eth1 a: 4.80 and 2.80 b: 4.81 c:2.81

                        b和c分别设置网关为 4.80 / 2.80(零时配置),并开启linux的内核路由转发


                        命令:
                            a服务器
                                 sysctl -a | grep -i ip_forward

                                 vim /etc/sysctl.conf
                                    添加如下
                                    net.ipv4.ip_forward = 1
                                 也可以使用 sysctl -w net.ipv4.ip_forward=1

                            b服务器
                                 systemctl stop NetworkManager
                                 route add default gw 192.168.4.80
                                 route -n
                            c服务器
                                 systemctl stop NetworkManager
                                 route add default gw 192.168.2.80
                                 route -n
                                 b和c 相互ping 通了表示 网关配置成功
                 防火墙四表五链
                 IPtables
                        安装如下软件包
                            iptables-services-1.4.21-24.el7.x86_64 防火墙服务端
                            iptables-1.4.21-24.el7.x86_64          管理防火墙

                        防火墙的组成

                            由四张表, 五条链(匹配数据的传输方向)构成

                            状态跟踪        包标记表                    地址转发            过滤表
                             raw表         mangle表                   nat表               filter 表
                             PREROUTING   PREROUTING(路由前处理)       PREOUTING             INPUT
                             OUTPUT       POSTROUTING(路由后处理)      PREOUTING            FORWARD
                                            INPUT
                                            OUTPUT                    OUTPUT               OUTPUT
                                           FORWARD

                        包匹配流程
                            匹配即停止(log除外)
                            若无任何匹配则安装该链的默认策略处理
                        IPtables 基本用法

                            位置 /sbin/iptables
                            指令  iptables [-t 表名] 选项 [链名] [条件] [-j 目标操作]

                            iptables -t filter -i INPUT -p icmp -j REJECT

                            常用的管理选项
                                添加规则
                                        -A              在链的末尾追加一条规则
                                        -I              在链的开头(或指定序号)char插入规则
                                        -L              列出所有的规则条目
                                查看规则
                                        -n              以数字形式显示地址 端口的选信息
                                        --line-number   查看规则时显示规则序号
                                删除规则
                                        -D              删除链内指定序号(或内容)的一条规则
                                        -F              情况所有的规则
                                默认策略
                                        -P              为指定的链设置默认规则
                            基本的 目标操作
                                 ACCEPT         允许通过/方行
                                 DROP           直接丢弃,不给出任何回应
                                 REJECT         拒绝通过,必要时会给出提示
                                 LOG            记录日志然后传递给下一条规则


                            基本的匹配条件



                            保存  iptables-save > /etc/sysconfig/iptables


                            filter 表

                                                                    --dport 目标端口  -j 操作类型
                                 iptables -t filter -A INPUT -p tcp --dport 22 -j ACCEPT
                                 iptables -t filter -P INPUT DROP   // 将filter表的 INPUT链的默认操作设置为DROP
                                 iptables -t filter -nL INPUT --line-number
                                     Chain INPUT (policy DROP)
                                     num  target     prot opt source               destination
                                     1    ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:22

                                 iptables -t filter -A INPUT -p tcp --dport 22 -j ACCEPT    //行尾追加

                                 iptables -t filter -I INPUT -p icmp -j ACCEPT //接受全部的 icmp 请求

                                 iptables -t filter -I INPUT -p icmp -s 192.168.4.254 -j DROP //拒绝4.254icmp -I 行首插入

                                 iptables -t filter -nL --line-number
                                    Chain INPUT (policy DROP)###### 默认策略
                                    num  target     prot opt source               destination
                                    1    DROP       icmp --  192.168.4.254        0.0.0.0/0
                                    2    ACCEPT     icmp --  0.0.0.0/0            0.0.0.0/0
                                    3    ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:22

                                 iptables -t filter -I INPUT -p icmp --icmp-type echo-request -j REJECT  //拒绝对本机所有的icmp request 请求

                                 iptables -t filter -A INPUT -m multiport -p tcp --dports 21,8089,3306 -j ACCEPT //允许多端口 混合端口

                                 iptables -t filter -I INPUT -m mac --mac-source 52:54:00:49:2d:5c -j DROP // 拒绝 设定的 mac地址 主机访问

                                 iptables -t filter -I INPUT -p tcp --dport 22 -m iprange --src-range 192.168.4.250-192.168.4.254 -j ACCEPT // 允许ip段访问


                            nat表

                                准备 2.81

                                   yum -y install httpd
                                   echo "<H1>I AM WEB2.81 "  > /var/www/html/a.html
                                   systemctl restart httpd
                                   crul http://loccalhost/a.html
                                   curl http://loccalhost/a.html
                                   curl http://192.168.2.81/a.html
                                   tailf /etc/httpd/logs/access_log

                                配置SNAT共享上网


                                    iptables -t nat -A POSTROUTING -s 192.168.4.0/24 -p tcp --dport 80 -j SNAT --to-source 192.168.2.80


                                动态网络地址转换

                                    iptables -t nat -A POSTROUTING -s 192.168.4.0/24 -o eth1 j MASQUERADE





推荐博客: http://www.jinbuguo.com/
######################################################
SHELL SCRIPT  SHELL 脚本(目前不做要求,之后会专门讲)
脚本:一个可以执行的文件,运行可以实现某种功能(类似于某种程序)
[root@server0 ~]# vim /root/helooworld.sh  #创建脚本
[root@server0 ~]#chmod ugo+x /root/helooworld.sh  #赋予执行权限
[root@server0 ~]# /root/helooworld.sh  #绝对路径执行
	echo hello world !
	uname -r > /root/name.txt
	cat /etc/redhat-release >> /root/name.txt
	cat /root/name.txt

Shell脚本的组成 
练习题 请查看 ENGERINGER---01练习题
#! 环境声明  #! /bin/bash
# 注释文本
# 可执行代码
eg:
	#!/bin/bash
	uname -r #查看内核信息
	hostname #查看主机名称 ###vim  /etc/hostname  主机名位置

	cat /etc/redhat-release #查看 系统信息
	ifconfig | head -2  #查看ip
	grep bin /etc/passwd | tail -2

变量
 以不变的名称存放变化的值
 如何创建变量
   变量名=存放值
   变量名要求:  = 两边不能有空格 (shell规定) 
		变量名只能由数字字母下划线组成,区分大小写且不能以数字开头(用户不可以 系统可以),
		不要使用关键词作为名字,
		若变量名已存在,则会对该变量重新赋值
 调用变量 
     $变量名 
     ${变量名}	 ########变量与常量结合
eg:
	[root@server0 ~]# a=10086
	[root@server0 ~]# echo $a
	10086
	[root@server0 ~]# a=redhat
	[root@server0 ~]# echo ${a}7  ########变量与常量结合
	redhat7
变量分类(运维角度)
环境变量 : 变量名大写,变量的值有系统定义完成(有系统完成,开机的过程中定义完成)
	PWD PAHT USER LOGNAE SHELL HOME
                  当前登录用户
位置变量 : 执行脚本时提供命令行参数 ,系统自动完成
	表示$n, n为序号
	在执行脚本时 后接的第一个参数 会传递给 $1
	[root@server0 ~]# vim /root/user.sh
	echo successfuly useradd $1      参数
	[root@server0 ~]# /root/user.sh nsd001
 	###########################################
	[root@server0 ~]# vim /etc/cat.sh
	#~/bim/bash
	cat -n $1 | head -$2   head / tail 默认显示前10行
	[root@server0 ~]# /etc/cat.sh /etc/passwd

shell 交互 信息
   read 
	1.直接产生交互
	2.记录用户在键盘上的输入
	3.讲用户在键盘的输入复制给一个变量储存
eg:设定用户名和密码创建用户
	[root@server0 ~]# vim /root/user.sh
	[root@server0 ~]# vim /root/user.sh
	#!/bin/bash
	# echo 请输入USERNAME
	read -p ':请输入USERNAME' a
	read -p ':PASSWD' b

	#echo 请输入PASSWD
	#read b
	#read -p 请输入USERNAME
	#read -p 请输入PASSWD

	
预定义变量
	useradd $a &> /dev/null   ### &>  将错误信息和正确信息传递给 下一部
	echo successfuly useradd $a
	echo $b | passwd --stdin $a &> /dev/null
	echo successfuly passwd $a
	        
	$# 统计用户的输入信息(if判断 常用)
	[root@server0 ~]# /root/1.txt 1 2 3 4 5 6 
	#!/bin/bash
	echo $1
	echo $2
	echo $# ###统计输入参数的数量
	1
	2
	6
	$?程序退出后状态显示  (if 判断中 命令是否成功)
	0 正常 
	非0 不正常
自定义变量
   用户自己定义 



重定向输出  #####面试常考
(补充追加重定向>>)
 > 只收集正确输出
 2> 只收集错误输入
 &> 收集所有输出
>&2  将正确输出转化为错误 输出
补充: 
  单引号 ''  屏蔽所有的特殊符号 原样输出
  $(hostname) 将变量作为一个参数
 
   反撇号`` 或者$() : 将命令的输出,直接参与下次运行
   	[root@server0 ~]# mkdir /$(hostname)
	[root@server0 ~]# ls /
	bin   dev  home  lib64  mnt  proc  run   server0.example.com  sys  usr
	boot  etc  lib   media  opt  root  sbin  srv                  tmp  var
eg: 创一个以当前日期为名的目录
	[root@server0 ~]# mkdir mydate-$(date +%F)  
#####date +%F 注意这里的+%F   
显示完整日期 [student@gao ME]$ date +%F  2019-04-11

	[root@server0 ~]# ls
	anaconda-ks.cfg  mkdir              Pictures
	Desktop          Music              Public
	Documents        mydate-2019-04-11  sysinfo.sh
	Download         Templates
	helooworld.sh    name.txt           Videos
##############################################################
黑洞设备 
/dev/null 
专门为写脚本产生的无用数据而生 
无限制 把无用的数据 定向到 黑洞即可
####################################################################
条件测试
 [ 测试表达式 ] 注意空格 
常用的测试选项
 -e 文档存在为真 (查询 文件和 目录 是否存在 )
 -d 文档存在,且必须为目录为真(只能查询 目录 是否存在)
 -f 文档存在,且必须文件为真(只能用来筛选文件是否存在)
 eg: 
这是一个 文件测试的脚本 
#!/bin/bash
if [ -f $1  ];then
  echo file
elif [ -d $1 ];then
  echo  doctum
elif [ -e $1 ] ;then
echo EXIT 
else
    echo NULL
    exit 6
fi

比较整数大小(小数之后在学)
  -gt    -ge -eq  -ne  -lt   -le
   大于 大于等于 等于 不等  小于  小于等于
字符串的比较
  == :两个字符串一样为真
echo $?  0为真  ###$?程序退出后状态显示
 != 不等于为真
echo $?  0 为真 ###$?程序退出后状态显示  使用 echo $?
################################
if 选择结构
双分支
	if[ 条件 ];then
 	   命令
	else
	   命令
	fi
###############################
if 多分支处理
	if [ 条件 ];than
	命令1
	elif [ 条件 ];than
	命名2
	  *
	  *
	  *
      elif [ 条件 ]
	命令n
	else
	命令
	fi
eg:检测用户是否存在 ,不存在则创建

[root@server0 ~]# vim /root/user.sh

#!/bin/bash
# echo 请输入USERNAME
       read -p '输入用户:' a
       id $a &> /dev/null
       if [ $? -eq 0 ];then  ####$?程序退出后状态显示  使用 echo $?  查询
            echo 用户存在
            id $a
       else
            echo 用户不存在 
#       read -p '请输入USERNAME' a
            echo 正在创建用户$a
            read -p 'PASSWD' b
            useradd $a &> /dev/null
            echo successfuly useradd $a
            echo $b | passwd --stdin $a &> /dev/null
            echo successfuly passwd $a
        fi
~    
循环结构
	有限次循环
	for循环 结构 
	for 变量名 in 值列表 
	do 
	   命令
	done	
	   命令
值得列表可以不参与循环
数值范围
{起始..结束}
{1..100} = 1-100 连续的数字

#####################################################
系统安全保护
SElinux 安全机制 
linux 内核 已经集成 (2.6以上)
SElinu 运行的三种模式
enforcing (默认)强制    permissive  宽松    disable  彻底禁用
任何模式变为disable(彻底禁用)模式,必须修改配置文件 重启
任何模式的转换都需要修改配置文件 ,重启后生效
 切换运行模式 (下次开机失效)
     (零时设置) 
     gentenforce ##########查看selinu 状态
        enforce  强制模式
     setenforce 0 ################修改当前selinux状态
	Permissive  (宽松模式)
       永久修改 (修改配置文件＃系统下次启动生效)
修改  vim /etc/selinux/config 
      SELINU=permissive  ##########宽松模式
vim 中命令模式下按 C 光标之后被删除
###############################
配置用户环境  (设置永久别名)
 开启新终端后生效
  影响指定用户的bash 解释器
  ~ /.bashrc,每次开启bash 终端生效 ####注意这是一个隐藏文件 
  [root@server0 ~]# vim /root/.bashrc 修改root 用户的
  [student@gao ~]$ vim /home/student/.bashrc   $####修改用户studen 的bash .添加别名
	  alias gos='ssh -X root@172.25.0.11'
	#mount | grep qemu &> /dev/null
	alias god='ssh -X root@172.25.0.10'

  影响所有用户的 bash 解释器
  [root@server0 ~]# vim /etc/bashrc
  source ~/.bashrc ###重新加载bash 配置文件

###################################
防火墙策略的管理(基础阶段)
  在之后的服务学习中注意 selinux 状态 处于 permissive 或者 disable 
一 搭建基本的web服务 (不涉及优化) 
   web 服务 :提供页面内容服务
   1. yum 安装  httpd
   2. 重启 httpd 服务
[root@server0 ~]# systemctl restart httpd 
   3. 本机测试 访问 172.25.0.11
   filefox 访问 172.25.0.11
    在-X远程访问 Firefox 时保证 本机物理机 的Firefox没有开启 ,否则会出现错误
   4.在example.server中写一个网页
     网页默认存放路径: /var/www/html/ 当该路径下没有页面时会自定显示测试页面
     默认页面文件名称: index.html

二 构建FTP服务器
   ftp服务默认共享路径: /var/ftp
  1. 安装 vsftpd
    yum -y install vsftpd
   2. 重启服务 
    systemctl restart vsftpd 
   3.验证 ftp 
    [root@server0 ~]# firefox ftp://172.25.0.11
    需要注意的是ftp文件的属相最好是 644
##############################################
ftp 通常分为
         1）主动模式（port）
                    ftp client向ftp服务器发送请求并携带自己的监听端口；
                    服务器返回确认，并从服务器的20端口主动连接到 client的监听端口，最后客户端返回确认。 数据连接由服务器完成
         2）被动模式 （pasv）
                    命令连接和数据连接都由客户端来发起

                    被动模式解决了主动模式所面临的服务器到客户端的连接会被拦截阻塞的问题
FTP的传输有两种方式：ASCII传输模式和二进制数据传输模式
ftp的相关问题可以参考
https://www.jianshu.com/p/f1788f596a57

############################################
#############################
防火墙策略
   作用:隔离
            硬件防火墙 : huawei 思科 h3c 
            软件防火墙 : firewalld linux 默认安装启动
系统服务 :firewalld
     管理工具: firewall-cmd   firewall-cofig(图形)
     预设安全区域
	     首先判定请求 应该划分给某个区域
	     根据不同区域设置不同规则
　　　目前只讲四个区域	
-------public: 仅允许访问本机的sshd ping dhcpd 服务
-------trusted:允许任何访问
-------block: 阻塞任何来访请求 (有明确拒绝,客户端有接受回应)
-------drop:丢弃任何来访数据包 (直接丢弃,客户端没有回应,,,,节省资源)

配置规则位置
     --运行时(runtime)
     --永久(permanent)

 数据包:目标地址 源IP地址 数据
 防火墙判定规则;
	1.查看请求数据包中源IP 地址,然后查看防火墙所有区域,那个区域有源IP规则，则进入该区域


	2.进入默认区域ｐｕｂｌｉｃ（由ｒｏｏｔ指定）
防火墙的规则中不允许　同一个ｓｏｕｒｃｅ　ｉｐ添加到两个块中　不然会报错
################################################33
一　防火墙默认区域的修改
　　查看防火墙默认区域
　　firewall-cmd --get-default-zone 
    firewall-cmd--set-default-zone=block ###设定防火墙默认区域为ｂｌｏｃｋ
  在区域中添加允许访问的服务ＯＲ协议 (背下来)
	　九大协议 常用端口
　　　　　ｈｔｔｐ：超文本传输协议　　           端口: 80
　　　　　ｈｔｔｐｓ：安全超文本传输协议               443
	　ＤＮＳ：　域名解析协议			            53
	　ＦＴＰ　：文件传输协议                        21(用于链接)20(用于传输数据)
	　ＴＦＴＰ：简单文件传输协议                     69
	　ｔｅｌｎｅｔ：　远程管理协议                   23
　　　　　ｐｏｐ３：邮件协议　（收）                 110
	　ＳＭＴＰ：邮件协议　（发）                    25
　　　　　ＳＮＭＰ：　简单的网络管理协议　            161
        Mariadb数据库 mysql                     3306
        imap                                    143
ｅｇ：　给ｓｅｒｖｅｒ0　的ｆｉｒｅｗａｌｌ的ｐｕｂｌｉｃ添加　ｈｔｔｐ　和ｆｔｐ协议
查看ｆｉｒｅｗａｌｌ的ｐｕｂｌｉｃ域的规则
[root@server0 ~]# firewall-cmd --zone=public --list -all　＃＃＃查看区域规则
[root@server0 ~]# firewall-cmd --zone=public --add-service=http
[root@server0 ~]# firewall-cmd --zone=public --list-all 
[root@server0 ~]# firewall-cmd --zone=public --list-all 
public (default, active)
  interfaces: eth0
  sources: 
  services: dhcpv6-client http ssh
  ports: 
  masquerade: no
  forward-ports: 
  icmp-blocks: 
  rich rules: 
＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃
永久的防火墙规则
使用选项
　－－ｐｅｒｍａｎｅｎｔ　
注意设置玩永久防火墙后记得重新加载
ｅｇ：
[root@desktop0 ~]# firewall-cmd --permanent --zone=public --add-service=ftp ＃＃＃＃永久加载策略
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　需要添加的服务名
[root@desktop0 ~]# firewall-cmd --reload 　＃＃＃＃＃重新加载防火墙策略

[root@desktop0 ~]# firewall-cmd --permanent --zone=public --remove-service=ftp #################删除规则（配置文件）　－－ｐｅｒｍａｎｅｎｔ　修改配置文件
[root@desktop0 ~]# firewall-cmd --reload ＃＃＃＃重新加载防火墙策略


＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃


使用防火墙实现端口转发（实现本机的端口映射）
端口：　标示　服务/协议/程序端口
　　　　可以使用ｒｏｏｔ　用户修改服务/协议/程序的
	端口标示程序（防火墙也就是通过端口来判断服务/程序）
一般来说　服务有着默认端口
　　　本地应用的端口重定向（端口１－－端口２）
　　　比如，访问一下两个地址可以看到相同的页面：
客户端访问：172.250.11：80　-------＞防火墙-----------＞172.25.0.11:8000


[root@server0 ~]# firewall-cmd --permanent --zone=public --add-forward-port=port=8000:proto=tcp:toport=80　＃＃＃＃＃＃＃＃＃＃设置端口转发　注意格式　
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　这里第二个ｐｏｒｔ就无无法ｔａｂ了＃指定转发端口　指定传输协议　＃＃指定目标端口　　
[root@server0 ~]# firewall-cmd --reload 　　＃＃＃＃＃＃＃＃＃＃重新加载ｆｉｒｅｗａｌｌ
success
[root@server0 ~]# firewall-cmd --zone=public --list-all ＃＃＃注意lsit后面没有空格　
public (default, active)
  interfaces: eth0
  sources: 
  services: dhcpv6-client http ssh
  ports: 
  masquerade: no
  forward-ports: port=8000:proto=tcp:toport=80:toaddr=
  icmp-blocks: 
  rich rules:
＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃
触发挂载
　1.关闭ｓｅｒｖｅｒ，添加光驱
　2.安装软件包　实现挂载软件　ａｕｔｏｆｓ
[root@server0 ~]# yum -y install autofs

[root@server0 ~]# systemctl restart autofs
[root@server0 ~]# systemctl enable autofs　　＃＃＃设置开机自启
[root@server0 ~]# cd /misc/cd　　＃＃＃＃＃＃＃＃＃＃＃＃当用户进入／ｍｉｓｃ／ｃｄ　目录的时候（特定条件）　　ａｕｔｏｆｓ　自动创建挂载点且自动挂载，其他路径不可以，　一段时间后自动卸载，用的时候自动挂载
＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃
[root@server0 ~]# ls /etc/auto.master　　＃＃触发挂载主配置文件
/etc/auto.master
[root@server0 ~]# ls /etc/auto.misc 　　＃＃＃＃挂载配置文件
/etc/auto.misc
触发挂载必须为两层目录
　　　/nsd/　　第一层监控点，由auto.master 设定
	abc　　　
####################
[root@server0 ~]# vim /etc/auto.master　　＃＃＃当我们需要修改　监控点的时候添加（注意不要删除　原本的　写上自己的　规则就好）　/nsd    /etc/test.misc
　　
 监控点　　指定挂载在配置文件的路径
/misc   /etc/auto.misc
翻译：设置挂载点为　/misc ，想要知道挂载什么设备．请看/etc/auto.misc

[root@server0 cd]# vim /etc/test.misc

abc    -fstype=xfs,rw :/dev/vdb1　　＃＃＃＃＃＃＃＃＃＃＃＃＃格式

root@server0 cd]# cd /nsd/abc ####使用

＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃
添加一个ｓｗａｐ分区（交换分区）
　　　作用：在一定程度上缓解内存需求，当物理机器内存不足时讲一部分数据放到ｓｗａｐ中，其他平台叫做　虚拟内存
　Ｌｉｎｕｘ　一般也是使用分区空间来充当交换空间
　可以由多个分区来组成．

怎么设置

[root@desktop0 ~]# fdisk /dev/vdb　＃　创建一个分区
[root@desktop0 ~]# mkswap /dev/vdb1　　＃格式化　为ｓｗａｐ
正在设置交换空间版本 1，大小 = 524284 KiB
无标签，UUID=b9ae5113-aea8-4e4d-8b05-81974f61d1be
[root@desktop0 ~]# blkid /dev/vdb1　　＃查看文件系统类型　　　＃＃＃＃　df -h 相当于　打开我的电脑后看到的　磁盘信息　,lsblk 相当与　磁盘管理后看到的
/dev/vdb1: UUID="b9ae5113-aea8-4e4d-8b05-81974f61d1be" TYPE="swap"
[root@desktop0 ~]# swapon /dev/vdb1 　　＃＃＃＃＃＃＃＃＃＃打开ｓｗａｐ分区
[root@desktop0 ~]# swapon -s　　　　　　　＃＃＃＃＃＃＃＃＃＃查看ｓｗａｐ分区信息
文件名				类型		大小	已用	权限
/dev/vdb1                              	partition	524284	0	-1
[root@desktop0 ~]# swapoff /dev/vdb1 ＃＃＃＃＃＃＃关闭　swap 分区


[root@desktop0 ~]# vim /etc/fstab 　＃＃＃设置ｓｗａｐ分区开机自动挂载

[root@desktop0 ~]# swapon -a 　＃＃＃自动挂载ｓｗａｐ分区
[root@desktop0 ~]# swapon -s　＃＃＃３显示　ｓｗａｐ分区信息
文件名				类型		大小	已用	权限
/dev/vdb1   



＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃３３
iscsi 　网络磁盘服务(共享磁盘/分区) 类似于　ｓｈｅｌｌ　脚本的地位　也就是说必须学好  怎么读 爱斯嘎see
　　作用：主要用在集群中　高可用　
　　工作模式：　基于　ｃ/ｓ架构的虚拟磁盘技术
　　　　　　　　服务器提供磁盘空间，客户机链接并且当成本地磁盘使用
服务端：虚拟机　ｓｅｒｖｅｒ提供磁盘空间　　　
		＃＃＃＃＃装包　配置　启动服务
环境准备　
　1.　ｆｉｒｅｗａｌｌ　设置
	[root@server0 ~]# firewall-cmd --set-default-zone=trusted
	success
	＃＃＃＃ｄｅｓｋｔｏｐ也要将防火墙　设置为　允许所有
	＃＃安装软件包
	[root@server0 ~]# yum -y install targetcli
	＃＃配置　可以支持全程ｔａｂ
	＃使用ｆｄｉｓｋ　分一个空闲分区　不用格式化(没有文件系统)
	[root@server0 ~]# fdisk /dev/vdb
	
　2.运行targetcli 进行设置	
	将使用targetcli 比喻成　快递运输　主机　他会要求原包装（backstore）　且木箱子(target)   将原包装装进木箱子，　关联起来（lun）　，指定定收件人　（acl 访问控制）
	target，磁盘组
　　		是客户端的访问目标，作为一个框架，由多个lun 组成
	lun，逻辑单元(将后端存储放入磁盘组)
 　　		每一个lun 需要关联到某一个后端设备存储中，在客户端会视为一块虚拟磁盘





	进入targetcli　　＃＃＃＃默认exit退出命令　保存配置文件＃＃　ｃｔｒｌ　＋　Ｃ　是不会保存配置文件的
	[root@server0 ~]# targetcli 
		/> ls　＃查看需要配置的文件
	o- / ..................................................................... [...]
	　／ｄｅｖ／ｖｄｄ１　后端存储
	  o- backstores .......................................................... [...]
	　
	  | o- block .............................................. [Storage Objects: 0]
	  | o- fileio ............................................. [Storage Objects: 0]
	  | o- pscsi .............................................. [Storage Objects: 0]
	  | o- ramdisk ............................................ [Storage Objects: 0]
	  o- iscsi ........................................................ [Targets: 0]
	  o- loopback ..................................................... [Targets: 0]
	1）＃创建后端储存（backstore，后端存储）	
	/> backstores/block create name=iscsi_store dev=/dev/vdb1
	创建成功
	Created block storage object iscsi_store using /dev/vdb1.
	/> 
	2）＃创建　target，磁盘组（木质箱子）
		ISCSI Quanlified Name (iqn)命名规范（不符合创建时不通过）
		iqn.yyy-mm.倒叙域名：自定义标示
		用来识别target 磁盘组，也用来识别客户机身份
		名称例子：
		iqn.2016-02.com.example:server0
	iqn.2016-02.com.example:desktop0
	/> iscsi/ create iqn.2019-04.com.example:server0
	Created target iqn.2019-04.com.example:server0.
	Created TPG 1.＃创建成功
	3）配置　lun ，　关联（木箱子）
	/> iscsi/iqn.2019-04.com.example:server0/tpg1/luns create /backstores/block/iscsi_store 
	Created LUN 0.＃成功
	4）配置acl 访问控制设置客户端声称的名字，（需要手写）名字需要符合iqn 命名规范，设置的名字需要在客户端在写一遍
	/> iscsi/iqn.2019-04.com.example:server0/tpg1/acls create iqn.2019-04.com.example:desktop0
	Created Node ACL for iqn.2019-04.com.example:desktop0　
	Created mapped LUN 0.＃　成功
　　　　5）指定端口，网卡（服务器肯定不止一个网卡）　　　　　　　　　　　＃指定ｉｐ，若不愿指定　可以写成　0.0.0.0，写四0，意味这访问我的任何ＩＰ就好，只要你能ｐｉｎｇ通
	/> iscsi/iqn.2019-04.com.example:server0/tpg1/portals create 172.25.0.11
	Using default IP port 3260　＃默认
	Created network portal 172.25.0.11:3260.＃创建成功
	查看　
	/> ls 
	o- / ........................................... [...]
	  o- backstores ................................ [...]
	  | o- block .................... [Storage Objects: 1]
	  | | o- iscsi_store  [/dev/vdb1 (3.0GiB) write-thru activated]
	  | o- fileio ................... [Storage Objects: 0]
	  | o- pscsi .................... [Storage Objects: 0]
	  | o- ramdisk .................. [Storage Objects: 0]
	  o- iscsi .............................. [Targets: 1]
	  | o- iqn.2019-04.com.example:server0 ..... [TPGs: 1]
	  |   o- tpg1 ................. [no-gen-acls, no-auth]
	  |     o- acls ............................ [ACLs: 1]
	  |     | o- iqn.2019-04.com.example:desktop0  [Mapped LUNs: 1]
	  |     |   o- mapped_lun0  [lun0 block/iscsi_store (rw)]
	  |     o- luns ............................ [LUNs: 1]
	  |     | o- lun0 .... [block/iscsi_store (/dev/vdb1)]
	  |     o- portals ...................... [Portals: 1]
	  |       o- 172.25.0.11:3260 ................... [OK]
	  o- loopback ........................... [Targets: 0]
	/> exit 保存（不要用ｃｔｒｌ　＋　Ｃ）
	/> exit
	Global pref auto_save_on_exit=true
	Last 10 configs saved in /etc/target/backup.
	Configuration saved to /etc/target/saveconfig.json
　　　3.重启服务
	[root@server0 ~]# systemctl restart target　＃重启服务
	[root@server0 ~]# systemctl enable target　　＃开机自启
	ln -s '/usr/lib/systemd/system/target.service' '/etc/systemd/system/multi-user.target.wants/target.service'　
	＃制作快捷方式，不是报错
	[root@server0 ~]# 

客户端：
1.安装软件包　iscsi-initiator-utils
	[root@desktop0 ~]# yum -y install iscsi-initiator-utils
2.修改配置文件，指定客户端生的命令
	[root@desktop0 ~]# vim /etc/iscsi/initiatorname.iscsi 
	InitiatorName=iqn.2019-04.com.example:desktop0
3.数据库重启服务　iscsid 服务，用于识别客户端 声称名字＃修改完　配置文件后需要重启服务
	[root@desktop0 ~]# systemctl restart iscsid
	有时会出现　需要使用　systemctl daemon-reload 　刷新命令
4.发现，链接　iscsi 磁盘 ###告诉快递的位置
	iscsiadm 
	由于命令太长　使用mna iscsiadm 　／example  在查找例子 　ＥＸＡＭＬＰＥＳ中的　将第一个例子复制出来
	[root@desktop0 ~]# man iscsiadm
	[root@desktop0 ~]# iscsiadm --mode discoverydb --type sendtargets --portal 172.25.0.11 --discover
	172.25.0.11:3260,1 iqn.2019-04.com.example:server0
5.重启　iscsi 服务（客户端）
	[root@desktop0 ~]# systemctl restart iscsi　　＃＃＃＃＃重启服务　＃＃这个　服务名字ｉｓｃｓｉ　　没有　ｄ
	[root@desktop0 ~]# systemctl enable iscsi　　＃＃＃＃＃＃＃开机自启
	[root@desktop0 ~]# lsblk 
	NAME   MAJ:MIN RM SIZE RO TYPE MOUNTPOINT　　＃查看磁盘
	sda      8:0    0   3G  0 disk 　　＃＃＃ｉｓｃｓｉ　磁盘　　　　　　　
	vda    253:0    0  10G  0 disk 
	└─vda1 253:1    0  10G  0 part /
	vdb    253:16   0  10G  0 disk 
	[root@desktop0 ~]# 
systemctl students
＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃
提问ＩＱＮ的两个作用：　1.用来识别target 磁盘组，2.也用来识别客户机身份

＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃

数据库的基本管理　　
什么是数据库：	
	存放数据的仓库
数据库结构:
在数据库中，有许多的库，每个库中存在表格
分类：　
ＭＩＣＳＲＯＦＴ　－－－　ＳＱＬ　ＳＥＲＶＥＲ　
ＩＢＭ　　　　　　－－－　ＤＢ２
甲骨文　　　　　　－－－　Orcale  MySQL 
社区开源　　　　　－－－　Maira DB　和　MySQL 的作者是一个人
（软件）Maria DB
一.环境准备＆重启服务
安装　　
	[root@server0 ~]# yum -y install mariadb-server (服务端软件)
重启服务
	[root@server0 ~]# systemctl restart mariadb
卸载　 ####这个是和删根一样的操作，别用
	[root@server0 ~]# yum remove mariadb-server　
二.数据库基本操作
＃＃＃＃＃＃＃＃＃＃＃＃＃所有命名都已　；　结尾　，不然报错
增删改查
[root@server0 ~]# mysql　　＃＃＃进入数据库
	Welcome to the MariaDB monitor.  Commands end with ; or \g.
	Your MariaDB connection id is 2
	Server version: 5.5.35-MariaDB MariaDB Server

	Copyright (c) 2000, 2013, Oracle, Monty Program Ab and others.

	Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

MariaDB [(none)]> 
MariaDB [(none)]> show databases;＃＃＃＃查看数据库　，注意这里的ｄａｔａｂａｓｅｓ　有ｓ　
MariaDB [(none)]> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| gaoyaun            |
| mysql              |
| nsd1903            |
| performance_schema |
| test               |
+--------------------+
6 rows in set (0.00 sec)



MariaDB [(none)]> create database gaoyaun;＃＃＃＃＃＃创建库　　ｄａｔａｂａｓｅ　　没有ｓ
Query OK, 1 row affected (0.00 sec)


MariaDB [(none)]> drop database nsd1903;　＃＃＃＃删除库
Query OK, 0 rows affected (0.00 sec)



三.为数据库管理员设置密码
　　数据库管理员：　ｒｏｏｔ　，数据库所有用户信息由数据库中的ＭＹＳＱＬ管理
　　系统管理员：　　ｒｏｏｔ　，系统所有的用户信息，由　／ｅｔｃ／ｐａｓｓｗｄ管理
设置数据库管理员密码
[root@server0 ~]# mysqladmin -u root password '123'###注意格式　
登录
[root@server0 ~]# mysql -u root -p 　＃交互式
Enter password: 
MariaDB [(none)]> 

[root@server0 ~]#　mysql -u root -p123 ## 非交互　
MariaDB [(none)]> 

四.表格操作;表记录，表字段
　　　　　　　行　　　列
	　　　３表记录　　５表字段
	编号　姓名　性别　联系方式　　　地址　
	 1　　ａ　　ｗ　　　ａａａ　　　ｎ　
     2　　ｂ　　ｍ　　　ｂｂｂ　　　ｗ
　　　3　　ｃ　　ｗ	 ｃｃｃ　　　ｅ

增删改查　: instal delea update  select
　　　＃＃＃＃进入　mysql 库
	MariaDB [(none)]> use mysql;
	###进入其他库　
	show tables;
	####查看表结构
      desc user;

数据库的导入／恢复　
　　　
[root@server0 ~]# mysql -u root -p123 nsd1903 < /root/users.sql 

表格查询：　
select　　表字段　from 表名

MariaDB [nsd1903]> select * from base  ####相对路径路径　
MariaDB [mysql]> select * from nsd1903.base;　＃＃＃＃＃绝对路径
+------+---------+------------+
| id   | name    | password   |
+------+---------+------------+
|    1 | Tom     | 123        |
|    2 | Barbara | 456        |
|    3 | James   | solicitous |
|    4 | Smith   | tarena     |
|    5 | Barbara | pwd123     |
+------+---------+------------+

MariaDB [nsd1903]> select id,name from base;
+------+---------+
| id   | name    |
+------+---------+
|    1 | Tom     |
|    2 | Barbara |
|    3 | James   |
|    4 | Smith   |
|    5 | Barbara |
+------+---------+

有条件查询：
　查找指定条件的
	  			字段		            字段
MariaDB [nsd1903]> select * from base where password='123';
+------+------+----------+
| id   | name | password |
+------+------+----------+
|    1 | Tom  | 123      |
+------+------+----------+


MariaDB [nsd1903]> select name,password from base where name='tom';
+------+----------+
| name | password |
+------+----------+
| Tom  | 123      |
+------+----------+


MariaDB [nsd1903]> select id,name from base where name='tom';
+------+------+
| id   | name |
+------+------+
|    1 | Tom  |
+------+------+

禁止网络进行链接，只服务与本机
[root@server0 ~]# vim /etc/my.cnf　　＃主配置文件
skip-networking //手写
systemctl restart mariadb  //重启服务
＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃＃
数据库授权　
　－除了　root 用户，此nsd1903数据库只能被　lisi 查询，密码123　＃＃不需要创建系统用户
　	
	GRANT 权限列表　ON 数据库名 TO　用户名@客户地址 IDENTIFIED BY '密码'; 
	grant select on nsd1903.* to lisi@localhost identified by '123'; 
	当用户ｌｉｓｉ在本地使用　123　登录

联合多表查询
        查询　有多少人姓名　Ｂarbara　同时住在　ＳＵＮＮＹＶＡＬＥ
MariaDB [nsd1903]> select count(*) from base,location where base.name='Barbara' and location.city='Sunnyvale' and base.id=location.id; 



禁止空密码root 用户访问 mariadb 数据库 
MariaDB [nsd1903]> use mysql  # 进入mysql                    表            表字段
MariaDB [mysql]> select user,host,password from user; ##查看user中的 user,host,password
+------+---------------------+-------------------------------------------+
| user | host                | password                                  |
+------+---------------------+-------------------------------------------+
| root | localhost           | *23AE809DDACAF96AF0FD78ED04B6A265E05AA257 |
| root | server0.example.com |                                           |
| root | 127.0.0.1           |                                           |
| root | ::1                 |                                           |
|      | localhost           |                                           |
|      | server0.example.com |                                           |
| lisi | localhost           | *23AE809DDACAF96AF0FD78ED04B6A265E05AA257 |
+------+---------------------+-------------------------------------------+
7 rows in set (0.00 sec)

MariaDB [mysql]> delete from user where password='';      # 删除表中密码为空的
Query OK, 5 rows affected (0.00 sec)

MariaDB [mysql]> select user,host,password from user;    ##查看user表中 表字段
+------+-----------+-------------------------------------------+
| user | host      | password                                  |
+------+-----------+-------------------------------------------+
| root | localhost | *23AE809DDACAF96AF0FD78ED04B6A265E05AA257 |
| lisi | localhost | *23AE809DDACAF96AF0FD78ED04B6A265E05AA257 |
+------+-----------+-------------------------------------------+
2 rows in set (0.00 sec)


MariaDB [mysql]> flush privileges;####刷新user所有记录 

##########################################
selinux 和 Firewall 状态
配置nfs (nfs共享文件夹) linux之间共享文件
	network file system ,网络文件系统
	-用途:为客户机提供共享使用的文件夹
	-协议:NFS(TCP/UDP 2049) RPC(TCP/UDP 111)
软件包 nfs-utils
服务名 nfs-server
服务端:
1.安装软件包
rpm -q nfs-utlis
nfs-utils-1.3.0-0.el7.x86_64

2.创建共享目录
[root@server0 ~]# mkdir /public
[root@server0 ~]# echo 'I AM STUDENT' > /public/1.txt  
3.修改配置文件/etc/exports ,指定共享目录
-- 文件夹路径  客户机地址(权限)  客户机地址(权限) .....    ##可以写多个客户机地址
 /public      *(ro) ##readonly                  
客户端:
linux需要nfs-utlis软件的支持 来挂在 nfs
在Linux中 共享文件与win不同 , win 直接输入 ip 访问,然而 Linux 需要挂载.
1.查看服务端共享路径并重启服务
showmount -e 172.25.0.11 
Export list for 172.25.0.11:
/public *
[root@server0 ~]# systemctl restart nfs-server
2.挂载 
#####注意格式

[root@desktop0 ~]# mkdir /mnt/nfs
[root@desktop0 ~]# mount 172.25.0.11:/public /mnt/nfs
[root@desktop0 ~]# df -h   #####查看文件系统信息
文件系统             容量  已用  可用 已用% 挂载点
/dev/vda1             10G  3.0G  7.1G   30% /
devtmpfs             906M     0  906M    0% /dev
tmpfs                921M   80K  921M    1% /dev/shm
tmpfs                921M   17M  904M    2% /run
tmpfs                921M     0  921M    0% /sys/fs/cg

3.开机挂载

[root@desktop0 ~]# vim /etc/fstab 
172.25.0.11:/public /mnt/nfs nfs    defaults,_netdev  0         0  
  设备路径                 挂载点  文件系统   参数(别写错了)          备份标记  检测标记


############################################
WEB 服务器
 基于B/S(browser/server)其核心依然是cs 架构的网页服务 
-服务端提供网页
-浏览器下载并显示网页
记得 将防火墙设置为trusted，才能使用 desktop 访问 serve
firewall-cmd --set-default-zone=trusted
server
   20  yum -y install httpd
   23  systemctl restart httpd           # 网页默认路径 /var/www/html/
   26  echo '<h1> I AM STUDENT </h1>' > /var/www/html/index.html
   27  echo '<h1><marquee> I AM STUDENT </h1>' > /var/www/html/index.html

desktop
firefox 172.25.0.11

#############################
WEB服务器软件  (重要啊 面试比问)
 httpd(Apache 软件基金会) nginx(为主) tomcat (兼容JAVA) 都要学习

eg :请大家用Apache 搭一个web环境

默认设置
-listen :监听地
址:端口(80)
-ServerName: 本站点注册的DNS名称(空缺)

	DNS服务器:本次实验由classroom提供(之后自己搭建)
	 server0.example.com	
	 www0.example.cpom
	 webapp0.example.com
注意server的防火墙 是否关闭 (为trusted)
测试域名能否解析  nslookup  域名
[root@server0 ~]# nslookup webapp0.exsample.com

-DocunmetRoot: 网页文件根目录(默认/var/www/html)

[root@server0 ~]# vim /etc/httpd/conf/httpd.conf
	只修改 DocumentRoot 行 
	修改为  DocumentRoot "/var/www/myweb"
[root@server0 ~]# echo '<h1><marquee> I AM MYWEB</h1>' > /var/www/myweb/index.html
重启服务
[root@server0 ~]# systemctl restart httpd
网络路径与实际路径
	客户端访问:
	Firefox 172.25.0.11:80-->服务端 httpd--->DocumentRoot /var/www/myweb-->index.html

服务端 /var/www/myweb/abc/index.html	
客户端 Firefox 172.25.0.11/abc ##注意这里的路径 ,网页文件起点 已经在Documentroot中指定了,这里只要接着写/abc/

########################################
客户端
########################################
配置文件的调用
 重要:由于 主配置文件和调用配置文件使用时在 DOCUMENTROOT 选项中只能有一个生效所以,当有一个站点使用虚拟主机之后其他站点必须使用虚拟主机,否则会按照web优先级显示页面
配置文件路径
[root@server0 ~]# vim /etc/httpd/conf/httpd.conf  ##主配置文件 在工作中 不推荐修改主配置文件 改错了 排错麻烦
[root@server0 ~]# vim /etc/httpd/conf.d/*.conf    ##调用配置文件

为什么分文件写呢? 为了方便自己排错,方便调用,若配置文件过大会影响读取配置文件的速度(重启服务)
#########################################################

虚拟WEB主机 (面试考)
作用:由同一个服务器提供多个不同的站点
区分方式
-基于域名的虚拟主机(主要使用)
-基于端口的虚拟主机(较少使用)
-基于IP的虚拟主机(绝迹江湖)
配置文件(调用配置文件)路径
[root@server0 ~]# /etc/httpd/conf.d/xxxx.conf

写在调用配置文件中

<VirtualHost *:80>
	ServerName  server0.examlpe.com
	DocumentRtoot /var/www/myweb ###由于selinux会限制文件的存放位置,所以在没有修改selinux时不要吧 DocumentROOT 位置放在 其他地方
</VirtualHost>

[root@server0 ~]# mkdir /var/www/qq
[root@server0 ~]# echo '<h1>tencent'> /var/www/qq/index.com

##########################
虚拟web主机的优先级,由上到下优先级变小
若使用了虚拟主机,所有的页面必须使用虚拟web主机来访问
###################################
补充: Samba 共享服务(Windows与Linux 跨平台共享服务)  我选择 nfs
	协议:SMB(沟通验证身份)   CIFS(储存或传输数据)
默认情况必须通过用户验证,才能访问.
专门用于Samba共享服务,验证的用户:Samba共享账号
特点: 
    1.必须要有相应的本地用户相对应
    2.采用独立的密码设置
	也可以使用不能登录的用户只用于验证
虚拟机 server
1.环境准备 samb

 yum -y install samba


2.创建samba共享账号
   pdbedit -a harry   #添加 共享账号 ##必须在本地添加一个账号
   pdbedit -X harry   #-X删除
   pdbedit -L         # 查看所有的samba共享账号	
3.修改配置文件
 [root@server0 ~]# vim /etc/samba/smb.conf 
在命名模式下输入G 到全文最后一行 gg到全文首行

	[nsd]	##设置共享名 Windows中 用得到
	path = /common  ##设置实际共享目录

	默认是连用户的家一起共享出来
4.重启服务
[root@server0 ~]# systemctl restart smb  ##服务名与软件名不同

虚拟机 desktop
1.安装软件包,支持samba共享挂载,让本机识别cifs协议
 yum -y install cifs-utils
 mkdir /mnt/smb #创建挂载点
2.挂载访问samba共享

[root@desktop0 ~]# mount -o user=harry,pass= //172.25.0.11/nsd /mnt/smb/

3.修改SELINUX 策略,布尔值策略(功能的开关)
[root@desktop0 ~]# getenforce  #查看SeLinux状态
Enforcing

[root@server0 ~]# getsebool -a | grep samba #查看bool 状态

samba_export_all_ro --> off
samba_export_all_rw --> off

[root@server0 ~]# setsebool samba_export_all_ro=on ##开启Samba export服务


3.开机自动挂载

vim /etc/fstab 

//172.25.0.11/nsd /mnt/smb/ cifs defaults,_netdev,user=harry,pass=  0 0



############################
课程准备
搭建web服务
要求要有三个 不同的页面 使用三个不同的域名


#############################
web访问限制控制
客户机地址限制
位置: 调用配置文件

若格式忘记的话,可主配置文件,中可以查到
[root@server0 ~]# vim /etc/httpd/conf/httpd.conf

   ######对//var/www设置
		<Directory "/var/www">
		    AllowOverride None
		    # Allow open access:
		    Require all granted  ###　允许所有来源访问
		</Directory>


###url重写(伪静态技术)需要读取,有时候，我们需要修改apache默认配置，但是，
#####我们却不想对apache的http.conf进行太多的修改，所以我们使用.htaccess(分布式配置文件)来达到我们的目的。
####.htaccess提供了针对每个目录改变配置的方法，即在一个特定的目录中放置一个包含指令的文件，
####其中的指令作用于此目录及其所有子目录。不过，我们需要让apache来读取它，这里就需要修改apache下的http.conf了。

我们的apache都有自己项目的默认根目录，在DocumentRoot "D:/www"下面(这里以我的路径为例子) ,有一个叫<Directory>的东西，
它里面有这样一段代码：AllowOverride None，如果我们把None改成All，那么我们的www目录下所有项目都能读取到.htaccess了。

一个单词就解决了我们的问题，固然方便，但是它的弊端也很多。例如每次访问项目时，apache都会对每一个.htaccess文件进行读取，
处理速度大幅度降低；每一个项目都能进行apache的配置修改，安全性大大降低等。　所以默认设置为none





使用: <Directory></Directory>
对于目录设置的 权限子目录默认继承,
除非对于子目录有明确规定





eg:
<Directory 目标地址1>
Require all denied /granted 拒绝/允许/
Require ip 172.0.0.1::1 172.25.0.11 允许部分ip访问/
</Diretcory>

<Directory /var/www/web01>
Require all denied #拒绝所有人访问
</Diretcory>

<Directory /var/www/web02>
Require all granted #允许所有人访问
</Diretcory>

<Directory /var/www/web02>
Require ip 172.0.0.1::1 172.25.0.11 #允许部分用户访问
</Diretcory>

###############
自定WEB根目录
 调整web站点 server0.example.com的网页目录
  要求修改selinux 为permissive 宽松模式
  主配置文件中设定了 网页根目录 /var/www 
  我们可以在调用配置文件中修改  网页文件根目录
	
 
要求如下 
1)新建 /webroot 作为站点目录

	mkdir /webroot
	echo 'i am webroot' > /webroot/index.html
	vim /etc/httpd/conf.d/ruler.conf #调用配置文件--允许访问设置

		<Directory /var/www/web02/pirment>
		Require ip 172.25.0.11
		</Directory>
		<Directory /webroot>
		 Require all granted   ###允许所有访问
		</Directory>
	vim /etc/httpd/conf.d/html.conf #调用配置文件--虚拟主机设置
		<virtualhost *:80>
		documentroot /webroot
		servername server0.example.com
		</virtualhost>

2)修改selinux策略,安全上下文(标签)
###查看selinux的标签值
	[root@server0 ~]# ls -Zd /var/www/ ### -Zd 查看selinux中标记
	drwxr-xr-x. root root system_u:object_r:httpd_sys_content_t:s0 /var/www/
	[root@server0 ~]# ls -Zd /webroot/
	drwxr-xr-x. root root unconfined_u:object_r:default_t:s0 /webroot/

  参照表中目录,重新设定目录的属性
	--chcon [-R] --reference=目录模板 新目录
	--chcon -R --reference=/var/www  /webroot
	eg:
	  chcon -R --reference=/var/www /webroot

	  firefox server0.example.com

###############################################
部署动态网站

静态网站
    服务端的原始网页 与浏览器中访问的网页相同
    由web服务软件处理所有请求
    有文本 图片等静态资源
动态网站
   服务端的原始网页 不等于浏览器访问网页
   由web服务软件接受请求,动态程序转后端模块处理
  PHP网页 python网页 JSP网页
#################################
eg:
部署Python动态网页,为站点 webapp0.example.com
虚拟机
1.下载 网页文件
	[root@server0 ~]# vim /etc/httpd/conf.d/html.conf 
	[root@server0 ~]# cd /var/www/web03

	[root@server0 web03]# wget http://classroom.example.com/pub/materials/webinfo.wsgi

	[root@server0 web03]# ls
	index.html  webinfo.wsgi

2. 实现客户端方便访问,设置页面跳转(页面别名 地址重写) ####重点 操作 务必学会
当客户端访问 网络路径,讲实际路径 页面呈现

	[root@server0 ~]# vim /etc/httpd/conf.d/html.conf

	<virtualhost *:80>
	documentroot /var/www/web03
	alias /  /var/www/web03/webinfo.wsgi #注意alias的位置 必须在Documentroot之下
	servername webapp0.example.com
	</virtualhost>

  	alise 网络路径 实际路径
   	alias /  /var/www/web03/webinfo.wsgi
 
   	alias  / :用户直接输入域名
	[root@server0 ~]# systemctl restart httpd  ###重启服务
	[root@server0 ~]# firefox webapp0.example.com #本地测试
3.server上安装mod_wsgi
   yum -y install mod_wsgi

4.修改配置文件.添加翻译配置
 
	[root@server0 ~]# vim /etc/httpd/conf.d/html.conf

	<virtualhost *:80>
	documentroot /var/www/web03
	WsgiScriptalias /  /var/www/web03/webinfo.wsgi 	
	#注意alias的位置 必须在Documentroot之下,需要在Alisa前面添加wsgiScript
	servername webapp0.example.com
	</virtualhost>
5.修改端口
     这一步 selinux  会影响 httpd 服务启动
	listen 8909 ####httpd 监听端口 修改侦听端口
	<virtualhost *:8909> ###  设置虚拟web主机端口 (网页提供访问端口)
	documentroot /var/www/web03
	wsgiscriptalias /  /var/www/web03/webinfo.wsgi
	servername webapp0.example.com
	</virtualhost>
6.修改selinux  策略 ,非默认端口开放策略

	[root@server0 ~]# vim /etc/httpd/conf.d/html.conf 

	listen 8909
	<virtualhost *:8909>
	documentroot /var/www/web03
	wsgiscriptalias /  /var/www/web03/webinfo.wsgi
	servername webapp0.example.c    om
	</virtualhost>

	[root@server0 ~]# semanage port -a -t http_port_t -p tcp 8909
			
 			-a 添加 -t类型  -p协议
	libsemanage.semanage_exec_prog: Child process /sbin/load_policy did not exit cleanly.
	libsemanage.semanage_reload_policy: load_policy returned error code -1.
	ValueError: 无法提交 semanage 事务
	[root@server0 ~]# systemctl restart httpd
	[root@server0 ~]# firefox webapp0.example.com:8909

#####################################################
web服务中,端口优先级最高
############################################
安全web服务(第一阶段,作为补充内容)

	  PKI 公钥基础设施
	公钥:主要用来加密数据
	私钥:解密数据
	数字证书:证明拥有者的合法性权威性 (单位名称 ,有效期,公钥,颁发机构及签名)
	Certificate Authority, 数字证书授权中心:负责证书的申请 审核 颁发 鉴定 撤销

	公私钥 算是比较安全的 非对称算法

一个安全的网站 所需要的: 
	网站证书
	根证书
	数字证书
	公私钥
部署安全web server服务器
1.部署网站证书 
	 cd /etc/pki/tls/certs
	 wget http://classroom.example.com/pub/tls/certs/server0.crt
2.部署根证书
 在当前路径下
 	wget http://classroom.example.com/pub/example-ca.crt
3.部署解密 秘钥

路径/etc/pki/tls/private

	[root@server0 certs]# cd /etc/pki/tls/private/

	[root@server0 private]# wget  http://classroom.example.com/pub/tls/private/server0.key


4.安装软件,实现加密web传输 mod_ssl
 	yum -y install mod_ssl
	[root@server0 private]# cd /etc/httpd/conf.d/
	[root@server0 conf.d]# ls
	autoindex.conf  README      ssl.conf      welcome.conf
	html.conf       ruler.conf  userdir.conf
5.修改配置文件
	vim 末行模式  :set nu 开启行号 
	vim ssl.conf 

59行	<VirtualHost _default_:443>  ###设置端口
	  DocumentRoot "/var/www/web01"
      ServerName www0.example.com:443
	<VirtualHost>
100 SSLCertificateFile /etc/pki/tls/certs/server0.crt ###指定网站证书

107 SSLCertificateKeyFile /etc/pki/tls/private/server0.key###指定秘钥

122 SSLCACertificateFile /etc/pki/tls/certs/example-ca.crt ##指定CA 证书


重启服务

systemctl restart httpd


访问
Firefox firefox https://webapp0.example.com

##########################
Apache  httpd   服务的日志

通用日志格式(Common Log Format)
这是一个典型的记录格式：

LogFormat "%h %l %u %t \"%r\" %>s %b" common
CustomLog logs/access_log common

它定义了一种特定的记录格式字符串，并给它起了个别名叫common ，其中的"%"指示服务器用某种信息替换，其他字符则不作替换。
引号(")必须加反斜杠转义，以避免被解释为字符串的结束。格式字符串还可以包含特殊的控制符，如换行符"\n" 、制表符"\t"。

我们也可以 自定义httpd的错误 信息格式
#########################################
eg:
127.0.0.1 - frank [10/Oct/2000:13:55:36 -0700] "GET /apache_pb.gif HTTP/1.0" 200 2326

127.0.0.1 (%h)
    这是发送请求到服务器的客户的IP地址。如果HostnameLookups设为 On ，则服务器会尝试解析这个IP地址的主机名并替换此处的IP地址，但并不推荐这样做，因为它会显著拖慢服务器，最好是用一个日志后续处理器来判断主机名，比如logresolve 。如果客户和服务器之间存在代理，那么记录中的这个IP地址就是那个代理的IP地址，而不是客户机的真实IP地址。
- (%l)
    这是由客户端identd进程判断的RFC1413身份(identity)，输出中的符号"-"表示此处的信息无效。除非在严格控制的内部网络中，此信息通常很不可靠，不应该被使用。只有在将IdentityCheck指令设为 On 时，Apache才会试图得到这项信息。
frank (%u)
    这是HTTP认证系统得到的访问该网页的客户标识(userid)，环境变量REMOTE_USER会被设为该值并提供给CGI脚本。如果状态码是401，表示客户未通过认证，则此值没有意义。如果网页没有设置密码保护，则此项将是"-"。
[10/Oct/2000:13:55:36 -0700] (%t)
    这是服务器完成请求处理时的时间，其格式是：
        [日/月/年:时:分:秒 时区]
        日 = 2数字
        月 = 3字母
        年 = 4数字
        时 = 2数字
        分 = 2数字
        秒 = 2数字
        时区 = (+|-)4数字

    可以在格式字符串中使用 %{format}t 来改变时间的输出形式，其中的format与C标准库中的strftime()用法相同。
"GET /apache_pb.gif HTTP/1.0" (\"%r\")
    引号中是客户端发出的包含许多有用信息的请求行。可以看出，该客户的动作是GET ，请求的资源是/apache_pb.gif ，使用的协议是HTTP/1.0 。另外，还可以记录其他信息，如：格式字符串"%m %U%q %H"会记录动作、路径、查询字符串、协议，其输出和"%r"一样。
200 (%>s)
    这是服务器返回给客户端的状态码。这个信息非常有价值，因为它指示了请求的结果，或者是被成功响应了(以2开头)，或者被重定向了(以3开头)，或者出错了(以4开头)，或者产生了服务器端错误(以5开头)。完整的状态码列表参见HTTP规范(RFC2616第10章)。
2326 (%b)
    最后这项是返回给客户端的不包括响应头的字节数。如果没有信息返回，则此项应该是"-"，如果希望记录为"0"的形式，就应该用%B 。
    组合日志格式(Combined Log Format)
    另一种常用的记录格式是组合日志格式，形式如下：

LogFormat "%h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-agent}i\"" combined
CustomLog log/access_log combined
    这种格式与通用日志格式类似，但是多了两个 %{header}i 项，其中的header可以是任何请求头。这种格式的记录形如：

127.0.0.1 - frank [10/Oct/2000:13:55:36 -0700] "GET /apache_pb.gif HTTP/1.0" 200 2326 "http://www.example.com/start.html" "Mozilla/4.08 [en] (Win98; I ;Nav)"
    其中，多出来的项是：

    "http://www.example.com/start.html" (\"%{Referer}i\")
    "Referer"请求头。此项指明了该请求是被从哪个网页提交过来的，这个网页应该包含有/apache_pb.gif或者其连接。
    "Mozilla/4.08 [en] (Win98; I ;Nav)" (\"%{User-agent}i\")
    "User-Agent"请求头。此项是客户端提供的浏览器识别信息。

##############################3
邮件服务器
 DNS 服务器 : classroom # 由于目前没有学校DNS服务的搭建

1.server 安装postfix,提供邮件服务软甲

[root@server0 ~]# yum -y install postfix

2.Firewall 设置 trusted 且修改 /etc/post/main.cf

 99 myorigin = server0.example.com
 99 myorigin = $mydomain ##变量调用 #默认补全后缀
 116 inet_interfaces = all  ##本机任何一张网卡都提供 邮件服务
 164 mydestination = $myhostname, localhost.$mydomain, localhost
 164 mydestination = server0.example.com ##判断为本域邮件依据
##重启服务
[root@server0 ~]# systemctl restart postfix.service

####使用mail 命令发信
记得先创建收件人 发件人
mail -s '邮件标题' -r 发件人  收件人@收件域


    [root@server0 ~]# mail -s '买车吗' -r yg xln
    买 奔驰吗?  66 万 ,漏油内种. 一公里没开
    .
    EOT



非交互
echo dc | mail -s '主题' -r 发件人  收件人

mail 收信
mail -u 用户

    [root@server0 ~]# mail -u xln
        Heirloom Mail version 12.5 7/5/10.  Type ? for help.
        "/var/mail/xln": 1 message 1 new
        >N  1 yg@server0.example.c  Thu Apr 18 10:36  18/637   "买车吗"
        &
        Message  1:
#############################
parted分区工具(GPT分区专用)
全程支持tab
GPT最多: 128 主分区
不像fdisk上 w 才写入磁盘, parted 在 你回车时候就已经修改硬盘信息了

[root@server0 ~]# parted /dev/vdb
(parted) mktable gpt ###指定分区模式 ,每个分区只能执行一次
(parted) mkpart #交互式,不支持 中文特殊字符
分区名称? #中文特殊字符
文件系统类型? #xfs ...
起始点? 0 #默认设置
结束点? +2G
(parted) print  #显示分区信息

rm 删除分区####
rm 2 # 分区编号
#############
配置 ipv6
128二进制,冒号分割的十六进制,
eg: 配置 2003:ac18::308/64

nmcli connection show #查看网卡信息
v4 v6 都可以 使用这条命令
nmcli connection modify
   配置                                 #网卡名称 上面查看              #手动                                                    #开机自动链接
[root@server0 ~]# nmcli connection modify 'System eth0' ipv6.method  manual ipv6.addresses '2003:ac18::305/64' connection.autoconnect yes
  激活链接
[root@server0 ~]# nmcli connection up 'System eth0'
[root@server0 ~]# ifconfig |head -5
    eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
            inet 172.25.0.11  netmask 255.255.255.0  broadcast 172.25.0.255
            inet6 2003:ac18::305  prefixlen 64  scopeid 0x0<global>

ping6 2003:ac18::305  ###用ping 不识别
################################
链路聚合
team  聚合链路
 由多块网卡一起组建而成的虚拟网卡
 作用1 论询式(team-slave) 流量负载均衡
 作用2 热备份(activebackup) 链接冗余


怎么做:
1.创建虚拟网卡
team0
参考man teamd.conf
                                 配置文件名字     网卡名字                              这里的 '' "" 不能改变
nmcli connection add type team config-name team0 ifname team0 autoconnect yes config '{"runner" :{"name": "activebackup"}}'

由于这条命令不会覆盖错位的数据 所以 需要删除后 重新 输入
                                       虚拟网卡名字
[root@server0 ~]# nmcli connection delete team0

2.添加成员

[root@server0 ~]# nmcli connection add type team-slave con-name team-1 ifname eth1 master team0
[root@server0 ~]# nmcli connection add type team-slave con-name team-2 ifname eth2 master team0

配置文件
[root@server0 ~]# ls /etc/sysconfig/network-scripts/


3.配置 IP 并激活
###配置 ip
[root@server0 ~]# nmcli connection modify team0 ipv4.method manual ipv4.addresses 192.168.1.1/24 connection.autoconnect yes
[root@server0 ~]# nmcli connection up team0   #####激活
Connection successfully activated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/7)

[root@server0 ~]# teamdctl team0 state  ##查看链路聚合信息


新教学环境的搭建
clone- vm7
调用 脚本进行虚拟机的创建
ROOT
password 123456
真机管理虚拟机
1.直接管理 无需ip 显示开机过程
             虚拟机的名字
virsh console  A


作用:只用来配置IP

退出 : ctrl + ]
2.配置 ip
虚拟机 A
 192.168.4.7/24
 主机名 svr7.tedu.cn

虚拟机 B
 192.168.4.207/24
 主机名 pc207.tedu.cn

添加别名只对 student 生效
[student@student ~]$ vim /home/student/.bashrc
    alias goa='ssh -X root@192.168.4.7'

    alias gob='ssh -X root@192.168.4.207'

查看虚拟机文件内容
[root@pc207 ~]# cat /etc/motd
为虚拟机搭建yum
服务端 :构建 web / ftp服务 共享仓库内容
在真机上安装 vsftpd
    [student@room9pc01 ~]$ rpm -q vsftpd
    vsftpd-3.0.2-22.el7.x86_64
    1. 查看服务状态
        [student@room9pc01 ~]$ systemctl status vsftpd
        ● vsftpd.service - Vsftpd ftp daemon
    2.  创建 /var/ftp/centos-1804
        /var/ftp/ 默认共享位置
        开机自动挂载
        mount -a 检测
        vim /etc/fstab
                                                                          光盘文件系统
        /var/lib/libvirt/images/iso /CentOS7-1804.iso  /var/ftp/centos-1804 iso9660 defaults 0 0

        检测
        [student@room9pc01 ~]$ firefox ftp://192.168.4.254
        A B 都要执行上面操作
常见的一级目录以及用法
        /boot  系统引导必须项目
        /bin /sbin  命令程序文件
        /etc   系统配置文件
        /dev  物理设备
        /root  /home
        /var  经常变化文件  日志文件
        /proc 存放内存中的映射数据,不占用磁盘空间
        /tmp  零时文件   ~]$ ls -ld /tmp/
                            drwxrwxrwt. 29 root root 4096 4月  19 11:32 /tmp/
权限数值的表示
        r = 4
        w = 2
        x = 1
        SUID = 4           S`出现在 x 位置 `
        SGID = 2           S`出现在 x 位置 `
        Sticky Bite = 1    t`出现在 x 位置 `
        注意这里数字 是数字 不能和 字母连用 是能数字与数字 字母与字母

        [student@room9pc01 ~]$ chmod o+7 /etc/
        chmod: 无效模式："o+7"
        设置特殊权限
        第一个数字是附加权限的求和
        [root@svr7 ~]# chmod 7751 /public/ (大规模修改用,精确修改还的用字母)
        [root@svr7 ~]# ls -ld /public/
        drwsr-s--t 2 root root 6 4月  19 11:40 /public/
        [root@svr7 ~]#
        history -c 清空历史命令
        vim /etc/profile
        默认1k行
        !str  (常用)
        !xxx
        执行历史命令中最近以str开头的命令
          vim /etc/profile
          [root@svr7 ~]# systemctl restart httpd
          [root@svr7 ~]# !sys
          systemctl restart httpd
统计文件或者目录信息
         du

        [root@svr7 ~]# du -sh /root/
        13M	/root/
date查看/调整系统 时间  #####常常充当变量用
        date %F  显示Y- M -D
        date +%Y  只显示年
        date +%m 只显示月
        date +%d  只显示日
        date +%H  只显示小时
        date +%M  只显示分钟
        date +%S  只显示秒
软硬链接  ------制作快捷方式
    1.软连接(最多)
        ln -s /路径/软文件  /路径/快捷方式 (青色)
                  当你不起名字时候默认和源文件名相同
                  原始文件被干掉后软链接不可用
                  可以跨分区
        [root@svr7 ~]# mkdir /public/
        [root@svr7 ~]# ln -s /public/ /root/zz
        [root@svr7 ~]# ls
        Desktop  zz

    2.硬连接  (限制比较大)

        ln  /路径/软文件  /路径/快捷方式 (原始文件被干掉后硬链接依然可用)
        并且不可已跨分区使用,不能用在目录上
获取帮助
    1.利用help
        xxx --help
    2.权威帮助信息
        man  xxx
        mna 5 passwd ###5 表示文字帮助信息
        man 默认查看命令帮助信息
ZIP 归档工具,具有夸平台压缩归档格式
        zip [-r] 备份文件.zip  被归档文件    -r 递归  目录必须加

   释放zip
        unzip 备份文件.zip [-d] 目标文件夹   -d 指定目录,目录不从在会自动创建
        检测ce
将 ftp 上rhce测试脚本
        desktop0.sh  rht-labcheck  server0.sh
下载到/home/student/bin
        运行 rht-labcheck 进行检查

自定义yum 仓库(客户端)
      1.将ftp中 tools.tar.gz下载到真机桌面
      2.将真机的tools.tar.gz上传到虚拟机A的root下
         scp依赖于ssh
         scp /本地路经/源文件  root@对方ip:/对方路径
      3.生产仓库数据文件
         yum -y install createrepo
         createrepo /tools/other/
      4.修改yum配置文件
         vim /etc/yum.repos.d/local.repo
         [A-repo]
         name=other
         baseurl=file:///tools/other
         enabled=1
         gpgcheck=0
      5. 显示安装路径
         rpm -ql XXX
         rpm -ql cmatrix


      在命令后面加上 & 将 程序放入后台
yum install 出现错误 :  Transaction check error:
 这就表示 出现了依赖冲突
 rpm -e package-name 卸载后 重新执行

vim 编辑技巧
    vi :linux基本的文本编辑器
    依然和vim一样有三个模式
    命令模式
    12G 跳转到第12行
    GG 末尾
    gg开头
    yy复制
    p黏贴
    dd删除当前行
    d$ 或者 D 从光标处删除到行尾
    C 从光标处删除到行尾,进入插入模式
    d^ 从光标处删除到行首
    u 撤销
    U 撤销当前行所有操作
    ctrl + r 取消前一次撤销操作 (反撤销)
    shift + ZZ   保存且退出(命令模式)

    / 查询
   末行 模式
   :w  保存
   :q! 强制退出
   :W /root/newfile
   :set nu 显示行号
   :r /xxx/xxx  在当前行插入文件 ###常用
   字符串的替换
   :%s /old/new/g  替换文件所有的 old
   :s /old/new/g  替换光标当前行所有old
   :s /old/new/   替换光标所在行的第一个 old
   :1,10 s/old/new/g   替换第1-10行所在行所有old
   开关参数的控制
   :set nu或nonu
   :set ai或noai 自动缩进
   将文件直接导入本文件
   :r  文件路径   #############注意光标的位置,会直接将文件放在光标之后
###################################################


Linux 安装  nfs-3g

mount.nfs-3g  /dev/xxxx  /挂载点/
##################################

kvm 虚拟化

概述 :
virtualization 资源管理

kvm构建以及管理

虚拟化软件
vmware
virtualpc Hyper-v(MICROSOFT)
KVM RHEV (REDHAT)
XEN  (CITRIX)
ORACLe VM VIRTUAALBOX (ORACLE)

安装 kvm 所需要的软件包

– qemu-kvm	:为 kvm 提供底层仿真支持
– libvirt-daemon	:libvirtd 守护进程,管理虚拟机
– libvirt-client	:用户端软件,提供客户端管理命令
– libvirt-daemon-driver-qemu	:libvirtd 连接 qemu 的驱动
– virt-manager	:图形管理工具

 systemctl restart libvirted
 systemctl enable libvirtd

 LANG=en virt-manager  ##启动服务

需要cpu支出虚拟化功能
在bios中开启 虚拟化功能

如何管理kvm

virt-manager

virsh 控制工具
  virsh console  虚拟机名字 ###真机直接管理虚拟机 不需要IP
  virsh nodeinfo          ####查看kvm节点信息
  virsh list(--all)              ####列出虚拟机
  virsh net-list(--all)   ##列出虚拟网络
  virsh dominfo   虚拟机名字        ###查看指定虚拟机的信息
  virsh autostart  虚拟机名字  ###将虚拟机设置为开机自启
  virsh autostart --disable  虚拟机名字 ###将虚拟机开机自启取消
  virsh start|reboot|shutdown  虚拟机名字 ###
  virsh destroy   虚拟机名字 ###强制关闭
一台虚拟机的构成
    xml 配置文件 (虚拟机配置文件) :定义虚拟机的名称 UUID CPU 内存
 磁盘 网卡 等 参数信息
    磁盘镜像文件 :保存 虚拟机的操作系统以及文档信息   路径取决于 xml文件定义
    存放 xml文件  /etc/libvirt/qemu
    在本机中 文件默认存放于 /var/lib/libvirt/images/
    导出xml配置文件
       查看 vrish dumpxml  虚拟机名称
       备份 virsh dumpxml  虚拟机名 > 虚拟机名.xml
       虚拟机名称 ,UUID  虚拟机磁盘文件路径 网卡MAC 地址
 ###########################################
  新建一个虚拟机
  nsd01 2g 内存 网络 private 1  9g disk  网络类型 private 1  最小化安装 自动分区 root 密码 1
 #############################################
  利用虚拟机nsd01作为模板,复制一份手动生产全新虚拟机 nsd2
  1.将虚拟机磁盘文件复制一份修改磁盘文件名称
  /var/lib/libvirt/images/
  [root@room9pc01 images]# cp nsd01.qcow2 nsd02.qcow2
   df -h 查看文件大小 /xmlq
  2.将nsd01的xml文件复制,修改 磁盘文件的位置
    [root@room9pc01 qemu]# virsh dumpxml nsd01  > /xmlfire/nsd02.xml
    [root@room9pc01 qemu]# vim /xmlfire/nsd02.xml
    生成uuid ,将原本的UUID替换
    uuidgen
    修改磁盘文件 位置
    <source file='/var/lib/libvirt/images/nsd02.qcow2'/>
    修改mac地址 ,删除 ,删除后\kvm会自己生成
    <mac address='56:54:00:98:05:e6'/>
  3.导入虚拟机信息
    [root@room9pc01 qemu]# virsh define /xmlfire/nsd02.xml
    定义域 nsd02（从 /xmlfire/nsd02
    启动管理软件
    [root@room9pc01 qemu]# virt-manager
  4.删除命令
    vrish undefine nsd02  ###只是删除 /etc/libvirt/qemu 下的 xml删除了 ,
    [root@room9pc01 qemu]# ls /etc/libvirt/qemu
    1.txt      B.xml          desktop.xml  nsd01.xml
    autostart  classroom.xml  D.xml        server.xml
    A.xml      C.xml          networks     win2008.xml

  使用 virsh edit xxx  可以达到  修改 复制xml 导入 这三条命令  除了复制磁盘文件 (命令行常用,但是脚本中用不到)

cow(写时复制)技术(快速克隆虚拟机关键技术) (也是docker技术的关键)
 copy on write
 特点:
     直接映射原始盘的数据内容
     当原始盘的旧数据有修改时,在修改之前自动将旧数据存入前端盘
     对前端盘的修改写不到原始盘
     前端盘在生成的时候 其实是一对快捷方式 (可能是软连接 ?)
快速创建qcow文件
     qemu-img 通过 -b 选项复用指定原始盘  -f 指定文件类型(qcow2 / rar )
     qemu-img create 磁盘文件 #快速产生一个任意大小的磁盘文件,内容为空
     qemu-img info 磁盘文件  ##查看磁盘文件信息
     qemu-img  create -f qcow2 -d /var/lib/libvirt/images/nsd01.qcow2 /var/lib/libvirt/images/nsd06.qcow2  10G
     qemu-img create  -f  文件类型 -d 原始盘 前端盘 前端盘大小
###############################
    1.以nsd01通过写实复制技术产生虚拟机前端盘
      images]# qemu-img create -f qcow2 -b /var/lib/libvirt/images/nsd01.qcow2 /var/lib/libvirt/images/nsd06.qcow2 10G
    2.产生并修改xml文件
     virsh edit xxx.xml
    3.开机
     virsh start xxx
配置虚拟机系统
    离线访问虚拟机磁盘文件内容
    guestmount -a 虚拟机磁盘路径 -i /挂载节点

########################## 扩展虚拟机磁盘
教学环境(在虚拟机上用 )  扩展磁盘空间当虚拟机磁盘不够用时
LANG=en growpart /dev/vda 1  ##扩展/dev/vda 的第一个分区空间
lsblk
blkid /dev/vda1
xfs_growfs /dev/vda1###扩展/dev/vda1 文件系统
df -h


##########################
DNS 解析的作用  端口 53
  域名解析服务
    两个功能
    正向解析 : 根据注册的域名查看对应的ip (最常用的)(web服务:域名到 ip)
    反向解析 : 根据ip查找域名  (邮件服务 ip到 域名)

    虽然 你在浏览器中输入的域名 但其实 实际起作用的还是ip地址
    DNS分为三类 :一级 DNS二级DNS  三级DNS
    通常由服务器用来解析那一类地址(一类地址,二类地址,三类地址) 用来区分 哪一级DNS
    所有的域名都要以 . 结尾 规定 ;  . 称为根域   专门维护 . 的服务器称为根域名服务器
##########################################
        根域:
        一级域名: cn        hk  kr  jp  tw  us
        二级域名  .com.cn   .net.cn   org.cn
        三级域名  xxx.com.cn         nb.com.cn
        Full Qualified Domain Name  (FQDN) 完全合格主机

        主机头部,正确申请的域名结尾
        CNNIC--中国互联网信息中心  墙 ?
#######################################
    虚拟机A构建基本DNS\dns服务
        1.安装 bind  bind-chroot
            伯克利发明
            bind.x86_64 32:9.9.4-61.el7 // 域名服务包
            服务: named
            端口: 53
            主配置文件: /etc/named.conf  // S设置本机复制解析的域名
            地址库文件: /var/named/      //FQDN 与 ip地址额关系
            SVR7
               vim /var/named.conf
               options {
                    listen-on port 53 { any; }; 或者删除这一行就意味着 为任何人服务// 这里的127 需要修改为any
                  directory       "/var/named";
                       };
               zone "tedu.cn" IN {
                                    type hint;
                                    file "tedu.cn.zone";
                                   };

            [root@svr7 named]# cp -p named.localhost  tedu.cn.zone
            [root@svr7 named]# pwd
            /var/named
            [root@svr7 var]# vim /var/named/tedu.cn.zone

                                                       ###注意这个点
                    tedu.cn. NS     svr7               ##申明负责解析tedu.cn域名为svr7 主机
                    svr7     A      192.168.4.7        ###申明svr7 主机的ip地址为  192.168.4.7
                    www      A      192.168.4.2        ###正常解析纪录
                    ftp      A      192.168.4.250      ###正常解析纪录
                    AAAA 是ipv6 用的
            [root@svr7 named]# systemctl restart named
            bind-chroot.x86_64 32:9.9.4-61.el7   // 提供 虚拟根支持(牢笼政策)

            发现 bind 中病毒 将bind 放在 /var/named/chroot

        虚拟机B PC7
            1.指定dns服务器地址(客户机)  nmtui也可以
                [root@pc207 ~]# vim  /etc/resolve.conf
                search tedu.cn
                nameserver 192.168.4.7
            2.测试dns 服务
                [root@pc207 ~]# nslookup svr7
                Server:		192.168.4.7
                Address:	192.168.4.7#53

                Name:	svr7.tedu.cn
                Address: 192.168.4.7

###################################################
虚拟机负责qq.com的解析
        1.修改主配置文件
            [root@svr7 named]# vim /etc/named.conf

            zone "qq.com" IN {
                type hint;
                file "qq.com.zone";
                            };
        2.修改地址库文件
            [root@svr7 named]# vim /var/named/qq.com.zone
            qq.com.  NS  svr7
            svr7    A   192.168.4.7
            www     A    1.1.1.1
            ftp     A    2.2.2.2
        3.测试访问

            [root@pc207 ~]# nslookup www.qq.com
            Server:		192.168.4.7
            Address:	192.168.4.7#53

            Name:	www.qq.com
            Address: 1.1.1.1

#####################################
 特殊的解析纪录
        1.基于域名的负载均衡(但是现在不用了)

            在地址库文件中,对于一个地址添加多个,A纪录 ,客户端访问的请求会随机分配到 其中的任意一个
            [root@svr7 named]# vim /var/named/qq.com.zone
                qq.com.  NS  svr7  ########NS 前面的域名需要 添加  " . "
                svr7    A   192.168.4.7
                www     A    1.1.1.1
                www     A    1.1.1.3
                www     A    1.1.1.6
                ftp     A    2.2.2.2
                *       A      1.2.3.4  ###不管前面写啥 只要域名正确就解析到这和地址


        2.有规律的泛域名解析
            内置函数:$GENERATE 制造连续范围的数字
            $GENERATE  起始-结束
            eg:
            server
            vim /var/named/qq.com.zone
            $GENERATE 1-50  PC$  A  192.168.10.$
            desktop
            nslookup PC1.qq.com
            Server:		192.168.4.7
            Address:	192.168.4.7#53

            Name:	PC1.qq.com
            Address: 192.168.10.1

            tts     CNAME   ftp  ######tts的解析地址和ftp解析地址相同

            eg:
                [root@pc207 ~]# nslookup tts.qq.com
                Server:		192.168.4.7
                Address:	192.168.4.7#53

                tts.qq.com	canonical name = ftp.qq.com.  ####注意这句话
                Name:	ftp.qq.com
                Address: 6.6.6.6

        面试提问: DNS服务器资源解析纪录类型 ? ##目前基础阶段
                A      地址解析记录
                CNAME  声明DNS 服务器记录
                NS   解析记录别名
        客户端解析域名优先级
        1./etc/hosts         ## 直接提供解析结果 ,若这个文件解析不了才会找dns 解析,且只能在本机有效
        2./etc/resolv.conf   ##DNS 服务器地址
################################################################
        子域授权
        虚拟机A 负责 qq.com
        虚拟机B 负责 bj.qq.com
 ###################################################

         DNS子域授权

             父域:www.qq.com
             子域:www.bj.qq.com

          虚拟机A负责解析qq.com域名
          虚拟机B负责解析bj.qq.com域名

        虚拟机B:搭建为DNS服务器,负责解析的域名为bj.qq.com
        [root@pc207 ~]# yum -y install bind bind-chroot
        [root@pc207 ~]# cp /etc/named.conf /etc/named.bak
        [root@pc207 ~]# vim /etc/named.conf
         options {
                directory       "/var/named";
          };
         zone "bj.qq.com" IN {
                type master;
                file "bj.qq.com.zone";
          };
        [root@pc207 ~]# cd /var/named/
        [root@pc207 named]# cp -p named.localhost bj.qq.com.zone
        [root@pc207 named]# vim bj.qq.com.zone
        bj.qq.com.      NS      pc207
        pc207           A       192.168.4.207
        www             A       50.60.70.80
        [root@pc207 /]# systemctl restart named
        [root@pc207 /]# nslookup  www.bj.qq.com  192.168.4.207




        子域授权

            虚拟机A负责解析qq.com域名
            虚拟机B负责解析bj.qq.com域名

            解析子域的域名,请求虚拟机A,可以解析
        虚拟机A:
        [root@svr7 ~]# vim /var/named/qq.com.zone
         qq.com.       NS  svr7
         bj.qq.com.    NS  pc207
         svr7           A  192.168.4.7
         pc207          A  192.168.4.207
         www            A  192.168.4.10
         ftp            A  2.2.2.2
        [root@svr7 ~]# systemctl restart named
        [root@pc207 /]# nslookup www.bj.qq.com 192.168.4.7
        Server:		192.168.4.7
        Address:	192.168.4.7#53

        Non-authoritative answer:   #非权威解答
        Name:	www.bj.qq.com
        Address: 50.60.70.80
        [root@pc207 /]#


##########################################
        递归查询:接受客户端请求,本机与其他dns服务器交流并将 解析结果带回来
        根域名 是不支持的
        迭代查询 : 本机与其他DNS服务器交流
        根域名支持
##########################################
        缓存dns,提高解析速度(企业内部网络)
        在虚拟机A dns服务器  ####之前已经搭好
        在虚拟机B 缓存dns服务器 ###修改 options 删除 zone
               options {
                        directory       "/var/named";
                        forwarders { 192.168.4.7; };  ###转发给4.7
                };

        在虚拟机C 客户机  ###测试
                [root@C ~]# nslookup ftp.tedu.cn 192.168.4.207
                Server:		192.168.4.207
                Address:	192.168.4.207#53

                Non-authoritative answer:
                Name:	ftp.tedu.cn
                Address: 192.168.4.250
#################################################
Split 分离解析
        什么是: 当收到客户端 的dns查询请求的时候
                能够区分客户机的来源地址
                为客户端提供最近的服务器
                为不同类别的客户提供不同的解析结果(IP地址)


        配置:
        1.匹配即停止
        2.分类要合理,每一个客户端都要找到自己分类
        viem "name0"{
        match-clients { 来源地址;....; };    #匹配客户机来源
        zone "12306.cn" IN { ...地址库1; };
        };
        viem "name1"{
        match-clients{ 来源地址;...; };        #匹配来源
        zone "12306.cn" IN { ...地址库; };
        };
        viem "name3"{
        match-clients{ any; };             #匹配来源 ,上面都不符合的话他将是最后一个 负责解析
        zone "12306.cn" IN { ...地址库; };
        };
    eg:A 纪录分离解析  -----以 www.tedu.cn 为例子
    客户机解析结果
            192.168.4.207---------->  192.168.4.100
            其他地址---------------->  1.2.3.4



            [root@svr7 named]# vim /etc/named.con
                        options {
                    directory       "/var/named";

             };

            view "nsd" {
            match-clients { 192.168.4.207; };
              zone "tedu.cn" IN {
                    type master;
                    file "tedu.cn.zone";
                        };
            };

            view "other" {
            match-clients { any; };
            zone "tedu.cn" IN {
                    type master;
                    file "tedu.cn.other";
                        };
            };

            [root@svr7 named]# vim tedu.cn.other
            tedu.cn.  NS      svr7
            svr7      A      192.168.4.7
            www      A      1.2.3.4
            [root@svr7 named]# vim tedu.cn.zone
            tedu.cn.  NS      svr7
            svr7     A      192.168.4.7
            www      A      192.168.4.100

            [root@svr7 named]# !sys
            [root@pc207 ~]# nslookup www.tedu.cn
            Server:		192.168.4.7
            Address:	192.168.4.7#53

            Name:	www.tedu.cn
            Address: 192.168.4.100




###########################################

192.168.4.207---------->tedu.cn------------> 解析地址 Address: 192.168.4.100
other IP访问------------>tedu.com-----------> 解析地址Address: 1.2.3.4

192.168.4.207---------->sina.com------------> 解析地址 Address: 192.168.4.200
other IP访问------------>tedu.com-----------> 解析地址Address: 10.20.30.40


    [root@svr7 named]# vim /etc/named.conf   #####修改主配置文件

        options {
                directory       "/var/named";

         };
            ####正确写法 ###### 一个match-clients 只能用一次
        view "nsd-yedu" {
        match-clients { 192.168.4.207; };
          zone "tedu.cn" IN {
                type master;
                file "tedu.cn.zone";
                    };
           zone "sina.com" IN {
                type master;
                file "sina.com.zone";

               };

        };
        ########## 错误写法  虽然 服务重启成功 但是无法解析
         #view "nsd-sina"
        #{match-clients { 192.168.4.207; };
        #zone "sina.com" IN {
        #       type master;
        #       file "sina.com.zone";

         #      };
        #};




        view "other-tedu" {
        match-clients { any; };
        zone "tedu.cn" IN {
                type master;
                file "tedu.cn.other";
                    };
    [root@svr7 named]# vim /var/named/sina.com.zone  ##### 添加地址库文件
        sina.com.  NS      svr7
        svr7     A      192.168.4.7
        www      A      192.168.4.200
    [root@svr7 named]# vim /var/named/sina.com.other  ##### 添加地址库文件
        sina.com.  NS      svr7
        svr7     A      192.168.4.7
        www      A      10.20.30.40

    [root@pc207 ~]# nslookup www.sina.com   #####测试访问
    [root@pc207 ~]# nslookup www.sina.com
        Server:		192.168.4.7
        Address:	192.168.4.7#53

        Name:	www.sina.com
        Address: 192.168.4.200



    [root@pc207 ~]# nslookup www.tedu.cn #####测试访问
        Server:		192.168.4.7
        Address:	192.168.4.7#53

        Name:	www.tedu.cn
        Address: 192.168.4.100

#############################
    acl test={ 192.168.4.7; 192.168.4.8; 192.168.4.9;  };  ##类似于变量的功能方便之后调用

       match-clients { test; }; ##调用

#############################################

    RAID 磁盘阵列
            廉价冗余磁盘阵列
            Redundant Arrays of Inexpensive Disk
          什么是:
             通过软件/硬件技术,将多个较小的/低速的磁盘整合称为一个大磁盘
              阵列的价值:提高I/O效率,硬件级别的数据冗余
              不同RAID级别的功能,特性不同
          作用:提高磁盘的高可用
          分类:
              RAID0  , 条带模式

                    同一个文档分散存放在不同磁盘
                    并行写入以提高效率
                    至少两块磁盘
              RAID1  , 镜像模式
                    一个文档复制多份,分别写入不同的磁盘
                    多份拷贝提高可靠性,效率无提升
                    至少两块磁盘
              RAID0+1 ,RAID1+0(绝迹江湖)
                    整合RAID0,RAID1的优势
                    并行存储提高效率,镜像写入提高可靠性
                    至少四块磁盘

                   0+1
                      分别将两组磁盘做成RAID0,将两个RAID0再作成RAID1
                   1+0
                      分别将两组磁盘做成RAID1,将两个RAID1再作成RAID0

              RAID5
                    至少需要三块磁盘
                    需要至少一块用来存放校验数据
                    相当于RADI0 和 RADI1 的折中方案
              RAID6 高可用(银行)
                    相当于扩展的RAID5阵列,提供两份独立的校验方案
                    至少需要两块磁盘存放校验数据
                    至少需要四块磁盘组成
############################################################
   进程管理
           程序:静态的代码  占用磁盘空间
           进程:动态代码   占用CPU MEMORY

           进程整体也是树型结构
           父进程与子进程
           特殊进程:僵尸进程(程序假死)  孤儿进程(程序执行过程中,父进程的突然终止只剩子进程)
           唯一编号 PID
           当父进程kill之后,其子进程也会被kill
           systemd:所有进程的父进程,也负责管理孤儿进程,
   查看进程树
            pstree
            pstree lisi 显示某用户开启的进程
   显示进程的详细信息
            ps
                 选项:
                 aux  列出正在运行的所有进程
                 -elf  ppid 父进程id  列出正在运行的所有进程

   统计命令
            wc

                        eg:
            统计正在运行的进程又少个?
            ps aux | wc -l
            ps -elf | wc -l
            统计当前有多少用户?
            wc -l /etc/passwd
            wc -l /etc/shadow
            统计 /etc/下 所有以 conf结尾的文档?
            [root@server0 ~]# find /etc/   -name '*.conf' | wc -l
            395

   进程动态排名
            top [-d刷新秒数] [-u用户名]  查看 系统运行时间

             CPU 工作负载  1MIN  5MIN  15MIN
            load average: 0.00, 0.01, 0.05

   pgrep [-l 进程名]  [-x 进程名] [-U 用户名]
           -l 输出进程名 而不仅是pid
           -x 精确匹配完整进程名
           -U 检索指定用户的进程
   控制进程
          进程的前后台调度
          正在运行
          ctrl + z  将正在运行的程序暂停并放入后台
          jobs -l ()查看后台
          bg 将后台任务继续运行
          fg 将后台程序恢复到前台继续运行
          $ 后台运行
#######################################
    杀死进程
          #############[-9] 强制执行 能不用就不用
          ctrl + c 结束当前正在运行的程序
          kill [-9] PID  kill [-9] %PID
          killall  [-9] 进程名
          pkill 查找条件 (包含条件的都要杀)
###########################################
            杀死一个用户开启的所有进程(强制踢出一个用户)
            [root@server0 ~]# killall -9 -u lisi
#######################################
日志管理
              什么是日志:纪录系统,程序运行中发生的各种时间
              作用:通过查看日志,;了解以及排除故障
              信息安全控制依据
              记录内核消息,各种服务的公共消息
                /var/log/message
              记录系统启动过程中的相关信息
                /var/log/dmesg
              记录与cron计划任务相关的消息
                /var/log/cron
              记录邮件收发相关
                /var/log/maillog
              记录与访问限制相关安全消息
                /var/log/sucure
        追踪日志消息
            tailf  文件名
        专用分析工具
            Webmin 系统管理套件
            ....
        用户登录分析
            users , who ,w 命令
            查看已登录的用户 详细程度依次递增
            last ,lastb 命令
            查看最近登录成功/失败的用户消息
        日志级别
            数值越小代表越优先
            0-7
        3   ERR  运行出现错误
        4   WARNING 可能会影响系统功能的事件
journalctl 工具
        journalctl(rht7 以上才有)
        提取systemd-journal 服务搜集日志
        journalctl -u


#####################################
systemd
        一个高效的系统&服务管理器
        开机服务并启动,各系统服务间的精确依赖
        配置路径:  /etc/systemd/system/
        服务目录:  /lib/systemd/system/
        主要管理工具  systemctl
        systemctl restart 重启服务
        systemctl start   开启服务
        systemctl status  查看服务当前状态
        systemctl stop    停止服务
        systemctl enable  设置开机自启
        systemctl disable 关闭卡机自启

运行级别的切换(rhel6/5)
        init 5  切换到图形界面
        init 0  关机
        init 3  多用户字符界面(支持网络) 服务器默认运行级别
        init 2  多用户字符界面(不支持支持网络)
        init 5  重启
        init 1  单用户破解密码
rhel7 运行模式
        切换到字符界面
              systemctl isolate multi-user.target
        切换到图形
              systemctl isolate graphical.target

        设定默认的运行模式
              systemctl set-default multi-user.target ##字符界面
              systemctl set-default graphical.target  ##图形界面
        查看默认的运行模式
              systemctl get-default

###########################################################################################
开机启动项目:(默认) 1.本机硬盘 2.光驱设备 3.u盘 4.网络  (顺序可以修改)


DHCP 原理 : 广播进行,先到先得,一个网络只能有一个dhcp服务器 #####工作时请先询问 网络工程师

        DHCP 地址分配的四次会话
            DISCOVERY    --->    OFFER        --->      REQUEST       --->         ACK
           寻找 DHCP服务器       dhcp服务器回应         提供dhcp服务分配ip       确认网络中没有 ip地址冲突

        虚拟机 A :
                安装软件  dhcp
                配置文件  /etc/dhcp/dhcpd.conf
                其服务    dhcpd
        安装 dhcp 服务
        [root@svr7 etc]# yum -y install dhcp
        修改配置文件
        (将 /usr/share/doc/dhcp*/dhcpd.conf.example 中的配置文件导入 dhcp.conf 中 修改到如下;使用 :r /usr/share/doc/dhcp*/dhcpd.conf.example
 导入)
        vim /etc/dhcp/dhcpd.conf

                  subnet 192.168.4.0 netmask 255.255.255.0 {  ###分配的网段
                  range 192.168.4.100  192.168.4.200;         ##分配的ip范围
                  option domain-name-servers 192.168.4.7;     ##分配dns地址
                #  option domain-name "internal.example.org"; ###### 域名
                  option routers 192.168.4.254;               ##指定网关地址,一般为路由地址
                #  option broadcast-address 10.5.5.31;        ##广播地址
                  default-lease-time 600;                     ###地址租约时间
                  max-lease-time 7200;
                }
####################################################################################################
网络装机的概述 (云平台的基础) (必须会 面试必考)

        优势:
            规模化   同时装配多台主机
            自动化   装系统 配置 各种服务
            远程实现 不需要光盘

什么是PXE网络
        PXE  pre-boot execution  environment
            预启动执行环境,在操作系统之前运行
            可远程安装
        pxe 装机: 服务提供的顺序是, hdcp提供ip ,TFTP提供 引导 驱动,HTTP提供RPM软件包
        服务端(PXE装机服务器)
        DHCP服务  分配ip 定位引导程序
        TFTP服务  提供引导程序下载
        HTTP服务  (或FTP/NFS)提供yum 安装源
        客户机要求:
                网卡支持PXE 协议
                主板支持从网卡启动


##############################################################################
PXE 的安装  #####面试必考

        1.搭建DHCP服务
            由于已经安装好,我们需要修改配置文件
            [root@svr7 etc]# vim /etc/dhcp/dhcpd.conf  ####dhcp配置文件
            在{}中添加如下两行
            next-server 192.168.4.7; ###指定下一个服务地址
            filename "pxelinux.0";  ####指定引导文件名称 注意这里的双引号不能用单引号
            单引号双引号的区别
                单引号 屏蔽特殊含义  '$a' 就代表 字符$a
                双引号 不屏蔽特殊含义  "$a" 则代表 变量$a
            "pxelinux.0" 网卡引导文件(安装说明书) 二进制文件
            重启服务
            systemctl restart dhcpd
        2.搭建TFTP服务
            安装
                 yum -y install tftp-server ####注意安装包的名
            默认共享位置
                 /var/lib/tftpboot/
            启动服务
                 systemctl restart tftp
            部署pxelinux.0
                1)查询 该文件是由那个服务产生
                    yum provides 路径
                    yum provides */pxelinux.0  ###查询那个包产生 pxelinux.0 这个文件
                    已加载插件：fastestmirror
                    Loading mirror speeds from cached hostfile
                    syslinux-4.05-13.el7.x86_64
                2)安装 syslinux
                    查询pxelinux.0 文件产生的位置
                    rpm -ql syslinux | grep pxelinux.0
                3)将文件复制到(tftp)默认共享的位置 /var/lib/tftpboot/
                    cp /usr/share/syslinux/pxelinux.0 /var/lib/tftpboot/
                4)产生pxe菜单
                    isolinux.cfg
                    菜单文件 默认位置 ( isolinux/isolinux.cfg)
                    从光盘中获取菜单文件
                    由于虚拟机没有光驱,所以关机添加光驱
                    wget 或者 mount 直接挂载iso文件
                    挂载 iso
                        mount /dev/cdrom /mnt/
                    创建文件夹
                        mkdir /var/lib/tftpboot/pxelinux.cfg
                    拷贝到文件夹并将名称修改为default /var/lib/tftpboot/pxelinux.cfg/
                        cp /mnt/isolinux/isolinux.cfg /var/lib/tftpboot/pxelinux.cfg/default

                5)图形模块vesamenu.c32 和背景图片 splash.png
                    cp /mnt/isolinux/vesamenu.c32 /mnt/isolinux/splash.png /var/lib/tftpboot
                    ls /var/lib/tftpboot/  ##查看文件
                    pxelinux.0  pxelinux.cfg  splash.png  vesamenu.c32

                6)启动内核  vmlinuz 和驱动程序 initrd.img
                    将内核和驱动程序复制到  TFTP的 默认共享位置 /var/lib/tftpboot
                    cp /mnt/isolinux/vmlinuz /mnt/isolinux/initrd.img /var/lib/tftpboot/

                7)修改菜单文件
                     vim /var/lib/tftpboot/pxelinux.cfg/default
                     修改文件
                     1 gg 跳转到第一行
                       1 default vesamenu.c32 ###图形模块
                       2 timeout 600         ###延时 60s 单位 ms
                       4 display boot.msg
                       10 menu background splash.png   ###指定背景图片
                       11 menu title CentOS 7          ###启动标题
                       61 label linux
                       62   menu label ^Install CentOS 7 ###启动项标题 ^I 表示 该选项的快捷键是 I
                       63   menu default                ###设置读秒结束后默认启动项目
                       64   kernel vmlinuz
                       65   append initrd=initrd.img
                       ##同理
                       66 label check
                       67   menu label Test this ^media & install CentOS 7 ###启动项标题 ^m 表示 该选项的快捷键是 m

                8)设置服务的开机自启
                     [root@svr7 ~]# systemctl restart dhcpd
                     [root@svr7 ~]# systemctl enable dhcpd
                     [root@svr7 ~]# systemctl restart tftp
                     [root@svr7 ~]# systemctl enable tftp
        3.构建web服务,共享iso 内容
            1)安装httpd 重启服务
                yum -y install httpd
                [root@svr7 ~]# systemctl restart httpd.service
                [root@svr7 ~]# systemctl enable httpd.service
            2)共享光盘内容
                [root@svr7 ~]# mkdir /var/www/html/centos/
                [root@svr7 ~]# mount /dev/cdrom /var/www/html/centos/
                mount: /dev/sr0 写保护，将以只读方式挂载
                [root@svr7 ~]# firefox 192.168.4.7/centos  ##访问测试
           4) 部署无人值守安装,生成应答文件
                [root@svr7 ~]# yum -y install system-config-kickstart
                LANG=en system-config-kickstart
                首先查看软件包选择是否可用(redhate7 会显示disable)
                package select
                需要yum仓库的支持,必须要求 yum光盘表示[development]
                重启软件
                system-config-kickstart
                basic configuration : 时区 上海  安装完成重启
                installation method : profrom new installation
                                      installation source   httpd
                                      httpserver 192.168.4.7  ###http主机ip
                                      http directory centos   ###和http配置中创建的 centos 对应
                partition information : master boot record clear master record
                                        partition  remove all existing partitions
                                        disk label initialize the disk label
                                        layout  add  / xfs  full disk
                network configuration   add network driver etho dhcp
                authentication 跳过
                Firewall       disable
                selinux        disable
                display configuration 跳过
                package select system --> base
                posinstallation script   user a interpret    /bin/bash
                                        useradd lisi
                                        echo 123 | psswd --stdin lisi
                保存 至 root下
        4.利用web服务,将应答文件 ks.cfg ,共享给客户端
                [root@svr7 ~]#  cp /root/ks.cfg /var/www/html/
        5.修改pxe配置文件 修改 应答文件位置

                 [root@svr7 ~]# vim /var/lib/tftpboot/pxelinux.cfg/default
            65   append initrd=initrd.img ks=http://192.168.4.7/ks.cfg  ####注意这里的IP地址应和 DHCP 的配置文件中 DNS 的地址相同


验证:
                    新建虚拟机  安装选择 PXE   网络private1   内存 2G  其他随机
                    由于目前 PXE 安装文件并没有 完成 所以 看到 安装的 界面就算完成
思路:                DHCP服务->  IP 地址  -> next-server  filename
                    tftp服务 -> pxelinux.0
                    pxelinux.0 -> 读取默认菜单文件
                    default ->图形模块  背景图片 启动内核 驱动程序  应答文件
                    ks.cfg 应答文件 ->分区 语言  键盘类型  装包
                    url --url='http://192.168.4.7/centos' #当 next-server 地址变化 这里也要变化
#############################################################
cobbler 装机平台 (pxe)  ( 新技术越来越多)
        主要适用于centos 系统, 适合多平台的的安装
        集中管理所需服务,如DHCP,DNS TFTP,WEB
        内建 一个镜像版本仓库
        内建ks应答文件
        提供yum 管理 web  api 借口 电源管理

        优点就是自动化程度高
        缺点修改ks.cfg 有点儿难
        1)将cobbler.zip 安装包 scp到虚拟机
            [student@room9pc01 ~]$ scp /home/student/桌面/cobbler.zip root@192.168.4.7:/root/
        2)解压
            [root@svr7 ~]# unzip cobbler.zip -d /
            将文件解压到/opt/     下
            [root@svr7 cobbler]# unzip cobbler_rpm.zip -d /opt/
        3)安装 并 检测
            [root@svr7 cobbler]# yum -y install /opt/cobbler/*.rpm mod_ssl dhcp httpd
            [root@svr7 cobbler]# rpm -q cobbler
            cobbler-2.8.2-1.el7.x86_64
            一下是需要查看是否安装完成的程序列表
            cobbler
            cobbler-web
        4)配置 cobbler
            只要修改四行 对于格式有着严格要求
            [root@svr7 cobbler]# vim /etc/cobbler/settings
            next_server: 192.168.4.7
            server: 192.168.4.7
            manage_dhcp: 1
            pxe_just_once: 1
        5)配置cobbler 的dhcp
            [root@svr7 cobbler]# vim /etc/cobbler/dhcp.template
            [root@svr7 cobbler]# vim /etc/cobbler/dhcp.template
             :%s /192.168.1/192.168.4/g
        6)绝对路径解压释放 cobbler_boot.tar.gz
            [root@svr7 cobbler]# tar -xPf cobbler_boot.tar.gz
            ####在解压过程中 依照压缩前的 路径 将 文件释放到 源位置
        7)启动服务
            #######一次启动多个服务  推荐使用
            [root@svr7 cobbler]# for i in cobblerd httpd tftp rsyncd
            > do
            > systemctl restart $i
            > systemctl enable  $i
            > done
        8)测试
            [root@svr7 cobbler]# cobbler sync
            *** TASK COMPLETE ***
            测试完成
        9)导入安装镜像文件
            mount /dev/cdrom /dvd
            df -h
            cobbler import --path=/dvd --name=dc
            扩展虚拟机磁盘  309 查询行

            LANG=en growpart /dev/vda 1  ##扩展/dev/vda 的第一个分区空间
            lsblk
            blkid /dev/vda1
            xfs_growfs /dev/vda1###扩展/dev/vda1 文件系统
            df -h

 ####################################################################
rsync 同步操作
       同步与复制的差异:
            复制完全拷贝
            同步只有第一次是复制,之后时只修改 改变的部分
       什么是:
       用法: rsync [选项] 源目录 目标目录   ####将整个源目录中同步到目标文件夹
            rsync [选项] /源目录/ /目标目录/ ####将源目录中的 文件/文件夹 同步到 目标文件夹
            ##########################################
            eg:1
            [root@F /]# rsync -av /nsd01/ /nsd03/
            ./
            11
            aa
            bb
            #################################
            eg:2
            [root@F /]# touch /nsd03/aaaa
            [root@F /]# touch /nsd03/aa000
            [root@F /]# touch /nsd03/aa000
            [root@F /]# rsync -av --delete /nsd01/ nsd03/
            sending incremental file list
            deleting aaaa
            deleting aa000
            ./

            rsync指定端口 eg： rsync -e 'ssh -p 27076' xxxxx  user@hostIP:/url/
            rsync选项:
                  -r 递归 包括目录/子目录及其所有文件
                  -n 测试同步过程,不做实际修改
                  -l 保留符号链接文件
                  -a 归档模式 相当于 -rlptgoD
                  -v 显示详细的操作信息
                  -z 传输过程中启用压缩/解压缩  (5G以上) ####常用
                  -p -t 保留文件的权限 时间标记
                  -o -g 保留文件的属主 / 属组标记
                  -D 保留设备文件及其其他特殊文件
                  --delete 删除 目标目录中多余的部分
                  -av ####常用
                  -av --delete 同步过程中参考源文件地址且删除 目标目录中多余的部分  ####常用
                  -v, --verbose 详细模式输出。

                -q, --quiet 精简输出模式。
                -c, --checksum 打开校验开关，强制对文件传输进行校验。
                -a, --archive 归档模式，表示以递归方式传输文件，并保持所有文件属性，等于-rlptgoD。
                -r, --recursive 对子目录以递归模式处理。
                -R, --relative 使用相对路径信息。
                -b, --backup 创建备份，也就是对于目的已经存在有同样的文件名时，将老的文件重新命名为~filename。可以使用--suffix选项来指定不同的备份文件前缀。
                --backup-dir 将备份文件(如~filename)存放在在目录下。
                -suffix=SUFFIX 定义备份文件前缀。
                -u, --update 仅仅进行更新，也就是跳过所有已经存在于DST，并且文件时间晚于要备份的文件，不覆盖更新的文件。
                -l, --links 保留软链结。
                -L, --copy-links 想对待常规文件一样处理软链结。
                --copy-unsafe-links 仅仅拷贝指向SRC路径目录树以外的链结。
                --safe-links 忽略指向SRC路径目录树以外的链结。
                -H, --hard-links 保留硬链结。
                -p, --perms 保持文件权限。
                -o, --owner 保持文件属主信息。
                -g, --group 保持文件属组信息。
                -D, --devices 保持设备文件信息。
                -t, --times 保持文件时间信息。
                -S, --sparse 对稀疏文件进行特殊处理以节省DST的空间。
                -n, --dry-run现实哪些文件将被传输。
                -w, --whole-file 拷贝文件，不进行增量检测。
                -x, --one-file-system 不要跨越文件系统边界。
                -B, --block-size=SIZE 检验算法使用的块尺寸，默认是700字节。
                -e, --rsh=command 指定使用rsh、ssh方式进行数据同步。
                --rsync-path=PATH 指定远程服务器上的rsync命令所在路径信息。
                -C, --cvs-exclude 使用和CVS一样的方法自动忽略文件，用来排除那些不希望传输的文件。
                --existing 仅仅更新那些已经存在于DST的文件，而不备份那些新创建的文件。
                --delete 删除那些DST中SRC没有的文件。
                --delete-excluded 同样删除接收端那些被该选项指定排除的文件。
                --delete-after 传输结束以后再删除。
                --ignore-errors 及时出现IO错误也进行删除。
                --max-delete=NUM 最多删除NUM个文件。
                --partial 保留那些因故没有完全传输的文件，以是加快随后的再次传输。
                --force 强制删除目录，即使不为空。
                --numeric-ids 不将数字的用户和组id匹配为用户名和组名。
                --timeout=time ip超时时间，单位为秒。
                -I, --ignore-times 不跳过那些有同样的时间和长度的文件。
                --size-only 当决定是否要备份文件时，仅仅察看文件大小而不考虑文件时间。
                --modify-window=NUM 决定文件是否时间相同时使用的时间戳窗口，默认为0。
                -T --temp-dir=DIR 在DIR中创建临时文件。
                --compare-dest=DIR 同样比较DIR中的文件来决定是否需要备份。
                -P 等同于 --partial。
                --progress 显示备份过程。
                -z, --compress 对备份的文件在传输时进行压缩处理。
                --exclude=PATTERN 指定排除不需要传输的文件模式。
                --include=PATTERN 指定不排除而需要传输的文件模式。
                --exclude-from=FILE 排除FILE中指定模式的文件。
                --include-from=FILE 不排除FILE指定模式匹配的文件。
                --version 打印版本信息。
                --address 绑定到特定的地址。
                --config=FILE 指定其他的配置文件，不使用默认的rsyncd.conf文件。
                --port=PORT 指定其他的rsync服务端口。
                --blocking-io 对远程shell使用阻塞IO。
                -stats 给出某些文件的传输状态。
                --progress 在传输时现实传输过程。
                --log-format=formAT 指定日志文件格式。
                --password-file=FILE 从FILE中得到密码。
                --bwlimit=KBPS 限制I/O带宽，KBytes per second。
                -h, --help 显示帮助信息。
#####################################################
远程同步(rsync + ssh )
       虚拟机A目录/nsd1903 与虚拟机B 目录/opt
       rsync + ssh = rsync + scp
       远程的ssh目录保存同步
       下行:rsync [] user@host 远程目录 本地目录
       上行:rsync [] 本地目录 user@host:远程目录
       [root@F /]# rsync -av --delete /nsd01/ root@192.168.4.7:/opt/nsd/
################################################
实时同步
        虚拟机 A 目录 /nsd1903/  与 虚拟机 B 目录/nsd/ 实时同步
        rsync + scp
        scp 是需要密码的(需要验证)
            两种办法认证:
                密码
                公私钥
                公钥 : 锁子 私钥 : 钥匙
                拥有私钥的人可以访问拥有公钥的人 ##重要



            1)生成公私钥  ssh-keygen ###一路回车
                       /root/.ssh ###存放地点
                        id_rsa     ##私钥
                        id_rsa.pub ##公钥  公钥给比人 私钥 自己保留
                        know_host 曾经远程管理的每个机器的纪录

              keygen选项:
                            -b：指定密钥长度；
                            -e：读取openssh的私钥或者公钥文件；
                            -C：添加注释；
                            -f：指定用来保存密钥的文件名；
                            -i：读取未加密的ssh-v2兼容的私钥/公钥文件，然后在标准输出设备上显示openssh兼容的私钥/公钥；
                            -l：显示公钥文件的指纹数据；
                            -N：提供一个新密语；
                            -P：提供（旧）密语；
                            -q：静默模式；
                            -t：指定要创建的密钥类型。
            2) 将公钥传递给虚拟机B
                [root@svr7 .ssh]# ssh-copy-id root@192.168.4.207
                会要求输入密码 可能会将原本的
            3)authorized_keys 当公钥传递过来的时候会保存为 这个文件
            4)监控目录内容变化  使用  intoifywait 工具
                intoifywait [选项] 目标文件夹
                -r 递归监控 包含子目录和文件
                -m 持续监控 (捕获一个事件后不退出)
                -q 减少屏幕输出信息  qq 关闭输出信息
                -e 指定监视的 modify move create delete attribu 的事件
            5)编辑shell脚本 实现同步操作
                循环解决重复性操作
                for i in []
                do
                    命令
                done
                死循环:无限次的循环
                while [条件]
                do
                    重复执行的操作
                done


                [root@svr7 nsd1903]# vim /root/rsync.sh
                #!/bin/bash
                while inotifwait -rqq /nsd1903
                do
                 rsync -a --delete /nsd1903/ root@192.168.4.207:/opt/nsd
                done
                [root@svr7 nsd1903]#  /root/rsync.sh
                [root@svr7 nsd1903]# touch 1233
                [root@svr7 nsd1903]# touch 12
                [root@svr7 nsd1903]# touch 1000
                [root@svr7 nsd1903]# ls
                [root@B ~]# ls /opt/nsd/
                1000  12  1233

##################################################
源码的编译与安装 ###重要
        今天学校安装 封装 之后在学
            rpm包 rpm -ivh 或者 yum install
            源码包 gcc  make 开发工具 ---->可以执行的程序---->运行安装
        源码编译安装的优势:

        源码编译安装的过程:
            0.下载源码包
            0.1安装 gcc  make 开发工具
            1.tar解包,释放源代码到指定目录
            2../configure 配置,指定安装目录/功能模块
            3.make 编译,生成可以执行的二级制文件
            4.make install 安装,将编译好的文件复制到安装目录
###########################################################
        安装软件包  intoify-tools 工具 (这是个源码包需要编译)
        0.安装 gcc 和 make 开发工具(安装依赖关系的软件)
        1.在物理机上上传 intoify-tools tar 包 到虚拟机A/root中
            scp /intoify-tools.tar.gz root@192.168.4.7:/root
        2.在虚拟机上解压
            cp tools.tar.gz /opt/
            tar -xf tools.tar.gz
        3. ./configure 配置,指定安装目录,功能模块选择
            --prefix=指定安装位置   eg:--prefix=/opt/myapp
            eg:./configure --prefix=/opt/myapp
            ##检测系统是否安装gcc,检测系统是否可以支持编译安装
            [root@svr7 inotify-tools-3.13]# ./configure

        4.make 编译 生成可执行的二进制文件
            [root@svr7 inotify-tools-3.13]# make
        5.make install 安装,将编译好的文件复制到安装目录
            [root@svr7 inotify-tools-3.13]# make install
            [root@svr7 inotify-tools-3.13]# ls /usr/local/bin/inotifywait
            /usr/local/bin/inotifywait




还原命令： rht-vmctl reset  电脑名
虚拟机： classroom  server  desktop  win
GPL 协议 (开源协议)
    1.随便复制
    2.随便修改
    3.随便发布
    4.具有继承性

程序 硬盘
进程 内存 在进程中可以启动多个线程
线程   (共享内存)

后台执行
ctrl + z  将当前任务放在后台并暂停
命令 &　后台执行　　
jobs 查看有多少后台任务
fg  将一个在后台暂停的命令，变成在后台继续执行
bg　后台中的命令调至前台继续运行
nohup 关闭当前的终端也执行（之前的&做不到）需要注意的试试nohub没有 后台的意思,所以要配合 & 来完成后台运行
eg:nohup COMMAND &
####################
debin       Redhat
dpkg        rpm
apt-get     yum
##################
配置ubuntu的 apt-get


/etc/apt/sources.list   //存放地址列表的配置文件
deb [web或ftp地址] [发行版名字] [main/contrib/non-free]
    deb http://archive.ubuntu.com/ubuntu/ bionic main restricted
    deb-src http://archive.ubuntu.com/ubuntu/ bionic main restricted

apt-get update 更新镜像
apt-get upgrande 更新软件
apt-get install package  安装软件
apt-get remove package  卸载软件(不删除配置文件)
apt-get purge package  卸载软件(删除配置文件)

###########################################
dpkg -i packagename  //安装
dpkg -r packagename  //卸载
dpkg -L packagename = rpm -ql  //列出软件包的详细详细
dpkg -l packagename = rpm -qa  //列出所有软件包
dpkg -S packagename  = rpm -qf /usr/bin/vim//验证文件所属的软件包

##########################################
rpm -qa 软件名 查询该软件是否已经安装
		rpm -qf /usr/bin/mail  //查询文件所属软件 和 yum provides 作用相同
		rpm -ivh 软件名-版本信息.rpm..   ###安装 只有在安装的时候才需要完整的路径和包名
		rpm -e --nodeps 软件名          ###卸载软件,忽略依赖关系 也会删除配置文件
		rpm -qc 软件名                  ###查找软件生成的配置文件位置
		rpm -ql 软件名                  ###查看安装软件安装位置
		yum provides /etc/hosts        ###查询某个文件所属的软件
		rpm -qf                        ###查询/验证文件属于的软件包
        rpm --import name              ###解决签名
####################
w命令查看上次服务器启动时间
    [student@room9pc01 ~]$ w
     18:03:20 up  9:14,  3 users,  load average: 0.56, 0.35, 0.27
    USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
    student  :0       :0               08:49   ?xdm?   1:03m  0.32s /usr/libexec/gnome-session-binary --session gno
    student  pts/1    :0               17:19   16.00s  0.06s  0.04s ssh root@139.9.210.20
    student  pts/2    :0               17:21    0.00s  0.04s  0.00s w

last命令 查看登录
    student  pts/7        :0               Wed Jul 10 19:07 - 19:17  (00:10)
    student  pts/7        :0               Wed Jul 10 17:09 - 17:09  (00:00)
    student  pts/6        :0               Wed Jul 10 14:33 - 19:09  (04:35)
    student  pts/3        :0               Wed Jul 10 10:18 - 19:09  (08:51)
############################
RHEL6/7

6和7的不同:
服务启动 服务自启 运行状态切换

rhel 6
系统服务管理
    /etc/init.d/ 脚本目录
    /etc/init.d/name state
    /etc/init.d/name status
    /etc/init.d/name stop
    /etc/init.d/name restart
    /etc/init.d/name reload
服务自启
    chkconfig --list [name]  //查看服务自启状态(不设置运行级别,默认为全部级别)
    chkconfig --list   //查看所有进程自启状态
    chkconfig [--level 级别列表] 服务名 on  //开机自启 --leave 指定运行级别,不加默认全部
    chkconfig [--level 级别列表] 服务名 off
系统运行状态
    6和7 相同
    0-6 7个状态
    0 关机状态
    6 重启状态
    init3/5 3命令行多用户,5图形多用户
    1 单用户
    2 多用户模式，没有NFS网络支持。
    3 完整的多用户文本模式，有NFS，登陆后进入控制台命令行模式。
    4 系统未使用，保留一般不用，在一些特殊情况下可以用它来做一些事情。例如在笔记本电脑的电池用尽时，可以切换到这个模式来做一些设置。
    init 3 //切换到运行级别3

rhel7

服务状态
    systemctl -t service //查看当前所有启动服务
    systemctl -t service --all //查看当前所有服务(包括未启动的)
当前系统运行级别
    runlevel
    列出当前可以切换的运行级别
    systemctl -t target
    切换运行级别
    systemctl isolate 状态
    查看默认运行级别
    systemctl get-default
    设置默认运行级别
    systemctl set-default 状态
##########################################
linux系统启动中init 程序的作用
    linux系统和服务管理器
        -内核引导后加载的第一个初始化进程(PID=1)
        -负责掌握整个linux的运行/服务资源组合
    传统的init程序
        systmev 顺序加载
    systemd
        一个更加高效的系统&服务管理器
        开机启动服务,并启动各个系统服务间的精确依赖
        配置目录: /etc/systemd/system/
        服务目录: /lib/systemd/system/
        主要管理工具: systemctl


##########################################
Linux文件目录
/ 根  
/etc 存放系统配置文件（删掉的话无法正常启动）
/bin 系统程序文件
/boot 启动所需的文件
/dev 分区信息
/home 普通用户的家目录
/root 管理员的家目录（~）
/var 系统中大小经常变化的文件 比如 log
/
/opt 软件安装位置
Unix&Linux一切皆文件  
路径 /abc/nsd/1.txt
开头的 /是根目录 其他的/ 均为分隔符

/dev/
存放设备(硬盘\键盘\鼠标\显示器)相关数据的地方
/root :Linux中管理员的家目录
/home: 存放所有普通用户家目录  (他本身不是所有用户的家)
 / 表示 根 
 ~ 表示家目录 
 . 表示当前目录  常常与复制命令连用 
 ..表示父目录
Linux目录结构:树形结构   
最顶层为根目录
根目录   (/) 

                                                       /
bin       boot      dev      etc     home     root      run      sbin      tmp        usr          	 var
                                                  |                                                              |               	  | 
                                                  |                                                              |                	  | 
                                                  |                                                              |                 	  | 
                                          -----------------------------                                     ---------------------------------------         --------
                                | alice  bob  eve|                           | bin local  sbin  tmp|      |tmp|


##############################################

终端中颜色:
黑色表示 文件
蓝色表示目录
绿色:可以执行的文件 
青色:文件

man 外部命令
help 内部命令
命令一般分为内部命令和外部命令

内部命令: 集成在shell 中,根据shell种类不同所以 内部命令有时候也不同
enable 查看内部命令
enable -n 命令 //关闭内部命令


外部命令: 额外安装的命令,一般可以找到对应的 文件

hash
系统初始hash表我空 ,执行外部命令时会将命令读取到hash表中,
通过shell执行外部命令时会首先查找hash表中,若表中没有则根据path查找.
可以大大提高外部命令的执行速度.

Linux中表示上一级目录
cd ..
相当于Windows中的   后退 返回上一级

如何编写命令行

在Linux中执行命令,都要找到相应的程序,将程序运行

命令的执行依赖于解释器	 比如 /bin/bash
命令的执行依赖于解释器  默认的/bin/bash
内核: 调配计算机硬件资源 
用户的指令--------> 内核---------> 调配计算机硬件

Linux 命令分类 
	内部命令 属于解释器的一部分
	外部命令 解释器之外的其他程序
命令行的完整格式 
 基本用法  
 -命令字 [选项]... [参数1]  [参数2] ...
  cat /etc/redhat-release
  head -1 /etc/password
  cat ls 是不能直接查看设备文件的  
查看命令的帮助信息 
  word --help
  man word
选项,调控命令的执行方式
  短选项: -A -I -c -d
  多个短选项选项-------->复合选项 -IH 
  长选项  --help
###################################################
ftp://176.233.40.248/
账户 nsd1903	
     20190329


Unix&Linux一切皆文件  
路径 /abc/nsd/1.txt
开头的 /是根目录 其他的/ 均为分隔符

/dev/
存放设备(硬盘\键盘\鼠标\显示器)相关数据的地方


#########################################################################################
Linux磁盘表示  (面试题目常考)
命名规则
       				 /dev/sda
					  |      |		
 					 |     |           a 表示第一块磁盘  b表示第二块 以此类推  
        			      所在目录  sd:表示scsi 设备
                                      vd:表示虚拟设备
						 id:表示ide设备    
/dev/sda  scsi的第一块磁盘
/dev/sdb   第二块
/dev/sdc   第三块

切换到控制界面 
Ctrl+alt+Fn  
         F4  字符控制台
         F1  图形化界面

命令行提示符的意义:
[ root @ localhost  ~  ]#
  登录的账户 主机名      代表当前工作目录    表示当前登录的用户为root 管理员 普通的账户为$     
					[root@localhost ~]# pwd
					/root
					[gaoyuan@localhost ~]$ pwd
					/home/gaoyuan


ctrl+shift+ + 加大字体
ctrl +  -   缩小字体
使用&来连接两条命令 
[root@localhost ~]# cd 桌面&ls
[1] 22503
anaconda-ks.cfg       公共  视频  文档  音乐
initial-setup-ks.cfg  模板  图片  下载  桌面
[1]+  完成                  cd 桌面
ls -l 详解
文件的详细属性
    d  目录文件    -  普通文件      l  链接文件

    权限  ：  r  读    w  写   x 执行权限 
     属主    属组    其他人  
     rwx     r--      r-x
 	-a 列出所有文件，包括以 "." 开头的隐含文件。	
	-d 将目录名像其他文件一样列出 而不是列出他的内容..##只列出目录名
	-h 显示常用的单位 提供易读的单位
      -lh 显示详细属性时 加上单位大小   
	-A 显示目录全部内容,包括隐藏数据 .显示除 "." 和 ".." 外的所有文件。 后期写脚本的时候会常用-A ,-a由于显示 . ..会比较难匹配所以,不会用-a.
	-l 长格式显示
tab键 
       1. 按一次，补全命令或者路径
       2. 按两次，下来菜单，照着找
       3. 按一次，检查这个文件有没有

mkdir  文件夹 目录
       mkdir  -p  a/aa/aaa  #通过 -p参数来递归创建文件夹
touch   文件                #TOUCH 可以支持多个 选项 用来同时创建 文件
       touch 1.txt
       touch /root/1.txt /root/2.txt	
mv  移动
    格式：  mv  源文件   目的位置
    1.mv  可以移动文件
    2.mv  可以移动文件的同时改名
    3.mv  可以直接重命名（移动到当前路径下）  
移动时修改文件名
[root@room9pc01 ~]# ls
123456789        besic02               nu.txt           秋名山.txt  下载
a                bin                   original-ks.cfg  视频        音乐
anaconda-ks.cfg  initial-setup-ks.cfg  公共             图片        桌面
b                ll                    模板             文档
[root@room9pc01 ~]# mv 123456789 ll/sbc
[root@room9pc01 ~]# cd ll
[root@room9pc01 ll]# ls
1.txt  456.txt  sbc


    调去上一条命令的执行参数路径  esc+.   alt+.
cp 复制
   格式：  cp  源文件  目的位置
           1. 拷贝的过程中叶可以改名字  cp 1.txt /2.txt
           2. 拷贝文件夹需要加参数  -a
           3. 与mv的区别是一个源文件还在，一个不在。


   选项     -r 递归复制  递归地复制目录
            -p  保持原始文件的所有者，组，许可，和时间表属性。
            -a 复制时,尽可能保持文件的结构和属性.(但不保持目录结构)
练习：
      1.在自己家里创建一个a文件夹，在里面创建1.txt 2.txt 3.txt
            
         cd    mkdir a  cd a  touch 1.txt 2.txt 3.txt
      2. 移动题一中的3.txt 到/下，并且改名字为4.txt
             mv 3.txt /4.txt
      3. 在自己家里创建一个b文件夹，b文件夹中创建一个b文件，拷贝这个b文件到/tmp/b/bb/bbb中。
           mkdir b  cd b  touch b
           mkdir -p /tmp/b/bb/bbb
           cp b /tmp/b/bb/bbb


      4.在题3的bbb文件夹中，创建c.txt d.txt .然后把c.txt重命名为v.txt
         alt + .    cd  /tmp/b/bb/bbb   touch c.txt d.txt
            mv c.txt v.txt
#############################
鼠标

选中为复制   只在终端下有用  适用于所有的 linux系统 
滚轮 粘贴
rth- vmctl 命令名  虚拟机名
优先开启 classroom ###why? 提供服务啊 
rht-vmctl reset classroom   提供网关/dns/软件资源          172.25.0.255 
rht-vmctl reset server      作为练习服务器                     172.25.0.11   ID ROOT PASSWD redhat
rht-vmctl reset desktop     作为练习的客户机                  172.25.0.10  ID ROOT PASSWD redhat
子网划分 节约ipv4 地址
b类地址 + d 类子网掩码
ctlr+alt+f2 切换到字符模式

ctlr+alt+f1 回到gui模式
 ctrl + l 清屏
 ctrl + c 放弃当前命令行/ 结束当前命令行
 esc + . 或者alt + . 粘贴上个命令行的参数
 ctrl + u 清空至行首 
 ctrl + k 清空至行尾
 ctrl + w  往回删除一个单侧 (以空格界定)
 ctrl + d  相当于exit
##########################
通配符
* 任意多个任意字符 
? 只配一个,且必须要有
[a-b] 多个字符或连续范围中的一个
{a,b,c} 多组不同的字符串,全匹配
ls /etc/r*.conf 
以r开头,conf 结尾 
	[root@jkgao ~]# ls /etc/r*.conf
	/etc/radvd.conf        /etc/resolv.conf 
ls /etc/*abc*
只要包含abc  
ls /dev/tty??
tty结尾 必须要有两位 
	[root@jkgao ~]# ls /dev/tty??
	/dev/tty10  /dev/tty20
#########################
	[root@jkgao ~]# ls /dev/tty[1-8]
	/dev/tty1  /dev/tty3  /dev/tty5  /dev/tty7
	/dev/tty2  /dev/tty4  /dev/tty6  /dev/tty8
	[root@jkgao ~]# ls /dev/tty[1-11]    #############################3这里为什么不显示 大于十的部分能 因为Linux只定义了10 一下的
	/dev/tty1
	[root@jkgao ~]# ls /dev/tty[3-6]
	/dev/tty3  /dev/tty4  /dev/tty5  /dev/tty6
	[root@jkgao ~]# ls /dev/tty{1,3,5,8,9}
	/dev/tty1  /dev/tty3  /dev/tty5  /dev/tty8  /dev/tty9
	[root@jkgao ~]# ls /dev/tty{[1-5],[6-8]}
	/dev/tty1  /dev/tty3  /dev/tty5  /dev/tty7
	/dev/tty2  /dev/tty4  /dev/tty6  /dev/tty8
#################################################
eg
	touch 1.txt 12.txt 13.txt 123.txt 456.txt
	[root@room9pc01 ll]# ls
	123.txt  12.txt  13.txt  1.txt  456.txt
	[root@room9pc01 ll]# rm -rf 1?.txt
	[root@room9pc01 ll]# ls
	123.txt  1.txt  456.txt
	[root@room9pc01 ll]# touch 145.txt
	[root@room9pc01 ll]# ls
	123.txt  145.txt  1.txt  456.txt
? 配一位
* 全部
##########################################

cat head tail   

cat -n //  ;查看文件 显示行号:
head -n //  ;查看文件 前几行 
tail -n //   ;查看文件 尾部 几行  n表示 你要显示几行#####默认 显示前10行 tail 同上
############################################
grep 关键字 目的文件  ；
grep root  /etc/passwd
root:x:0:0:root:/root:/bin/bash
operator:x:11:0:operator:/root:/sbin/nologin

grep -v ^$ /etc/chrony.conf  -v 取反 

grep ^$ /etc/passwd	^$ 匹配空行
grep ^root /etc/passwd  ^匹配 root 开头的 
grep login$ /etc/passwd |tail -4   ;  $匹配 以 login 结尾,且之显示四行
#########################################################
管道 |   将上一条命令执行的结果交给下一条命令执行  类似于桥梁的作用 没有数量限制 ###重要
eg：
cat /etc/passwd | grep root

root:x:0:0:root:/root:/bin/bash
operator:x:11:0:operator:/root:/sbin/nologin

cat /etc/passwd | wc -l 计数 
42

cat -n /etc/passwd | head -15 |tail -6   带行号输出
    10	operator:x:11:0:operator:/root:/sbin/nologin
    11	games:x:12:100:games:/usr/games:/sbin/nologin
    12	ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin
    13	nobody:x:99:99:Nobody:/:/sbin/nologin
    14	systemd-network:x:192:192:systemd Network Management:/:/sbin/nologin
    15	dbus:x:81:81:System message bus:/:/sbin/nologin

cat -n /etc/passwd | head -15 |tail -6 |wc -l  配合计数使用  ###cat -n 显示行号
6
##################################################################3
重定向
     前边命令的输出 写入到指定文本文件中,若指定文本文件不存在会自动创建
    
>    覆盖重定向  直接覆盖原文件

[root@room9pc01 home]# echo 123 > 1.txt
[root@room9pc01 home]# cat 1.txt 
123
[root@room9pc01 home]# echo 456 > 1.txt
[root@room9pc01 home]# cat 1.txt 
456

>>  追加重定向    保留源文件 在最后追加

[root@room9pc01 home]# echo 123 >>1.txt
[root@room9pc01 home]# cat 1.txt 
456
123
[root@room9pc01 home]# echo 789 >>1.txt
[root@room9pc01 home]# cat 1.txt 
456
123
789
############################################
echo  复读机 只会显示 echo后面输入的字符 
	配合重定向 快速修改 文件信息
	[root@jkgao gaoyuan]# echo lolo > /opt/hn.txt 
	[root@jkgao gaoyuan]# cat /opt/hn.txt
	lolo

	[root@jkgao gaoyuan]# echo lolo
	lolo
    [student@room9pc01 linux-]$ echo -e "123\n321" #换行输出   -e 允许对下面列出的加反斜线转义的字符进行解释
	123
    321
    [student@room9pc01 linux-]$ echo -e "123\t321" #加入tab
    123     321

    字符串切割
    需要注意的是这里与python中的列表的字符串切割是不同的,py_str[2:4] ###包含起始下标的字符,不包含结束下标的字符
    而shell是需要
    [student@room9pc01 HTML---temporal]$ pwd
    /home/student/HTML---temporal
                                                   开头 结束
    [student@room9pc01 HTML---temporal]$ echo ${PWD:(-6):6} //-6 表示从倒数第六个字符开始,6 表示开始后有几个字符
    mporal

#####################
vim编辑器

vim 命令模式下 
dd剪切(可以当删除使用)  用p可以粘贴出来
yy复制(光标放在行首)  5yy复制五行
p粘贴 
vim 命令模式进入插入模式 可以按 o 另起新的一行


命令模式 	批量操作，复制粘贴    i 进入插入模式 esc 推出 进入命令模式； 按两次 esc 进入 末行模式 wq 退出 q！推出不保存 ！强制执行
					从光标位置开始往下操作，
	命令模式下执行			复制      数字+yy  光标下几行需要复制，不是复制多少行
					粘贴      p
					删除      数字+dd  删除了数字行
					全文查找 /关键字  
					撤销     u
					反撤销   ctrl+r
					退出保存 shift+zz
					跳最后一行 shift + g
插入模式 	写入文档
末行模式 	保存退出  wq 退出保存 q！退出不保存 
set nu 显示行数 
：6 快速移动到某一行  移动到第6行
                    查找替换(常用)
                    :s
                    :s/vivian/sky ###替换当前行第一个vivian 为 sky
                    :s/vivian/sky/g ###替换当前行所有vivian 为 sky
                    :n,$s/vivian/sky ###替换第n行到最后一行的每一行的第一个vivian 为 sky
                    :n,$s/vivian/sky/g ###替换第n行到最后一行的每一行的每一个vivian 为 sky
                    一般来说 n 为数字 ,当 n 的值为 '.' 时 从当前行,到最后一行
                    将文件直接导入本文件
                    :r  文件路径   #############注意光标的位置,会直接将文件放在光标之后 导入文件
#####################################################
远程控制
teamviewer
win  cmd 命令
mstwc
跨平台 win +linux
tigervnc
xshell

ssh -X root@server0.example.com  :-X 调用图形界面 ##server0.example.com 域名
#########################################################
tar 打包压缩
linux 压缩格式:
	gzip(特点速度快,效率底) -----------> .gz
	bzip2---------------------------> .bz2
	xz(特点速度慢,效率高,)---------------> .xz
选项 
	-c 创建归档
	-x 释放归档
	-f 指定tar包的文件名
	-z -j -J  分别调用.gz .bz2 .xz 格式工具进行处理
	-t 显示归档中的文件清单
	-C 指定路径释放
	-v 解压时显示过程
	-P （大写） ：保留绝对路径，亦即允许备份数据中含有根目录存在之意
	-p （小写） ：保留备份数据的原本权限与属性，常用于备份（-c） 重要的配置文件
	    如果你需要将备份文件还原至本来目录时，需要加-P参数，如果只是备份，还原时不用替换原来文件时，不需要加
注意 连用时f一定要写在所有选项之后
tar 所有选项都需要有 f 选项
显示
打包
      选项  /路径/新包的名字     
tar -zcf  xxx.tar.gz    需要打包的文件名 #######
tar -jcf  xxx.tar.bz2    需要打包的文件名 #######
tar -Jcf  xxx.tar.xz    需要打包的文件名 #######
解压
          需要解压包得名字
tar -xf xxx.tar.gz 解压到当前位置
tar -xf xxx.tar.gz -C /指定解压缩位置  大写C 小写识别
##################################
分号  ;
命令 接着执行 多条命令 
eg mkdir pp ; touch xixi
#####################
管理用户和组
用户	1.登录操作系统	
	2.方便对不同用户进行访问控制
组      方便管理用户
用户唯一标识: UID  从0 开始的
组唯一标识: GID  从0 开始
Linux系统管理的uid 永远为0 
	[root@jkgao gaoyuan]# id root
	uid=0(root) gid=0(root) 组=0(root)
创建普通用户

useradd 用户名
useradd 选项 用户名
常用的选项  
-u用户id  指定uid (uid有极限)
	新用户uid默认上个用户uid+1
-d 家目录路径  指定家目录默认在/home/下 
	[root@jkgao gaoyuan]# useradd -d /mnt/nsd01 nsd01
						   家目录	用户名
-s登录解释器 
	[root@jkgao gaoyuan]# useradd -s /sbin/nologin haha
	[root@jkgao gaoyuan]# grep haha /etc/passwd 
	haha:x:1002:1002::/home/haha:/sbin/nologin

查看解释器
[root@jkgao gaoyuan]# cat /etc/shells 
				/sbin/nologin #禁止用户登录系统,非删除用户
-G 附加组
1.查看用户基本信息 id  id 用户名  
	[root@room9pc01 home]# id Student
	uid=1000(Student) gid=1000(Student) 组=1000(Student)
2.查home ls /home/

	
3.查文件   grep nsd01 /etc/passwd
用户的基本信息存放在  /etc/passwd 
/etc/passwd	属于系统级 配置文件 
	root:	x	 :0		:0:		root:			/root:	/bin/bash
       用户名 密码占位符 用户的UID	基本组的GID   用户描述信息可以为空   家目录         解释器
#############
删除用户 
	
userdel 用户名
userdel -r 用户名 #连通用户的的家目录一起删了(工作中尽量不会用这命令)
1.删除家 rm -rf /home/xixi
2.       vim
切换 用户 
su 用户名
su -c 传递command 给shell
              -c, --commmand=COMMAND
              传递单个COMMAND给-c的shell.
eg: su -c "/usr/local/tomcat/bin/startup.sh"  tomcat  //让 startup.sh 由  Tomcat执行
##############################################
删除
	rm- Remove   删了 真的就没了
格式 rm [选项]  文件/目录
常用选项 -r 递归删除 ,目录以及目录下所有
       -f 强制删除 
	 -i 提示信息 
###################################################
创建组 
基本组:与用户同名且由系统创建并将用户默认添加到该组(为了满足Linux默认的用户只属于一个组)
附加组(从属组): 由管理员创建并管理 
groupadd xixi
groupdel xixi
思路:创建组 创建用户时指定附加组

	[root@jkgao gaoyuan]# groupadd tarena #创建组
	[root@jkgao gaoyuan]# useradd -G tarena nsd03 #指定组并创建用户nsd03
	[root@jkgao gaoyuan]# id nsd03
	uid=1003(nsd03) gid=1004(nsd03) 组=1004(nsd03),1003(tarena)  
		用户id		基本组id	     附加组id
#########################################
管理组
存在组基本信息的文件 /etc/group 文件
由于没有直接查看组命令 所以使用grep查看
[root@jkgao gaoyuan]# grep stugrp /etc/group
stugrp:x:1005:
组名:密码占位符:组的成员列表
groupadd 组名
属性
-g  
groupadd [-g] 组名 
##################################3
管理组成员
gpasswd   
gpasswd -a 用户名 组名 添加
gpasswd -d 用户名 组名  删除

#############################################
删除组 
groupdel
groupdel 组名
不能删除住组 附属组可以删除
删除组不影响 用户存在
####################################
设置密码
 passwd 用户名
输入密码 两次
[root@jkgao gaoyuan]# passwd nsd03
更改用户 nsd03 的密码 。
新的 密码：
root用户在执行时 不需要 输入原密码 ,且设置的密码不需要符合密码字典的要求
普通用户可以修改自己的密码 并且密码必须符合密码字典的要求,
普通用户是无法修改与自己平级账户的密码的
 su - nsd03 
非交互式设置密码
必须 root 用户执行这条命令
echo 123 | passwd --stdin nsd03 (--stdin 取消passwd的交互功能##echo 之后为密码)
##########################################
登录密码 保存文件 
默认 root 才有权限阅读
/etc/shadow  系统文件
	(了解)
	[root@jkgao gaoyuan]# head -1 /etc/shadow
	root:$6$N2mU7M8m$mBO2wcqpI09Y/KlVTsIZJonkqKp948r/AyA9JUf0CoVE7GdPBZf5xyThSR40Pcwq6M8muh3n.Y/Xld0LCBZce.:17988:0:99999:7:::
	用户  :     密码加密字符串                                  : 上次修改密码的时间,从1970-1-1到修改密码的时间的天数: 密码可存在的天数:提前7天警告密码快失效了:用户永远不过期
修改用户属性 (只能修改已存在)
usermod 
选项  和 useradd 相同
-u 修改uid
-G 修改附属组
-d 修改家目录
-s 修改解释器
-g 指定用户的初始用户组, 该组必须存在
[root@jkgao gaoyuan]# usermod -u 1700 -G tarena -s /sbin/nologin nsd11
                              -u 指定uid  -G 指定附属组  -s 指定家目录  nsd11 为目标用户

###########################
命令别名 （临时别名）
alias
 别名=‘实际执行的命令’
别名定义 
	alias if="ifconfig"
	alias ho="hostname"
查看别名 alias 
取消别名 unalias
############################################################

###############################永久别名
配置用户环境
 开启新终端后生效
  影响指定用户的bash 解释器
  ~ /.bashrc,每次开启bash 终端生效 ####注意这是一个隐藏文件
  [root@server0 ~]# vim /root/.bashrc 修改root 用户的
  [student@gao ~]$ vim /home/student/.bashrc   $####修改用户studen 的bash .添加别名
	  alias gos='ssh -X root@172.25.0.11'
	#mount | grep qemu &> /dev/null
	alias god='ssh -X root@172.25.0.10'

  影响所有用户的 bash 解释器
  [root@server0 ~]# vim /etc/bashrc
###################################

cp复制 
	cp 选项 源文件
	cp可以支持两个以上的参数,永远会把最后一个参数作为目标其他所有参数都会作为源.也就是他会把 前边的所有文档\目录 拷贝到最后一个文件夹
常用选项 
	-r 递归,复制目录以及目录下文件时 需要添加  #重要,比较常用
	-i 提示信息   由于 系统已经自定义了系统级别的别名 ,所以在覆盖文件的时候会不断提示
	-p 保持源文件的属性不变 复制 (属主 属组 权限  )
	[root@jkgao 桌面]# alias
	alias cp='cp -i'
	但是我们可以使用 \ 可以在本次 命令中临时取消 别名 
	[root@jkgao 桌面]# \cp -r /boot/ /桌面
	复制时可以重新命名目标路径下的名称
	eg:
	[root@jkgao nsd01]# cp /etc/passwd ./nsd
	[root@jkgao nsd01]# ls
	0  nsd  passwd
	[root@jkgao nsd01]# 
	#######  ########提问这两次 cp操作有什么不同
	[root@jkgao nsd01]# rm -rf /opt/*
	[root@jkgao nsd01]# cp -r /home/ /opt/test  ########本次复制home到opt 并改名为 test######opt中为空
	[root@jkgao nsd01]# cp -r /home/ /opt/test  ########本次复制home到opt/test中 ##########这次opt中已经有了名为test的文件夹
	[root@jkgao nsd01]# ls
	[root@jkgao nsd01]# ls /opt/
	test
	[root@jkgao nsd01]# ls /opt/test/
	2  gaoyuan  home
	[root@jkgao nsd01]# 

####################################
 . 表示当前目录  常常与复制命令连用 
 ..表示当前目录的父目录
eg:
	[root@jkgao opt]# cd nsd01/0/
	[root@jkgao 0]# ls
	[root@jkgao 0]# cp -r /etc/passwd .
	[root@jkgao 0]# cp -r /etc/passwd ..
	[root@jkgao 0]# ls
	passwd
	[root@jkgao 0]# cd ..
	[root@jkgao nsd01]# ls
	0  passwd
##############################################################
破解用户密码（rhce考试第一步）
1.
重启系统 在系统启动过程中内核选择部分 按 E  进入单用户模式
2.
找到Linux 16 的一行 在末端输入 rd.break console=tty00
3. Ctrl+x 
4.  输入
    　　　　　　重新挂载赋予读写权限　
　　mount -o remount,rw /sysroot   （挂载sysroot 给予 、读写权限）
    chroot /sysroot/  （选择root账户）
    passwd root （修改密码）
    输入新密码 （密码强度不够的话需要输入两次）
    touch /.autorelabel (跳过内核检查和ＳＥＬｉｎｕｘ相关)
    exit
    reboot  
#####################################################################################
远程传输文件  
scp 文件 root@对方ip ：存放位置
scp ‘/root/桌面/dachui.txt/’root@172.168.5.45:/root/桌面
推荐使用rsync
rsync 文件 root@对方ip ：存放位置    -pgo 保持文件权限，保持用户主，保持用户组 不变
rsync /etc/yum.repos.d/local.repo root@$i:/etc/yum.repos.d/local.repo
        -avSXH
-v, --verbose 详细模式输出
-q, --quiet 精简输出模式
-c, --checksum 打开校验开关，强制对文件传输进行校验
-a, --archive 归档模式，表示以递归方式传输文件，并保持所有文件属性，等于-rlptgoD
-r, --recursive 对子目录以递归模式处理
-R, --relative 使用相对路径信息
-b, --backup 创建备份，也就是对于目的已经存在有同样的文件名时，将老的文件重新命名为~filename。可以使用--suffix选项来指定不同的备份文件前缀。
--backup-dir 将备份文件(如~filename)存放在在目录下。
-suffix=SUFFIX 定义备份文件前缀
-u, --update 仅仅进行更新，也就是跳过所有已经存在于DST，并且文件时间晚于要备份的文件。(不覆盖更新的文件)
-l, --links 保留软链结
-L, --copy-links 想对待常规文件一样处理软链结
--copy-unsafe-links 仅仅拷贝指向SRC路径目录树以外的链结
--safe-links 忽略指向SRC路径目录树以外的链结
-H, --hard-links 保留硬链结
-p, --perms 保持文件权限
-o, --owner 保持文件属主信息
-g, --group 保持文件属组信息
-D, --devices 保持设备文件信息
-t, --times 保持文件时间信息
-S, --sparse 对稀疏文件进行特殊处理以节省DST的空间
-n, --dry-run现实哪些文件将被传输
-W, --whole-file 拷贝文件，不进行增量检测
-x, --one-file-system 不要跨越文件系统边界
-B, --block-size=SIZE 检验算法使用的块尺寸，默认是700字节
-e, --rsh=COMMAND 指定使用rsh、ssh方式进行数据同步
--rsync-path=PATH 指定远程服务器上的rsync命令所在路径信息
-C, --cvs-exclude 使用和CVS一样的方法自动忽略文件，用来排除那些不希望传输的文件
--existing 仅仅更新那些已经存在于DST的文件，而不备份那些新创建的文件
--delete 删除那些DST中SRC没有的文件
--delete-excluded 同样删除接收端那些被该选项指定排除的文件
--delete-after 传输结束以后再删除
--ignore-errors 及时出现IO错误也进行删除
--max-delete=NUM 最多删除NUM个文件
--partial 保留那些因故没有完全传输的文件，以是加快随后的再次传输
--force 强制删除目录，即使不为空
--numeric-ids 不将数字的用户和组ID匹配为用户名和组名
--timeout=TIME IP超时时间，单位为秒
-I, --ignore-times 不跳过那些有同样的时间和长度的文件
--size-only 当决定是否要备份文件时，仅仅察看文件大小而不考虑文件时间
--modify-window=NUM 决定文件是否时间相同时使用的时间戳窗口，默认为0
-T --temp-dir=DIR 在DIR中创建临时文件
--compare-dest=DIR 同样比较DIR中的文件来决定是否需要备份
-P 等同于 --partial
--progress 显示备份过程
-z, --compress 对备份的文件在传输时进行压缩处理
--exclude=PATTERN 指定排除不需要传输的文件模式
--include=PATTERN 指定不排除而需要传输的文件模式
--exclude-from=FILE 排除FILE中指定模式的文件
--include-from=FILE 不排除FILE指定模式匹配的文件
--version 打印版本信息
--address 绑定到特定的地址
--config=FILE 指定其他的配置文件，不使用默认的rsyncd.conf文件
--port=PORT 指定其他的rsync服务端口
--blocking-io 对远程shell使用阻塞IO
-stats 给出某些文件的传输状态
--progress 在传输时现实传输过程
--log-format=formAT 指定日志文件格式
--password-file=FILE 从FILE中得到密码
--bwlimit=KBPS 限制I/O带宽，KBytes per second
-h, --help 显示帮助信息
###########################################################################################
远程链接  ssh -X root@ip地址 														
-X 表示显示图形化界面
find 在文件夹中查找文件
grep 在文件中查找内容
####################################################################################################
desktop IP 172.25.0.10 
server ip 172.25.0.11 
linux 中 加上文件的属性(.txt)是不影响文件的读取的,加后缀是为了给人看.


####################################################################################
AB两个机器的免密码登录 
原理: 
将A机器的公钥发送到B机器,B机器ssh登录A机器的时候就不需要 输入密码
将B机器的公钥发送到A机器,A机器ssh登录B机器的时候就不需要 输入密码
https://blog.csdn.net/u013948858/article/details/78252409
ssh-copy-id IP (传输公钥到制定的 ip)
-i 指定公钥文件
若命令执行失败,提示被拒绝去请检查权限
.ssh目录，以及/home/ 当前用户 需要700权限
.ssh目录下的authorized_keys文件需要600或644权限
###############################################################
ssh-keygen 产生 公钥和私钥

-b：指定密钥长度；
-e：读取openssh的私钥或者公钥文件；
-C：添加注释；
-f：指定用来保存密钥的文件名；
-i：读取未加密的ssh-v2兼容的私钥/公钥文件，然后在标准输出设备上显示openssh兼容的私钥/公钥；
-l：显示公钥文件的指纹数据；
-N：提供一个新密语；
-P：提供（旧）密语；
-q：静默模式；
-t：指定要创建的密钥类型。

产生  id_rsa
ssh-keygen -f /root/.ssh/id_rsa -N ''
SSH 安全外壳协议 :在不安全的网络中提供安全远程登录以及其他安全网络   的协议
ssh配置文件:  	
ssh远程链接的配置文件 文件位置   sshd_config
cd /etc/ssh/

port 22: 默认使用22端口作为ssh的服务端口
Hostkey:存放私人秘钥文件
LoginGraceTime :若链接失败切断链接的等待时间
PermitRootLogin yes 用于root登录 yes (以后一定要修改为 no 不允许root登录)
PermitEmptyPasswords no  允许空密码登录 默认关闭 但是这个一定要设定为 开 也就是属性设置为 no
/root/.ssh/  know hosts 记录主机的登录相信
                 authrized
ssh-copy-id ip 将公钥发送到 对应的 IP上
更改了 配置文件后一定要重启服务

公钥和私钥的存储位置 
cd /root/.ssh
authorized_keys  id_rsa  id_rsa.pub 		 known_hosts
   公钥                     自己 公钥         已经链接过的ip的访问方式
#######################################################################################################

服务器架构
一.C/S client&server 架构
--由服务器提供资源或某种功能
--客户机使用资源或功能

TCP/IP 协议
最广泛支持的通信协议集合
--包含大量的Internet应用中的表中协议
--支持跨网络架构\和操作系统

主机间通信的三要素   ip mac 端口号
-ip地址 ipaddress   :唯一表示网络中一个节点的地址(只要能连网的设备我们都可以称之为节点)
	 地址组成(点分十进制)
	 一共32个二进制数
	eg : 为win2008虚拟机配置 IP地址
	ip地址由两种位置分类: 网+主
	网络位 表示一个网络
	主机位 编号
	四类 
	A 1-127   网+主+主+主
	b 128-191 网+网+主+主
	C 192-223 网+网+网+主
	D 224-239  组播地址
	E 240-254  科研
-子网掩码 subnet mask
	用来区分ip地址的网络位和主机位
	利用二进制的1表示网络位
	利用二进制的0表示主机位
192.168.1.1 = 11000000.10101000.000001.000001
	       11111111.  11111111.  11111111.000000
子网掩码	255      255       255      0 
192.168.1.1 255255.255.0=192.168.1.1/24 该ip有24个网络位 
24 代表前边有连续的 24个1  , 8 个0  
网关地址 一个网络到另一个网络的关口 不同网段之间的访问
dns服务器地址 讲网站的域名解析为对应的 IP地址
arp -a 查看ip地址
#####################################################################
-IP路由 涉及路由器

############################################################################################

cat /etc/redhat-release　#查看系统版本
cat /etc/issue


lscpu 查看cpu信息
cat /proc/meminfo 查看内存 空闲情况
	[student@gao ~]$ head -1 /proc/meminfo 
	MemTotal:       16329888 kB
poweroff 关机
reboot  重启

top
按数字键1 查看 cpu 逻辑核心数量
###########################################################
查看主机名 hostname 
修改主机名 hostname jkgao  (临时修改主机名 重启后 恢复)
修改完成后 打开新终端 才会显示新主机名
################################################################
cat /etc/redhat-release　#查看当前系统版本 适用于 Redhat系列的Linux
cat /etc/issue    	 全版本的 Linux 都可以
https://www.cnblogs.com/wzk-0000/p/7483262.html
########################################
查看网络信息  ifconfig	

ifconfig eth0 192.168.1.1 为eth0 设置临时 IP
############################################
永久设置主机名\IP地址\子网掩码\网关\DNS服务器地址  nmtui  
 GUI 界面
修改ip后需要勾选自动连接 启用禁用后(激活配置)

##########
配置ip
一共会学到三个方法来配置 ip 这是第一个  但是nmtui 这个命令是会在安装系统后删除....所以目前常用的命令是 用脚本 来配置  

#########################################################
本地回环接口 (测试用大部分 win 安卓 Linux 中都有)
inet 127.0.0.0 netmask 255.0.0.0 这个ip永远代表本机 

linux 中的 ping 命令 (没有特殊情况:比如 对方掉线)是不会自己停下了的 需要自己手动停止
############################################
当文件内容较多的时候可以使用 
less 查看 (大文件)
q 退出  用法和vim 编辑器的末行模式类似  :/ a 表示查找包含a字符的文字
支持前后翻页 
[gaoyuan@jkgao ~]$ less /etc/passwd 

当文件内容少时可以使用 cat查看 
查看文件部分内容
head&tail
显示头十行
	[student@gao ~]$ head /etc/passwd |grep bin ####################默认显示前十行
	root:x:0:0:root:/root:/bin/bash
	bin:x:1:1:bin:/bin:/sbin/nologin
	daemon:x:2:2:daemon:/sbin:/sbin/nologin
	adm:x:3:4:adm:/var/adm:/sbin/nologin
	lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
	sync:x:5:0:sync:/sbin:/bin/sync
	shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
	halt:x:7:0:halt:/sbin:/sbin/halt
	mail:x:8:12:mail:/var/spool/mail:/sbin/nologin
	operator:x:11:0:operator:/root:/sbin/nologin
	[student@gao ~]$ head -2 /etc/passwd |grep bin  ###########显示头两行
	root:x:0:0:root:/root:/bin/bash
	bin:x:1:1:bin:/bin:/sbin/nologin
tail用法类似
	[student@gao ~]$ tail -2 /etc/passwd |grep bin
	student:x:1000:1000::/home/student:/bin/bash
	weekend:x:1001:1001::/home/weekend:/bin/bash
	###########################################  显示第一行内存信息
	[student@gao ~]$ head -1 /proc/meminfo 
	MemTotal:       16329888 kB
grep 查找 
格式  grep 条件 目标文件
	       属性
		 -i 忽略大小写 
	     -v 取反查找  关键字之外的都显示
		-^word 必须以字符串word 开头
		-word$ 必须以字符串word 结尾
	student@gao ME]$ grep ^root /etc/passwd
	root:x:0:0:root:/root:/bin/bash
	[student@gao ME]$ grep bash$ /etc/passwd
	root:x:0:0:root:/root:/bin/bash
	student:x:1000:1000::/home/student:/bin/bash
	weekend:x:1001:1001::/home/weekend:/bin/bash
        #保留有效信息 除去空行 除去#开头
	[root@server0 ~]# grep -v ^$ /etc/chrony.conf |grep -v ^# /etc/chrony.conf | >> /opt/a.txt
#################################################### 
	-v 取反查找  关键字之外的都显示
	[student@gao ME]$ grep -v root /etc/passwd |head -5
	bin:x:1:1:bin:/bin:/sbin/nologin
	daemon:x:2:2:daemon:/sbin:/sbin/nologin
	adm:x:3:4:adm:/var/adm:/sbin/nologin
	lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
	sync:x:5:0:sync:/sbin:/bin/sync
#################################################
	[student@gao ~]$ grep bin /etc/passwd
	root:x:0:0:root:/root:/bin/bash
	bin:x:1:1:bin:/bin:/sbin/nologin
	daemon:x:2:2:daemon:/sbin:/sbin/nologin
	adm:x:3:4:adm:/var/adm:/sbin/nologin
	lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
	sync:x:5:0:sync:/sbin:/bin/sync
	shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
	halt:x:7:0:halt:/sbin:/sbin/halt
	mail:x:8:12:mail:/var/spool/mail:/sbin/nologin
	operator:x:11:0:operator:/root:/sbin/nologin
	games:x:12:100:games:/usr/games:/sbin/nologin
	ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin
	nobody:x:99:99:Nobody:/:/sbin/nologin

####################################################
mount 挂载 操作 :让目录成为设备访问点
mount 设备目录 挂载点目录
	[root@jkgao gaoyuan]# mount /dev/cdrom dvd/  #该命令需要root权限操作
	[root@jkgao gaoyuan]# umount dvd/ #卸载挂载点 ,不要的当前挂载点内执行
默认以只读的方式挂载 
	注意:
	1.当前路径不要在挂载点目录内 
	2.允许一个设备有多个不同挂载点
	3.一个挂载点不允许挂载多个设备
	4.挂载点最好使用自己创建的目录,虽然Linux只是规定了挂载点是目录,也就是说可以使用 /root/这种比较特殊的文件夹 ,但是在卸载的时候就会提示目标正忙
安装软件  前提是先得有软件的安装包
	1. 互联网下载
	2. 从光盘中获得安装包
#####################################################
Windows 读取光盘内容

光盘----> 光驱设备 ----->cd驱动器图标(访问点)

如何让Linux系统读取 光盘的内容 
光盘 ------>光驱 
光盘----> 光驱设备 ----->目录(Linux规定)
  /dev/hdc   ####ide
   /dev/sr0  #### sata
	1.图形利用鼠标 将光盘放入 虚拟光驱
	2.命令行查看光驱设备  Linux下通过/dev/cdrom
	[gaoyuan@jkgao ~]$ ls -l /dev/cdrom
	lrwxrwxrwx. 1 root root 3 4月   3 10:59 /dev/cdrom -> sr0



19.4.8 权限和归属
#####################################  
远程管理
ssh root@172.25.0.11
ssh -Xroot@ip 
ctrl + shift + t 开启终端
ctrl + d (退出)关闭终端
  -X 在远程管理时打开图形化界面 
root 不受权限管理
权限和归属
	 权限分类: 基本权限 附加权限 acl访问控制 

	1.基本权限
	    基本权限的类别
	      读取 -r read
	      写入 -w write
	      执行 -x execute (能不能运行程序执行)
	    文本文件: 
		4 r: cat less head tail
		2 w: vim 修改且保存 重定向 >  >>
		1 x:shell 脚本除外(里面写代码) ######一般linux认为任何文本文件不具有执行权限(也就是说默认没有执行权限)
	    权限适用对象
		-所有者:拥有此文件/目录用户 -user  -u
		-所属组:拥有此文件/目录的组 -group  -g
		-其他用户:出所有者\所属组之外的用户-other -o
		dr-xr-x---. 18 root root 4096 4月   8 10:52 /root/
         	d目录
		-   rw- r--    r--  . 1           root     root  2005 7月  11 2014 /etc/passwd
           -文本文件 主组 所属组 其他人 软连接(硬链接) 所有者(属主) 所属组 最后修改时间  文件位置 
		l快捷方式
		除第一个外,每三个为一组共分为三组   
		----------. 1 root root 1148 7月  11 2014 /etc/shadow
		文件 什么权限都没 但是挡不住root
		d rwx rwx rwt . 22 root root 4096 4月   8 11:52 /tmp/
                     t附加权限
         查看权限
		ls -ld
		权限 :所有者>所属组>其他人
		其他系统的权限是叠加的Linux不是  计算机是顺序执行的,
	         判断用户 信息
 		 id userid
		 判断文件的权限 
		 ls -ld /xxxxx
		 相互比对

		 列出所有文件 -r 按照 逆序排列
		 ls -r *

	设置基本权限
		使用chmod 
		基本权限的改变是立即生效的
		-chmod 所属组+ - = (重新赋予权限) 权限
		-R 递归 #################################33Linux中权限默认没有继承 的说法(Windows) 父目录的权限与子目录的权限无关
		eg:		
		[root@server0 ~]# chmod -R o=--- /opt/aa
		[root@server0 ~]# ls -ld /opt/aa
		drwxr-x---. 3 root root 15 4月   8 14:15 /opt/aa
		[root@server0 ~]# ls -ld /opt/aa/bb/
		drwxr-x---. 3 root root 15 4月   8 14:15 /opt/aa/bb/

 	     eg:
		[root@server0 ~]# chmod u=rwx,g=r,o=--- /nsd01/
		[root@server0 ~]# ls -ld /nsd01/ 
		drwxr-----. 2 root root 6 4月   8 14:04 /nsd01/

		r 权限 能够ls 浏览
		 x 权限可以使用cd命令的
		 w 权限可以使用 rm mv cp mkdir touch 等命令(修改文件内容的操作)
		
	设置文档归属
		chown
		-R 递归修改 属主 属组 
		chown [-R] 属主 位置
		chown [-R] 属主:属组 位置
		chown ceph.ceph /dev/vdb1 (用这个修改磁盘 是零时的  重启后失效)　永久修改需要修改配置文件 vim /etc/udev/rules.d/70-vdb.rules 该文件需要创建
		归属选项修改 需要注销后生效
	
	2.附加权限(特殊权限)
	        Set GID (常考)
			 -附加在属组的 X 位上
			 -属组的权限变为s  #####
			-chmod   + - = s 
			-适用于目录,可以使目录下新增(父目录有setgid)的文档(文件和文件夹)(影响未来)自动的设定与父目录相同的属组
		        -继承所属组身份
			r-S 表示没有执行权限
			r-s 表示有执行权限
		 Sticky Bit (不常用)
			附加在其他人的 x 位上
			-其他人的权限表示变为t
			-适用于开放w 权限的目录,防止用户滥用 w权限 ,限制用户修改其他人文件
			# mkdir /home/public/
			# chmod ugo=rwx /home/public/ 

			# chmod o+t /home/public/

		  Set UID (简单的攻击手段,防护用得少) 了解
			-附加在属主的 X 位上
			-适用于可执行文件,setuid可以让使用者具有文件属主的身份以及部分权限

			
	3.acl访问控制表(acl访问策略) 优先于基本权限和附加权限
		能够对个别用户\个别组设置独立的权限
	acl 策略的作用
		文档归属的局限性
		-任何人只属于三种角色: 属主\属组\其他人
		-无法实现更精细的控制
		优点
		 能够对个别用户、个别组设置独立的权限
		 大多数挂载的EXT3/4、XFS文件系统默认已支持
	设置acl访问控制策略
		查看-getfacl 文档
		设置-setfacl [-R] -m u:用户名: 权限类别 文档
		设置-setfacl [-R] -m g:组名: 权限类别 文档
		    setfacl [-R] -b 文档...               #删除所有ACL策略
		    setfacl [-R]-m u:用户名   文档...      #删除单条指定ACL策略
		删除 setfacl  -x :删除指定用户的acl
		setfacl -m  u:lisi:r  /etc/shadow
    umask 值 决定了 用户默认创建 的文件 的 权限
    [root@server0 ~]# umask
    0022   root用户 默认
                            默认权限
    目录 最大权限 777 - 0022  755
    文件 最大权限 666 - 0022  644
    which hostname  ###查找 命令的软件的存放位置
    [root@server0 ~]# which hostname
    /usr/bin/hostname

################################################
	实现lisi用户可以读取/etc/shadow文件内容，您有几种办法?

	1.修改其他人权限　　
		 chmod  o+r  /etc/shadow
	2.利用所属组
		 chown :lisi /etc/shadow
		 chmod  g+r  /etc/shadow
	3.利用所有者
		 chown  lisi /etc/shadow
		 chmod  u+r  /etc/shadow
	4.利用ACL策略
	　　　　　setfacl -m  u:lisi:r  /etc/shadow


###############################################
################################################################
(重要)  软件包的安装 分区规划及使用 ntp时间同步 

软件包的安装
   零散软件包管理
	1.首先要具备软件的安装包
	2.构建web服务或ftp服务共享光盘所有内容(之后会学习到)
	3.讲虚拟机classroom已经构建完成web服务且已经共享光盘内容
	4.访问测试 
	访问http://classroom.example.com/
        包的版本在Linux是有严格的限制的 版本不同肯能 使用不了,会出现不兼容,漏洞等
	安装符合版本的包
	5.下载软件包
	使用wget下载工具
	-wget 软甲包url地址  #默认下载到当前位置
	-wget 软甲包url地址 -O /目录
	提供Ftp功能的软件包(vsftpd)
		vim /etc/vsftpd/vsftpd.conf
		允许匿名登录
		anon_upload_enable=YES


	6.安装
	  适用于单个安装(若依赖关系过多的话请使用yum)
		rpm -qa 软件名 查询该软件是否已经安装
		rpm -qf /usr/bin/mail  //查询文件所属软件 和 yum provides 作用相同
		rpm -ivh 软件名-版本信息.rpm..   ###安装 只有在安装的时候才需要完整的路径和包名
		rpm -e --nodeps 软件名          ###卸载软件,忽略依赖关系
		rpm -qc 软件名                  ###查找软件生成的配置文件位置
		rpm -ql 软件名                  ###查看安装软件安装位置
		yum provides /etc/hosts        ###查询某个文件所属的软件
		rpm -qf                        ###查询/验证文件属于的软件包
        rpm --import name              ###解决签名

	#######################################	
	升级Linux内核(rpm包) 虚拟机中操作
		显示内核版本 : uname -r
		[zhangsan@server0 root]$ uname -r
		3.10.0-123.el7.x86_64

		1.下载新的内核软件包 wget http://classroom.example.com/content/rhel7.0/x86_64/errata/Packages/kernel-3.10.0-123.1.2.el7.x86_64.rpm
		2.安装新内核包 别按ctrl + c  结束 不然会炸鸡
			[root@server0 ~]# rpm -ivh kernel-3.10.0-123.1.2.el7.x86_64.rpm 
			警告：kernel-3.10.0-123.1.2.el7.x86_64.rpm: 头V3 RSA/SHA256 Signature, 密钥 ID fd431d51: NOKEY
			准备中...                          ################################# [100%]
			正在升级/安装...
			1:kernel-3.10.0-123.1.2.el7        ################################# [100%] 
		3.软件包的依赖关系
		   错误: 依赖检测失败
		    可以手动安装: 但不推荐
   	yum仓库管理(重要,面试常考,推荐使用)
		 yum(也是服务)配置及其使用(软件包仓库)
		 作用:为客户端自解决依赖关系安装软件包
		 (配置前先明白谁是服务端谁是客户端,下面的例子是以classroom为服务端)
       	         服务端: 虚拟机 classroom  (有众多的软件包,仓库数据文件,构建web/ftp服务)
		                                  光盘中既具备软件包又具备仓库数据文件 
							packages/       repodata/
		
		 总结:构建web服务/ftp服务,共享光盘内容(搭建yum的服务端仓库,安装 httpd 或者 ftp 共享 光盘的中仓库,这里就完成了 )
		 客户端: server 
		 /etc/yum.repos.d/*.repo
                 指定服务位置 修改配置文件,错误的配置文件会音响到正确的配置文件
		
		[root@server0 ~]# rm -rf /etc/yum.repos.d/* #############删除文件夹下所有文件,不是删除文件夹误删除后自己创建相同文件夹 就好
		[root@server0 ~]# vim /etc/yum.repos.d/dvd.repo ########给你的配置文件起个名字 不支持中文
		格式	#### 记忆yum配置文件的关键字 面试常考	
		[nsd1903] #仓库表示
		name=rhel7 # 仓库描述信息
		baseurl=http://classroom.example.com/content/rhel7.0/x86_64/dvd/ #指定服务端
		enabled=1 #是否启用本文件
		gpgcheck=0 #不检测签名

		gpgcheck=1 时 需要指明 gpgkey的存放位置
		gpgkey=file:///opt/ccc  ###注意这里的 格式  /// 最后一个代表根

	      [root@server0 ~]# yum repolist  #显示如下信息时表示yum配置完成
		已加载插件：langpacks
		nsd03                                                    | 4.1 kB     00:00     
		(1/2): nsd03/group_gz                                      | 134 kB   00:00     
		(2/2): nsd03/primary_db                                    | 3.4 MB   00:00     
		源标识                                源名称                               状态
		nsd03                                 rhel7                                4,305
		repolist: 4,305

		[root@server0 ~]# yum -y install httpd
		已加载插件：langpacks
		正在解决依赖关系
		****
		完毕！ #看到完毕时 表示安装完成
				
		yum remove xxx   卸载 #由于依赖关系的存在,可能在卸载某些包的时候会卸载,相当重要的依赖包 (这条命令不要加 -y选项)
	      yum clear all    清空yum缓存
总结:   删除/etc/yum.repos.d/*
	创建 /etc/yum.repos.d/xxx.repo  ##xx表示配置文件的名字
	配置文件格式:
	nsd1903] #仓库表示
		name=rhel7 # 仓库描述信息
		baseurl=http://classroom.example.com/content/rhel7.0/x86_64/dvd/ #指定服务端
		enabled=1 #是否启用本文件
		gpgcheck=0 #不检测签名
###########################################
硬盘分区管理
   	 扇区(硬盘最小的单位)的大小 512字节 
	  硬盘(块设备)###在虚拟机上操作
	思路: 识别硬盘=>分区规划=>格式化=>挂载使用
	      毛坯楼层=>打隔断 => 装修 => 入住
查看硬盘
     lsblk来列出系统中所有的硬盘
	[root@server0 ~]# lsblk
	NAME   MAJ:MIN RM SIZE RO TYPE MOUNTPOINT
	vda    252:0    0  10G  0 disk 
	└─vda1 252:1    0  10G  0 part /
	vdb    252:16   0  10G  0 disk 
	vda1表示分区1  vda 虚拟硬盘1  vdb 虚拟硬盘2 
分区规划
	分区模式 :mbr古老 gpt 新的模式
		
	主引导记录分区模式:mbr
	mbr/msdos 分区模式
	1-4个主分区 或者3个主分区+1个扩展分区(n个逻辑分区)
	扩展分区再划分就是逻辑分区
	最大支持2.2tb的磁盘	
	扩展分区不能格式化
	/dev/sda5 :该设备表示含义
		第一块scsi借口设备,第五个分区
		第一块scsi借口设备,第一个逻辑分区

		使用命令fdisk /dev/vba 创建分区(只支持mbr分区)
		 n 创建分区
		 p 选择主分区\扩展分区
		 起始扇区
		 结束扇区
		 w 保存退出
		q退出不保存
格式化: 赋予空间文件系统
	文件系统:数据在空间的存储规则
	Linux文件系统
	        RHEL6 ext4 小文件优秀
			RHEL7 xfs  大文件优秀

	mkfs.ext4 分区设备路径
	mkfs.ext3 分区设备路径
	mkfs.xfs  分区设备路径
	mkfs.vfat 分区设备路径
      blkid /dev/vdb1 #查看分区文件类型类型
	对于一块磁盘重复格式化时 有时会需要 强制 格式化 
	eg:
	[root@server0 ~]# mkfs.ext4 /dev/vdb1
	mke2fs 1.42.9 (28-Dec-2013)
	文件系统标签=
	****
	[root@server0 ~]# blkid /dev/vdb1
	/dev/vdb1: UUID="b6fe10fe-9151-4544-a3ac-1328e75ae1ce" TYPE="ext4" 
	[root@server0 ~]# mkfs.xfs /dev/vdb2
	[root@server0 ~]# blkid /dev/vdb2
	/dev/vdb2: UUID="c45e5a63-1d4c-40ca-92ce-294d22d68fb5" TYPE="xfs"
挂载设备进行使用
	mkdir /mypart1 #创建挂载点
	mount /dev/vdb1 /mypart1 (临时挂载)
	df -h#查看正在挂载的分区(设备使用情况) -h 显示易读信息#查看分区信息 (比较常考)
	
	[root@server0 ~]# mkdir /mypart1
	[root@server0 ~]# mount /dev/vdb1 /mypart1/
	[root@server0 ~]# df -h
	文件系统        容量  已用  可用 已用% 挂载点
	/dev/vda1        10G  3.4G  6.7G   34% /
	devtmpfs        901M     0  901M    0% /dev
	tmpfs           921M   80K  921M    1% /dev/shm
	tmpfs           921M   17M  904M    2% /run
	tmpfs           921M     0  921M    0% /sys/fs/cgroup
	/dev/vdb1       976M  2.6M  907M    1% /mypart1
永久挂载(开机自动挂载)
	修改配置文件 /etc/fstab 
	配置文件/etc/fstab 的记录格式
        设别路径     挂载点   类型    参数       备份标记        检测顺序
	/dev/vdb1 /mypart1 ext4  defaults    0(1备份)      0(1检测,只有root分区写1 自己的就不要写了)          
	/dev/vdb2 /mypart2 xft   defaults     0           0
	vim 命令模式进入插入模式 可以按 o 另起新的一行
	mount -a 自动挂载
	检测开机自动挂载配置文件格式是否正确
	检测/etc/fstab 中书写完成,但当前没有挂载的设备 进行挂载 
综合分区
	扩展分区 一路回车就好
	若你在扩展分区是设定 大小,那么 在建立逻辑分区时 只有设定的大小可以分配
	若在分区完成后系统没有识别分区 使用partprobe(刷新系分区) 强制系统识别分区
	注意:系统对与扩展分区的容量显示是不正确的,这不是bug


总结:
 1. 识别硬盘 lsblk
 2. 分区划分 fdisk 
 3. 刷新分区表 partprobe
 4.进行格式化 mkfs.ext4 mkfs.xft  blkid #查询分区信息
 5. mount -a 测试挂载  df -h 显示挂载点
 6. 永久挂载 修改配置文件/etc/fstab 

DN域名DC域控制器
showmount -e 服务端主机/IP

补充:   LDAP (红帽认证考试考点)服务器 (面试大可能会问到)
	使用LDAP认证,实现网络用户认证,达到用户的集中管理(记住这句话) 
	网络用户:用户信息会放在网络中的LDAP服务器
	本地用户:用户信息会放在/etc/passwd
	客户端:classroom
	1. 安装sssd软件,与ldap服务器 通信       
	 yum install -y sssd ####真正起作用的是 SSSD ,由他来提供服务
	   rpm -q sssd
        2.安装authuconfig-gtk图形工具
	yum install -y authuconfig-gtk  ###只提供图像化界面
本地识别的用户不全是在/etc/oasswd ,也有可能在 ldap中
之后配合 autofs实现家目录漫游
#############################


#####################################################
触发挂载
1.关闭虚拟机server,添加光驱设备,将光盘放入

2.安装autofs可以实现触发挂载软件
[root@server0 ~]# yum -y install autofs
3.重启autofs服务
[root@server0 ~]# systemctl restart autofs
[root@server0 ~]# systemctl enable autofs
4.进行触发挂载
[root@server0 ~]# ls /misc
[root@server0 ~]# ls /misc/cd

#################################################
]# ls /etc/auto.master  #触发挂载的主配置文件
]# ls /etc/auto.misc    #挂载配置文件

 触发挂载必须为二层目录结构

  /nsd/第一层称之为监控点,必须有管理员亲自创建

监控点由/etc/auto.master设置
[root@server0 /]# vim /etc/auto.master  
 /misc   /etc/auto.misc
 /nsd    /etc/test

 监控点      指定挂在配置文件的路径
翻译:
设置监控点为/misc,要想知道挂载什么设备,请看/etc/auto.misc文件

[root@server0 /]# fdisk /dev/vdb
[root@server0 /]# mkfs.xfs /dev/vdb1
[root@server0 /]# vim /etc/test 
abc      -fstype=xfs,rw      :/dev/vdb1
挂载点      文件系统类型及参数           挂载设备

[root@server0 /]# systemctl restart autofs
[root@server0 /]# cd /nsd/abc

###############################################

############################
lvm逻辑卷  (最小的单位是分区:整个分区 不可以是某个分区的剩余硬盘)
  作用:整合分散空间 大小可以动态扩大
  将众多的物理卷(也可以是一个)组建成卷组,再从卷组中划分逻辑卷
思路:  零散空闲存储----整合的虚拟磁盘-----虚拟分区
       物理卷(pv)  =>   卷组(vg)  =>  逻辑卷(lv) 
         

	准备阶段
		一 添加硬盘
		1.关机 添加硬盘
		2.远程管理 server
		ssh -X root@172.25.0.11
		lsblk
		二 分区划分
		fdisk 
	准备完成
需要使用的命令
功能  	  物理卷管理    卷组管理  逻辑卷管理
SCAN 	  pvscan     vgscan  lvmscna
  	    pvs        vgs
      显示当前物理卷信息  




[root@mysql_11_master ~]# yum -y install lvm2


lvm卷组制作
	思路: vgcreate 
	      lvcreate
		格式化 
		挂载
1.创建名为systemvg的卷组
格式: vgcrrate 卷组名 设别路径
[root@server0 ~]# vgcreate systemvg /dev/vdc[1-2]

pvs #查看物理卷
vgs #查看卷组
[root@server0 ~]# vgs
  VG       #PV #LV #SN Attr   VSize  VFree 
  systemvg   2   0   0 wz--n- 19.99g 19.99g
[root@server0 ~]# pvs
  PV         VG       Fmt  Attr PSize  PFree 
  /dev/vdc1  systemvg lvm2 a--  10.00g 10.00g
  /dev/vdc2  systemvg lvm2 a--  10.00g 10.00g
 2.创建逻辑卷
格式: lvcreate -n vo -L 16G systemvg
                  逻辑卷名   大小  卷组名
 
eg:
[root@server0 ~]# lvcreate -n vo -L 16G systemvg
  Logical volume "vo" created
[root@server0 ~]# lvs #查看系统中所有逻辑卷
  LV   VG       Attr       LSize  Pool Origin Data%  Move Log Cpy%Sync Convert
  vo   systemvg -wi-a----- 16.00g                                             
[root@server0 ~]# pvs #查看物理卷
  PV         VG       Fmt  Attr PSize  PFree
  /dev/vdc1  systemvg lvm2 a--  10.00g    0 
  /dev/vdc2  systemvg lvm2 a--  10.00g 3.99g

[root@server0 ~]# vgs #查看系统所有卷组信息
  VG       #PV #LV #SN Attr   VSize  VFree
  systemvg   2   1   0 wz--n- 19.99g 3.99g


逻辑卷设备使用
逻辑卷设备文件 /dev/systemvg/vo

                                            卷组名  逻辑卷组名
	[root@server0 ~]# ls /dev/systemvg/vo 
	/dev/systemvg/vo  ##快捷方式 指向  dev/systemvg/vo -> ../dm-0
1.格式化
	[root@server0 ~]# mkfs.xfs /dev/systemvg/vo 
	[root@server0 ~]# blkid /dev/systemvg/vo
	/dev/systemvg/vo: UUID="b64ca55d-311f-4413-8bf1-3c565168117b" TYPE="xfs"
2.挂载
	[root@server0 ~]# mkdir /mypart1
	[root@server0 ~]# vim /etc/fstab 
	/dev/systemvg/vo /mypart1 xfs defaults 0 0
	[root@server0 ~]# mount -a 
	[root@server0 ~]# df -h
逻辑卷的扩展 #支持线上操作 不需要下线后扩展
	一 卷组空间足够
	1.扩展逻辑卷组空间的大小
	 lvextend -L  18G /dev/systemvg/vo	
		      扩大后的容量
	2.扩展逻辑卷组文件系统的大小
	  根据文件系统不同 扩展命令也不同
	 ext4 : resize2fs /dev/systemvg/vo
        xfs:   xfs_growfs /dev/systemvg/vo
	二 卷组空间不足
	让卷组变大
	1.扩展卷组空间                      卷组名    被添加的分区
	[root@server0 ~]# vgextend systemvg /dev/vdc3 #####扩展卷组
	[root@server0 ~]# vgs
	  VG       #PV #LV #SN Attr   VSize  VFree
	  systemvg   3   1   0 wz--n- 29.99g 4.99g
		                             扩展后大小   逻辑卷组url
	[root@server0 ~]# lvextend -L 25G /dev/systemvg/vo###逻辑卷组

	[root@server0 ~]# lvs
	  LV   VG       Attr       LSize  Pool Origin Data%  Move Log Cpy%Sync Convert
	  vo   systemvg -wi-ao---- 25.00g    
	      	扩展文件系统                  被扩展的逻辑卷组url
	[root@server0 ~]# xfs_growfs /dev/systemvg/vo ###扩展文件系统
	[root@server0 ~]# df -h
	/dev/mapper/systemvg-vo   25G   33M   25G    1% /mypart1

##################
卷组分配大小以4m为单位
可以使用
vgcreate -s pe大小 卷组名 空闲分区

lvcreate -l pe个数 -n 逻辑卷名

逻辑卷的删除 
一定要按照这个顺序删除 ,删除前请先卸载
删除卷组前,基于此娟组创建的逻辑卷
lvremove 
vgremove
pvremove

 | 基本不支持 双参数 命令 cp mv
##################
find  查找 递归
  find 路径 条件 也支持多个条件
 -type 类型 (f文本文件,d;目录 ,l快捷方式)
 -name '文档名字'
 -size +|- 文件大小(k(小心),G,M)
  -o  通常接其他命令 表示 or 
  -user 用户名 
  -mtime +10 #表示十天之前 创建 修改 
		#-10 最近十天创建\修改的数据
	      +90 #三个月之内创建或修改的数据
	文件修改时间
	所有的时间都是过去时间
  -exec 处理命令 {}\; #处理find查找的结果
	优势:以{}代替每一个结果逐个处理,遇到\;结束#####注意 结尾
      [root@server0 ~]# find /boot/ -name 'vm*' -exec    cp {} /opt \;
	  [root@server0 ~]# find /boot/ -name 'vm*' -exec    cp {} /opt/ \;
                    -exec 执行 command；如果命令返回状态值0，那么 exec 返回true。所有 find
                          其余的命令行参数将作为提供给命令的参数，直到遇到一个由       `;'
                          组成的参数为止。命令的参数中，字符串                        `{}'
                          将以正在处理的文件名替换。所有的                            `{}'
                          都会被替换，不仅是在单独的一个参数中。有些版本的            find
                          不是这样做的。       这些参数可能需要用       `\'       来escape
                          或者用括号括住，防止它们被shell展开。命令是从起始目录执行的。


	~]# find /etc/ -name passwd* ####支持通配符

    #找出当前目录[3KB,10KB]大小的文件
    find ./ -size +3k -a -size -10k
    找到 tmp下大于200k的 复制到 指定目录
    find /tmp/ -size +200k -exec cp '{}' /tmp/a \;

locate

locate命令其实是“find -name”的另一种写法，但是要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库（/var/lib/locatedb），这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，所以使用locate命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。

locate命令的使用实例：

　　$ locate /etc/sh

搜索etc目录下所有以sh开头的文件。

　　$ locate ~/m

搜索用户主目录下，所有以m开头的文件。

　　$ locate -i ~/m

搜索用户主目录下，所有以m开头的文件，并且忽略大小写。



date  #查看当前系统时间
date -s 'year-month-day h:m:s' #注意格式 
自动时间同步
NTP时间服务器
 -ntp服务器为客户机提供标准时间  端口123
  -客户机与ntp服务器保持通讯
ntp服务器 classroom
ntp客户机 server
 1.安装chrony
 2.修改配置文件
vim /etc/chrony.conf 	
server classroom.example.com
 3.重启服务
[root@server0 ~]# systemctl restart chronyd ####### 重启服务
[root@server0 ~]# systemctl enable chronyd #####设置开机自启
测试时间同步
chronyc sources -v/timedatectl

####################################################
集群
高可用 高效率
##################################
cron 计划任务(面试常考)
		          周期性任务
	    ___________|_____________            
	    |                  |                       | 
	cron任务描述---管理计划任务策略---如何编写crontab 任务记录

作用:按照设定时间间隔为用户反复执行某一项固定系统任务
  crontab 
  配置格式 /etc/crontab  文件
  /var/spool/cron  文件就是保存计划任务的文件
编辑  crontab -e -u 用户名
查看  crontab -l -u 用户名



删除  crontab -r -u 用户名 
格式  
    分 时 日 月 周  任务命令(绝对路径)
     *  *  *  *  *  #五个*表示分钟都执行一次 
     30 8  *  *  *  #每天早上8点半执行一次
     0   21 *  *  5  #每周周五晚上执行  
     0   21 *  *  1-5 #周一到周五 每天9点
     0   21 *  * 7   #周日 0 也代表周日
    0   21 *  *  1,3,5 #周一周三周五 每天9点
    1    8  1  *   1    #周一或每月一号执行8:01
    */3  *  *  *    *   #每隔三分钟执行一次
	* 匹配范围内任意时间
        ,分割多个不连续的时间点
	- 指定连续时间范围
	/n 指定时间频率 ,没 n


  23 14 * * * /bin/echo hiya
eg: 每分钟把当前时间保存到/opt/time.txt
	[root@server0 ~]# crontab -e -u root
	* * * * * date >> /opt/time.txt
       [root@server0 ~]# cat /opt/time.txt
	Wed Apr 10 17:47:01 CST 2019
	date 选项+%F 
        显示完整日期
	[student@gao ME]$ date +%F
	2019-04-11

	

王凯
network 5 天
shell   6 天
##########################################
下面学习的全部都是华为设备
    iso 国际标准化组织
    ieee电气和电子工程师协会
    计算机网络
            网络与 docker Mariadb openstack  hadoop 都有关
            网络的发展
                    60年代    分组交换  :提高数据传输效率,减少服务器负担  例子(断点续传)
                    70-80年代 TCP/IP   :统一网络
                     90年代   wbe技术
            wan与lan
                    wan :广域网
                                范围:10-100000km
                                Internet
                    lan :局域网
                                范围:1km作用
                                短距离
                                企业网,校园网
            网络设备及拓扑
                    厂商 华为 思科
                    线缆链接计算机和网络设备布局
                    点对点  wan
                    网状  lan (推荐)
                       优点:一个节点与其他多个节点相连接 提高冗余和容错性
                       缺点:成本高

                    星型及扩展星型(适用于小型机构)lan
                        优点:易于实现 易于扩展 易于故障排除
                        缺点:中心节点压力大 组网成本高
            网络功能:
                    信息传递
                    资源共享
                    提高可靠性
                    增加系统处理能力(集群)


    网络通信参考模型
            OSI参考模型--iso规定 (理论框架)
                 *  应用层 网络服务和用户的一个借口
                    表示层 数据表示 安全 压缩
                    会话层 建立管理终止 回话
                 *  传输层 定义数据传输 8 的协议端口 已经流程控和差错校验
                 *  网络层 进行逻辑地址寻址 实现不同网络之间的路径选择   (路由器 三层交换机)
                 *  数据链路层  建立逻辑链接 进行硬件地址寻址 差错校验  (交换机)
                    物理层 建立 维护 断开物理链接
                 * 代表运维 应该关注的地方
            TCP/IP五层模型   (实际应用)

                    应用层              HTTP FTP TFTP SMTP SNMP DNS   服务           上层数据
                    传输层 ------|      TCP  UDP                      数据传输质量     TCP 头部   上层数据                 数据段
                    网络层 ------|--核心 ICMP IGMP IP ARP                            ip头部 tcp头部 上层数据              数据包
                    数据链路层----|      VLAN TRANK MSTP                             mac地址 ip头部 tcp头部 上层数据       数据帧
                    物理层                                                            bit                              数据流
            8比特=1字节

                    TFTP Trivial File Transfer Protocol,简单文件传输协议 69
                    SMTP 简单邮件传输协议 (Simple Mail Transfer Protocol, SMTP)  25
                    SNMP 简单网络管理协议 是专门设计用于在 IP 网络管理网络节点（服务器、工作站、路由器、交换机及HUBS等）的一种标准协议，它是一种应用层协议。
                    ICMP (Internet Control Message Protocol)Internet控制报文协议 ping命令
                    IGMP (Internet Group Manage Protocol):Internet组管理协议,提供internet网际多点传送的功能,即将一个ip包拷贝给多个host
    网络层
            作用: 网络层提供点到点的链接

    传输层
            作用: 提供端口到端口的链接  端口 0-65535 1-1023 知名端口号 ; 一般我们使用>=1024
            传输层协议:
                    tcp 可靠 面向链接 效率低 传输控制协议    网页
                        syn 打算与对方主机进行链接
                        ack 确认对方信息
                        fin 打算与对方主机断开链接
                        三次握手
                        syn----ack,syn---ack
                        四次断开
                        fin---ack---fin---ack
                    udp 不可靠 无连接 效率高 用户数据包协议 缺乏可靠机制需要上层协议支持差错控制 游戏
                        TFTP NTP DNS是两个都用

            tcp三次握手 :
            https://www.cnblogs.com/zmlctt/p/3690998.html
                Client ：  syn ----> server
                Server: 收到后 回复  syn+ack----> client
                Client : 收到后 回复 ack -----> server    状态进入 establish 链接建立完成
            四次挥手:
                Client : 发送 FIN ----->server
                Server: 收到FIN -----> 回复ACK 给 client
                Server : 关闭 与 client 的 链接 发送 FIN -----> client
                Client : 收到 FIN+ack 会发 ACK ----->  server 关闭 client 和 server 的链接


    交换机命令行


    交换机命令配置

            172.40.50.115
            获取kvm.sh文件后
            1,   关闭所有虚拟机
            2,   以管理员身份运行
            3, chmod +x kvm.sh
            4, ./kvm.sh
            看到ok则成功

            密码: tedu

            用户视图
            系统视图   system-view
            接口视图   interface Ethernet0/0/1
            协议视图

            熟悉网络设备视图:
            system-view             //进入系统视图
            interface Ethernet0/0/1    //进入接口视图
            quit    //返回上一视图
            interface Ethernet0/0/1    //再次进入接口视图
            return     //返回用户视图

            return命令和快捷键ctrl+z效果一样

            <Huawei>system-view
            [Huawei]sysname SW1			//修改设备名称

            [Huawei]display version    //查看设备系统版本与硬件型号

            [Huawei]display current-configuration   //查看设备当前配置

            aaa   三a模式, 账户,认证,统计
            使用账户和密码登录终端
            <Huawei>system-view
            [Huawei]aaa                    //进入aaa认证
            [Huawei-aaa]local-user admin01 password cipher 123    //创建账户叫admin01,密码123
            [Huawei-aaa]quit
            [Huawei]user-interface console 0  // 打开当前控制台0
            [Huawei-ui-console0]authentication-mode aaa     //激活配置

            密码配置完毕后,退出系统,测试效果    或者 使用 display current-configuration  查看配置
            配错重置---不能修改

            快捷键   ctrl+]   退出账户

            <Huawei>save     //保存配置,如果保存时有被问到是否覆盖,则也回答Y
            <Huawei>reboot	 //重启设备
            <Huawei>reset saved-configuration     //删除配置文件(恢复出厂设置)
            注意:删除配置文件之后,如果重启,系统会先询问是否保存,回答N,然后在回答Y重启

            VRP(通用路由平台)  华为路由器交换机的操作系统的称呼

            arp 协议
                    地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议
                    同时 也有arp 欺骗  在地址转换表更新(有周期)之前修改地址转换表实现攻击,ARP请求为广播形式发送的，
                    网络上的主机可以自主发送ARP应答消息，并且当其他主机收到应答报文时不会检测该报文的真实性就将其记录在本地的MAC地址转换表，
                    这样攻击者就可以向目标主机发送伪ARP应答报文，从而篡改本地的MAC地址表。
                     ARP欺骗可以导致目标计算机与网关通信失败，更会导致通信重定向，所有的数据都会通过攻击者的机器，因此存在极大的安全隐患。

    数据链路层解析


            总结
                数据发送封装  接收数据解封
                学习  广播 转发  更新
                广播域 : 同一网段  统一范围
                广播域太大会造成 干扰 网络速率下降
                交换机是组建局域网的重要设备,交换机可以根据mac地址智能的转发数据帧 ,且工作在数据链路层

            display this ###显示当前配置 超级常用 几乎万能
            shutdown e0/0/1关闭 e0/0/1接口
            undo shutdown e0/0/1 开启 接口

    vlan(虚拟局域网)
            作用:  广播控制
                  增加安全性
                  调高带宽利用率
                  降低延迟
            什么是:
                vlan 4096个  0-4095
                vlan 1 不需创建 默认存在  ;  从vlan 2 开始创建
            思路:
                创建vlan
                把端口加入到vlan
                验证
            进入系统视图
                system-view
            创建vlan
                vlan1
                vlan batch  2 3 #####同时创建 vlan 2 vlan3
            添加端口(先进入端口)
                in e0/0/1               ####进入端口
                port link-type access   ###将网卡设置为access模式
                port default vlan 2     ###添加网卡

                当然也可以添加网卡组后 ,一起添加到vlan
                [Huawei]port-group 1    ###添加网卡组
                [Huawei-port-group-1]group-member Ethernet0/0/3 Ethernet0/0/4  ###添加网卡组成员
                [Huawei-port-group-1]port link-type access ###设置端口接入模式 / trunk
                [Huawei-port-group-1]port default vlan 2              ####将port-group-1 设置为 vlan2
            vlan中继线路使用    trunk
                [Huawei-port-group-1]port link-type trunk
                [Huawei-Ethernet0/0/1]port trunk allow-pass vlan all  ####允许所有vlan

            查看vlan
                display vlan
                display this            ###显示当前,配置
                提示 端口以及绑定请删除端口配置

                [Huawei]clear configuration interface e0/0/1  ###清除端口配置

                若添加错误请在添加命令前加入 undo 在敲一回
                access 接入链路,承载一个vlan
                trunk  中继链路,可以承载多个vlan
    链路聚合(也叫以太通道,网卡绑定)
            配置链路聚合需要在两个台switch 中都配置.配置一端是无效的
            eth-trunk
            作用:多条路线路负载均衡 带宽提高
                容错,当一条线路失效时,不会造成全网中断
            思路:先先创建 eth-trunk(链路聚合接口)
                在进入 端口中将端口添加到eth-trunk(链路聚合接口)
                接着在eth-trunk(链路聚合接口) 中配置需要的东西
            怎么配置:
                方法一
                [Huawei]interface eth-trunk 1       #### 创建 聚合链路端口
                [Huawei]interface Ethernet0/0/1     #### 进入 端口
                [Huawei-Ethernet0/0/1]eth-trunk 1   #### 将端口添加到 链路聚合
                [Huawei]interface Ethernet0/0/2     #### 进入 端口
                [Huawei-Ethernet0/0/2]eth-trunk 1   #### 将端口添加到 链路聚合
                [Huawei-eth-trunk 1] port link-type trunk  ####将聚合链路设置为 trunk
                [Huawei-eth-trunk 1] port trunk allow-pass vlan all ####允许所有vlan

                方法二
                [Huawei]interface eth-turnk 1                       #### 创建 聚合链路端口
                [Huawei-eth-trunk 1]trunkport Ethernet0/0/1 0/0/2   #### 将端口添加到 链路聚合
                [Huawei-eth-trunk 1] port link-type trunk           ####将聚合链路设置为 trunk
                [Huawei-eth-trunk 1] port trunk allow-pass vlan all ####允许所有vlan

    路由器
            作用: 1.能够链接不同的广播域(网段)的设备,并隔离广播
                 2.使用前配置ip

            若接口中 IP配置错误 可以使用  undo IP address 删除 或者重新配置 ip 会覆盖 旧 ip (但是某些情况不能覆盖)
            若接口中ip 配反了  只能全部删除重新配置
            思路: 1.配置网关 ip
                 2.配置终端设备 ip
                 3.配置路由表(静态路由表 / 动态路由表)
            //查看路由表,只需关注24位掩码的网段即可
            [Huawei]display ip routing-table
            静态路由 配置 :
                    <Huawei>system-view
                    [Huawei]interface GigabitEthernet 0/0/0
                    [Huawei-GigabitEthernet0/0/1]ip address 192.168.1.254 24
                    [Huawei-GigabitEthernet0/0/1]quit
                    [Huawei]interface GigabitEthernet 0/0/1
                    [Huawei-GigabitEthernet0/0/1]ip address 192.168.2.1 24
                    [Huawei]ip route-static 192.168.3.0 24 192.168.2.2  ####配置静态路由表  目标地址 下一跳地址
                    [Huawei]ip route-static 192.168.4.0 24 192.168.2.2
            ip route-static 目标地址 掩码 下一跳地址
                    static ----手动
                    direct ----直链接


            动态路由配置:
                    可以自动学习路由条目,通过某种动态路由协议实现.
                    协议: ospf 开放式最短路径优先协议 ; 适应大中型网络,兼容 网络中大部分设备
                    特点:减少管理任务,占用网络带宽(传递路由条目)
                    思路:1.开启ospf协议
                        2.进入area 0
                        3.宣告网络
                        4.默认路由 的设置: 是特殊的静态路由,当路由表中找不到明细路由时使用,匹配任意网段,一般用在企业出口网关.
                    [Huawei]ospf 1          ####开启ospf协议
                    [Huawei-ospf-1]area 0   ####进入area 0
                                                                    #反掩码;讲掩码的10互换
                    [Huawei-ospf-1-area-0.0.0.0]network 192.168.1.0 0.0.0.255 ####宣告网络,对外告知自身链接了那些网段
                                             通配所有的地址     下一跳地址
                    [Huawei]ip route-static 0.0.0.0 0.0.0.0 192.168.4.2       ####添加默认路由




    三层交换机
            什么是三层交换机


            思路:当你需要给 三层交换机的端口配置ip时需要 你在三层交换机的vlan虚拟接口(svi)上配置ip
                有几个vlan 就有几个接口
            配置:
                [Huawei]vlan batch 2 3
                [Huawei]interface Vlanif 1                  ####进入vlan1的虚拟接口
                [Huawei-Vlanif1]ip address 192.168.1.254 24 ####添加ip地址
                [Huawei]interface Vlanif 2
                [Huawei-Vlanif1]ip address 192.168.2.254 24
                [Huawei]interface Vlanif 3
                [Huawei-Vlanif1]ip address 192.168.3.254 24
                [Huawei]interface Ethernet0/0/2
                [Huawei-Ethernet0/0/7] port link-type access
                [Huawei-Ethernet0/0/7] port default vlan 2
                [Huawei]interface Ethernet0/0/3
                [Huawei-Ethernet0/0/7] port link-type access
                [Huawei-Ethernet0/0/7] port default vlan 3


            icmp  Internet  控制报文协议 检测和反馈网络状态信息
            ping 命令 就使用了 icmp 协议
            ping -t [时间] -l [字节] 目标ip/主机地址
            ping -c 限定次数 -i 限定ping时间间隔 -w 限定返回时间

    访问控制列表 ACL
            作用:过滤网络数据可以对源ip,目标ip端口,协议进行限制,达到更加合理的使用网络的目的.

            acl 分类
                acl 2000-2999 匹配 源ip
                acl 3000-3999 匹配源ip 目标ip 端口 协议
                0 严格匹配
                1 不做匹配
                192.168.1.0 0.0.0.255 匹配192.168.1 x 整个 网段 (以c类为例子)
                192.168.1.0 0.0.255.255 匹配 192.168.x.x
                192.168.1.0 0           匹配 192.168.1.1  这台服务器
                [Huawei]acl 2000    ####选择分类
                [Huawei-acl-basic-2000]rule deny source 192.168.2.1 0  #####拒绝192.168.2.1 主机
                                       rule permit source              ####允许
                [Huawei-GigabitEthernet0/0/1]traffic-filter inbound acl 2000  ####在端口中设置acl条目,过滤流量

                ###########################################

                高级acl
                [Huawei]acl 3000
                ###配置2.1 拒绝访问 1.1 的ftp
                [Huawei-acl-adv-3000]rule deny tcp source 192.168.2.1 0 destination 192.168.1.1 0 destination-port eq 21
                #配置2.2 拒绝访问 1.1 的web
                [Huawei-acl-adv-3000]rule deny tcp source 192.168.2.2 0 destination 192.168.1.1 0 destination-port eq 80
                [Huawei]interface g0/0/1
                [Huawei-GigabitEthernet0/0/1]traffic-filter inbound acl 3000

            內部私有地址:
                A:10.0.0.0~10.255.255.255         /8
                B:172.16.0.0~172.31.255.255       /16
                C:192.168.0.0~192.168.255.255     /24
                一下这两个地址不可用
                127 本機回环地址
                169.254 内部保留地址(无法与外网通信)
    NAT 网络地址转换 ,可以将内部私有地址转换成公网ip从而实现全球互联
            优点:节省公有合法ip
                处理地址重叠
                安全性
            缺点:延迟大
                配置和维护复杂
            实现方式:
                静态转换(一对一,从外网访问内网)
                Easy IP(一对多,从内网访问外网,不能从外网访问内网)
                这两个方式可以同时存在,且优先选择 静态转换

            配置:
                静态nat
                ##### 进入外网口 (一定要在外网口配置,在内网口无效)
                [Huawei]interface GigabitEthernet 0/0/0
                ##### 配置端口ip
                [Huawei-GigabitEthernet0/0/0] ip address  100.0.0.1 8
                ##### 配置静态 nat ;  nat static global 外网 ip  inside 内网 ip
                [Huawei-GigabitEthernet0/0/0]nat static global 100.0.0.2 inside 192.168.2.1  一个外网 ip 只能对应一个 内网 ip
                [Huawei-GigabitEthernet0/0/0]nat static global 100.0.0.3 inside 192.168.2.2

                Easy IP
                #### 先删除 之前配置的 静态nat
                [Huawei-GigabitEthernet0/0/0]undo nat static global 100.0.0.2 inside 192.168.2.1
                [Huawei-GigabitEthernet0/0/0]undo nat static global 100.0.0.3 inside 192.168.2.2
                #### 使用  acl 限定范围
                [Huawei]acl 2000  ###参照 278 行
                [Huawei-acl-basic-2000]rule permit source any     //使用acl定义任何内部地址
                #### 配置easy  IP
                [Huawei]interface g0/0/0
                [Huawei-GigabitEthernet0/0/0]nat outbound 2000    //可以利用g0/0/0的ip访问外网

    生成树协议(STP) 默认开启 了解内容
            作用:在环形网络中 临时断开一个接口,防范广播风暴; 在网络不同时,打开这个接口,起到备份链路作用
            #### 查看stp 状态信息
            display stp brief
                forwarding 转发
                discarding 阻塞状态(临时断开)

    vrrp 技术
            虚拟路由热备协议
            作用: 在不改变组网的情况下,将多台路由器虚拟成为一个虚拟路由器通过虚拟路由器的 IP 地址为默认网关,实现网关备份.
            三层交换机和路由器都可以使用.
            成员:
            主路由器(干活的) 备份路由器(当主路由器挂了,自动切换为主路由器) 虚拟路由器
            实验参考 : 三层交换配置VRRP
            路由器
                <Huawei>system-view
                [Huawei]interface GigabitEthernet 0/0/0
                [Huawei-GigabitEthernet0/0/0]ip address 192.168.2.1 24
                [Huawei]interface GigabitEthernet 0/0/1
                [Huawei-GigabitEthernet0/0/1]ip address 192.168.3.1 24
                [Huawei]interface GigabitEthernet 0/0/2
                [Huawei-GigabitEthernet0/0/2]ip address 192.168.4.254 24
                [Huawei]ospf
                [Huawei-ospf-1]area 0
                [Huawei-ospf-1-area-0.0.0.0]network 192.168.2.0 0.0.0.255
                [Huawei-ospf-1-area-0.0.0.0]network 192.168.3.0 0.0.0.255
                [Huawei-ospf-1-area-0.0.0.0]network 192.168.4.0 0.0.0.255
                MS1
                <Huawei>system-view
                [Huawei]interface Vlanif 1
                [Huawei-Vlanif1]ip add 192.168.1.252 24
                [Huawei]vlan 2
                [Huawei-vlan2]quit
                [Huawei]interface Vlanif 2
                [Huawei-Vlanif2]ip address 192.168.2.2 24
                [Huawei-Vlanif2]quit
                [Huawei]interface GigabitEthernet 0/0/2
                [Huawei-GigabitEthernet0/0/2]port link-type access
                [Huawei-GigabitEthernet0/0/2]port default vlan 2
                [Huawei]ospf
                [Huawei-ospf-1]area 0
                [Huawei-ospf-1-area-0.0.0.0]network 192.168.1.0 0.0.0.255
                [Huawei-ospf-1-area-0.0.0.0]network 192.168.2.0 0.0.0.255
                vrrp配置
                ######进入vlan1
                [Huawei]interface Vlanif 1
                ###### 配置vrrp        vrrp 编号
                [Huawei-Vlanif1]vrrp vrid 1 virtual-ip 192.168.1.254
                                vrrp vrid 1 priority 110 设定优先级
                MS2
                <Huawei>system-view
                [Huawei]interface Vlanif 1
                [Huawei-Vlanif1]ip add 192.168.1.253 24
                [Huawei]vlan 3
                [Huawei-vlan3]quit
                [Huawei]interface Vlanif 3
                [Huawei-Vlanif3]ip address 192.168.3.2 24
                [Huawei-Vlanif3]quit
                [Huawei]interface GigabitEthernet 0/0/2
                [Huawei-GigabitEthernet0/0/2]port link-type access
                [Huawei-GigabitEthernet0/0/2]port default vlan 3
                [Huawei]ospf
                [Huawei-ospf-1]area 0
                [Huawei-ospf-1-area-0.0.0.0]network 192.168.1.0 0.0.0.255
                [Huawei-ospf-1-area-0.0.0.0]network 192.168.3.0 0.0.0.255
                ######进入vlan1
                [Huawei]interface Vlanif 1
                ###### 配置vrrp        vrrp 编号
                [Huawei-Vlanif1]vrrp vrid 1 virtual-ip 192.168.1.254


            排错:
                 1.查看 借口 IP
                 2.查看 ospf (声明) 配置 是否正确
                 3.终端设备的网关

            在多vlan中配置vrrp 实现负载均衡 的配置 思路 :
                 ms1 (三层交换机)
                    1.创建vlan2
                    2.与其他交换机所有链接的接口配置为trunk
                    3.给vlan1 配置 192.168.1.252
                    4.给vlan2 配置 192.168.2.252
                    5.進入vlan1,开启vrrp,虚拟ip 192.168.1.254
                    vlan1 vrrp 优先级设置为110
                    6.進入vlan2,开启vrrp,虚拟ip 192.168.2.254

                 ms2
                    1.创建vlan2
                    2.与其他交换机所有链接的接口配置为trunk
                    3.给vlan1 配置 192.168.1.253
                    4.给vlan2 配置 192.168.2.253
                    5.進入vlan1,开启vrrp,虚拟ip 192.168.1.254
                    6.進入vlan2,开启vrrp,虚拟ip 192.168.2.254
                    vlan2 vrrp 优先级设置为110

                 sw1 (交换机)
                    1.创建vlan2
                    2.与其他交换机链接的接口配置为trunk

                 sw2
                    1.创建vlan2
                    2.与其他交换机链接的接口配置为trunk
                    3.链接pc的端口添加为vlan2



  Q: 如何判断两个ip地址是同一个 ip段
  A: 网络位和广播地址是否相同 , 相同为同网段
   arp 显示和修改ip到mac转换表

            snmp

            简单网络管理协议（SNMP，Simple Network Management Protocol），由一组网络管理的标准组成，
            包含一个应用层协议（application layer protocol）、数据库模型（database schema）和一组资源对象。
            该协议能够支持网络管理系统，用以监测连接到网络上的设备是否有任何引起管理上关注的情况。

运维 (7天)
        主机ip 以及ip地址
        clients eth0 192.168.4.10/24
        proxy   eth0 192.168.4.5/24
                eth1 192.168.2.5/24
        web1    eth1 192.168.2.100/24
        web2    eth2 192.168.2.200/24
    web服务器对比
        unix 与 linux 平台下
        -apache  Nginx  Tengine Lighttp
        -Tomcat   IBM websphere Jboss
        windows
        -IIS Internet information server
        Nginx(相比于Apache,开源) 更快 更小  效率更高 并发量更高
        Tengine 为Nginx的改编
    LNMP(PHP) NGNIX+PHP  只能这么配合
    TOMCATE+JAVA


参考 https://www.cnblogs.com/wcwnina/p/8728430.html
    https://www.cnblogs.com/zyxnhr/p/10707932.html#_label0_0


    Nginx 介绍
        轻量级的http服务器
        高性能http和反向代理服务器同时 也是 imap /pops smtp 代理服务器
        现代化软件都是模块化设计

    如何查看 网页使用的服务器
        F12 进入 network 选项 ,选择其中一项, 查看 response head  找关键词    server
    安全策略都是针对用户和用户组的
        谁启动服务,该服务就具有谁的权限.
    安装 NGINX
        root ------>httpd(nginx)--------客户访问
        useradd nginx
        root执行命令---->以nginx普通用户启动服务 systemctl restart
        ##########################################################
        由于软件可能存在 漏洞 ,在yum 安装程序的时候 会自动创建一个用户名称和软件相同的用户,启动服务的时候以该用户启动.
        若该程序被攻击,那么攻击者也只能获取该用户的权限 与 / 无关. 而在使用源码安装的的时候 这些需要 手动 操作.
        ##########################################################
        1)安装依赖包
            若不知道依赖包 则 查看 官方文档 或者直接安装 包什么错误 装什么包
        2)./configure 安装
            [root@proxy ~]# yum -y install gcc pcre-devel openssl-devel        //安装依赖包
            [root@proxy ~]# useradd -s /sbin/nologin nginx
            [root@proxy ~]# tar  -xf   nginx-1.10.3.tar.gz
            [root@proxy ~]# cd  nginx-1.10.3
            [root@proxy nginx-1.10.3]# ./configure   \
            > --prefix=/usr/local/nginx   \                //指定安装路径
            > --user=nginx   \                            //指定用户
            > --group=nginx  \                            //指定组
            > --with-http_ssl_module                        //开启SSL加密功能 ###with XXX 安装附加模块 without XXX不添加 附加模块
            [root@proxy nginx-1.10.3]# make && make install    //编译并安装

        3)启动服务
            [root@proxy ~]# /usr/local/nginx/sbin/nginx                    //启动服务
            [root@proxy ~]# /usr/local/nginx/sbin/nginx -s stop            //关闭服务
            [root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload        //重新加载配置文件 ### (不关闭服务)使配置文件立刻生效
            [root@proxy ~]# /usr/local/nginx/sbin/nginx -V                //查看软件信息
            [root@proxy ~]# ln -s /usr/local/nginx/sbin/nginx /sbin/        //方便后期使用
            当创建完成 软连接后 就可以使用
                nginx 来代替 /usr/local/nginx/sbin/nginx
                nginx -s stop


        查看服务端口
            netstat命令可以查看系统中启动的端口信息，该命令常用选项如下：
                -a显示所有端口的信息
                -n以数字格式显示端口号
                -t显示TCP连接的端口
                -u显示UDP连接的端口
                -l显示服务正在监听的端口信息，如httpd启动后，会一直监听80端口
                -p显示监听端口的服务名称是什么（也就是程序名称）
                netstat -untlp
                        -anptu
                netstat -anptul | grep 80 查找80 端口谁在使用


        版本升级/功能安装
            功能安装没有办法动态安装只能重新安装(升级安装)
            1.版本老旧,需要升级
            2.添加模块

            生成的objs 是从src(源码)中提取需要安装的文件,且没有编译,使用make(而不是make install)编译生成安装文件.
            make install 是重新安装将会覆盖/usr/local/nginx/html or conf or logs or /sbin/nginx ,也就是这些文件夹下所有的文件将会删除.

        1）编译新版本nginx软件
            [root@proxy ~]# tar  -zxvf   nginx-1.12.2.tar.gz
            [root@proxy ~]# cd nginx-1.12.2
            ############请在nginx安装包目录下执行否则会出错####################################################
            [root@proxy nginx-1.12.8]# cat auto/options | grep YES  ##查看默认安装和可以安装的nginx模块
            #######################################################################################
            [root@proxy nginx-1.12.2]# ./configure   \
            > --prefix=/usr/local/nginx   \
            > --user=nginx   \
            > --group=nginx  \
            > --with-http_ssl_module
            ####################### 注意这里是make 且 不适用make install(重新安装)
            [root@proxy nginx-1.12.2]# make

        2)备份老的nginx主程序，并使用编译好的新版本nginx替换老版本
            [root@proxy nginx-1.12.2]# mv /usr/local/nginx/sbin/nginx  \
            >/usr/local/nginx/sbin/nginxold
            [root@proxy nginx-1.12.2]# cp objs/nginx  /usr/local/nginx/sbin/         //拷贝新版本

            ###########################################
            [root@proxy nginx-1.12.2]# make upgrade                            //升级
            ############################################
            #或者使用killall nginx杀死进程后再启动nginx。
            /usr/local/nginx/sbin/nginx -t
            nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok
            nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful
            kill -USR2 `cat /usr/local/nginx/logs/nginx.pid`
            sleep 1
            test -f /usr/local/nginx/logs/nginx.pid.oldbin
            kill -QUIT `cat /usr/local/nginx/logs/nginx.pid.oldbin`
            [root@proxy ~]# /usr/local/nginx/sbin/nginx –v                //查看版本

    访问测试
        1)分别使用浏览器和命令行工具curl测试服务器页面
            [root@client ~]# firefox http://192.168.4.5
            [root@client ~]# curl http://192.168.4.5
           #####################################
            curl -u tom:123 192.168.4.6   ### -u 添加用户和密码


    LNMP的配置
    nginx 和 httpd 的配置
        httpd 配置
            <virtualhost *:80>
            documentroot /var/www/html
            servername www.example.com
            </virtualhost>
        nginx 配置
          vim /usr/local/nginx/conf/nginx.conf
            server {
                ###监听端口
                listen 80;
                ###域名
                server_name www.dc.com;
                ####网页根路径
                root html;###默认写相对路径,也可以是用绝对路径
                ######root "/usr/local/nginx/html";
                ####默认首页,第二个是当第一个网页失效的时候备份
                index index.html index.htm;
                    }
          配置格式
            server {                     #### server 代表的是     网站

                location / {             #### location 代表的是  网站下的某个网页
                }
                location / {
                }
            }

    实验目的: 给网页添加用户访问认证,输入正确的账户密码才能访问
        1)修改配置文件
            vim /usr/local/nginx/conf/nginx.conf
            server {
            listen       80;
            server_name  localhost;

            #charset koi8-r;

            #access_log  logs/host.access.log  main;
            需要手动添加的配置
            ###############################################
            auth_basic "Input Password:";                 ###提示信息
            auth_basic_user_file "/usr/local/nginx/pass"; ZZtom ng ###保存用户名密码的文件
            ###############################################
            location / {
                root   html;
                index  index.html index.htm;
            }
        2)生成密码文件
            ####################
            ###不要使用 vim 创建##
            ####################
            安装httpd-Tools,创建 密码文件
            yum -y install httpd-tools
            #############################################################
            -c 新建文件,当添加第二个用户时应当 不写 -c
            [root@proxy lnmp_soft]# htpasswd -c /usr/local/nginx/pass tom
            New password:
            Re-type new password:
            Adding password for user tom
            [root@proxy lnmp_soft]# htpasswd /usr/local/nginx/pass dc
            New password:
            Re-type new password:
            Adding password for user dc

        3)重启服务
            软连接
            nginx -s reload
        4)排错

            cd /usr/local/nginx/logs

            tailf error.log
            进入文件后 一路回车 让页面 什么都不显示 用浏览器访问 , 之后出现的错误错误信息 可作为排错的依据

    虚拟主机服务
        基于域名(最常用),基于IP,基于端口

        1)修改配置文件
                 每一个server 就是一个 网站 并且放在 html中
            [root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
                .. ..
                server {
                        listen       80;                                      //端口
                        server_name  www.a.com;                                //域名
                        auth_basic "Input Password:";                        //认证提示符
                        auth_basic_user_file "/usr/local/nginx/pass";        //认证密码文件
                location / {
                        root   html;                                    //指定网站根路径
                        index  index.html index.htm;
                               }

                }
                … …
                    server {
                        listen  80;                                        //端口
                        server_name  www.b.com;                                //域名
                    location / {
                        root   www;                                 //指定网站根路径
                        index  index.html index.htm;
                        }
                }

            批量修改配置文件参考 ADMIN 349 行
            vim 末行模式 中 :88,90s/#//
        2) 重启服务
            /usr/local/nginx/sbin/nginx -s reload(重新加载nginx配置文件)


    https加密服务
         对称加密
            AES DES [安全]
            单机加密(安全)
            网络加密(不安全)
         非对称加密
            RSA DSA 私钥 公钥
         信息摘要
            MD5 SHA256 SHA


         1)生成私钥与公钥
            [root@proxy ~]# cd /usr/local/nginx/conf
            [root@proxy ~]# openssl genrsa > cert.key                            //生成私钥
                                              格式
            [root@proxy ~]# openssl req -new -x509 -key cert.key > cert.pem      //生成证书

         2)修改配置文件
            [root@proxy ~]# vim  /usr/local/nginx/conf/nginx.conf
            … …
            server {
                    listen       443 ssl;
                    server_name            www.c.com;
                    ssl_certificate      cert.pem;         #这里是证书文件
                    ssl_certificate_key  cert.key;         #这里是私钥文件  文件位置 可以填写绝对路径
                    ssl_session_cache    shared:SSL:1m;
                    ssl_session_timeout  5m;
                    ssl_ciphers  HIGH:!aNULL:!MD5;
                    ssl_prefer_server_ciphers  on;
                    location / {
                        root   html;
                        index  index.html index.htm;
                    }
                }
         3)重启服务
            [root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
            #请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
            #[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)

         4)验证
            [root@client ~]# vim /etc/hosts  ####添加hosts 由于没有 dns服务器.
            192.168.4.5    www.c.com  www.a.com   www.b.com
            firefox https://www.c.com
            curl  https://www.c.com
            需要输入密码
            curl  -u tom:123 https://www.c.com
    动态页面和静态页面的实现
         区别
            动态(Java,php,py,sh...)代码在服务器执行
            静态(jpg,MP4...)
            #########添加php-fpm后用户访问网站流程##############################
             www.example.com        |
                   |
                Nginx        |
                   |路由到www.example.com/index.php        |
                   |加载nginx的fast-cgi模块        |
                   |fast-cgi监听127.0.0.1:9000地址        |
                   |www.example.com/index.php请求到达127.0.0.1:9000
                   |
                   |php-fpm 监听127.0.0.1:9000
                   |
                   |php-fpm 接收到请求，启用worker进.程处理请求        |
                   |php-fpm 处理完请求，返回给nginx        |
                   |nginx将结果通过http返回给浏览器
            ############  nginx 是不可以 处理 web页面的 只能交给php处理,而php-fpm则加快了php处理的速度########
            cgi是一个传输协议
            php-fpm 提供fastcgi的进程管理功能,也就是说实现了fastercgi.
            注意，FastCGI的内存消耗问题，一个PHP-FPM解释器将消耗约25M的内存。
         1) 安装 nginx mariadb(客户端软件)  mariadb-server(服务器端软件) mariadb-devel(mariadb依赖软件) php php-ftm(PHP服务) php-mysql(链接mysql数据库模块)
            [root@proxy ~]# yum -y install   mariadb   mariadb-server   mariadb-devel
            [root@proxy ~]# yum -y  install  php   php-mysql
            [root@proxy ~]# yum -y  install php-fpm


         2)启动服务
            这里需要注意的是，如果服务器上已经启动了其他监听80端口的服务软件（如httpd），则需要先关闭该服务，否则会出现冲突。

            1.启动Nginx服务
            [root@proxy ~]# systemctl stop httpd                //如果该服务存在则关闭该服务
            [root@proxy ~]# /usr/local/nginx/sbin/nginx             //启动Nginx服务
            [root@proxy ~]# netstat -utnlp | grep :80
            tcp    0    0 0.0.0.0:80        0.0.0.0:*        LISTEN        32428/nginx
            2.启动MySQL服务
            [root@proxy ~]# systemctl start  mariadb           //启动服务器
            [root@proxy ~]# systemctl status mariadb           //查看服务状态
            [root@proxy ~]# systemctl enable mariadb           //设置开机启动
            3.启动PHP-FPM服务
            [root@proxy ~]# systemctl start php-fpm           //启动服务
            [root@proxy ~]# systemctl status php-fpm          //查看服务状态
            [root@proxy ~]# systemctl enable php-fpm          //设置开机启动


            若网页会静态,nginx 直接返回文件
            若网页会动态,nginx 转发给9000(php)端口

            location 匹配用户的地址栏,从域名/ip往后 ; 且支持正则模糊匹配 添加 '~'; 不添加~ 表示模糊匹配
              location 一定要写在 server 中来
              server {
                location / {
                deny 1.1.1.1;
                allow all;
                }

                location /abc {
                allow all;
                }
                location /dachui {
                allow all;
                    }
                }

                #######匹配 动态网页 (以php 结尾的文件, '\'代表 转义 ,   ,'~' 表示使用正则 , '.' 在linux 中代表 匹配任意字符)
                修改nginx.conf 动静分离
                nginx动静分离参考:
                https://blog.51cto.com/13480443/2105404
                实际上 这种通过正则匹配的方法 是 通过 匹配不同的 url地址 来达到 动静分离的效果
                在一个 server 中 写 多个 location 来实现， 也需要定义动态集群和静态集群来，来分别处理动态请求和静态请求
                                        nginx 动静分离
                                        eg ：
                                            定义前端服务器集群
                                                upstream htmlservers {
                                                server 192.168.221.20:80;
                                                server 192.168.221.30:80;
                                                }
                                            upstream phpservers {
                                                server 192.168.221.20:80;
                                                server 192.168.221.30:80;
                                                }
                                            upstream picservers {
                                                server 192.168.221.20:80;
                                                server 192.168.221.30:80;
                                                }


                                                // 在 location {...}内添加以下内容
                                                if ($request_uri ~* \.html$){
                                                                proxy_pass http://htmlservers;
                                                            }
                                                            if ($request_uri ~* \.php$){
                                                                proxy_pass http://phpservers;
                                                            }
                                                            proxy_pass http://picservers;



                这是单个服务器匹配动态页面，非nginx 调度服务器
                location ~ \.php$ {
                  root           html;
                ################# 将动态文件转发给9000 端口 交个 php-fpm 处理
                  fastcgi_pass   127.0.0.1:9000;
                  fastcgi_index  index.php;
                 #  fastcgi_param  SCRIPT_FILENAME  /s    cripts$fastcgi_script_name;
                 ########## 导入 nginx 变量
                  include        fastcgi.conf;
                 }


         3)添加 网页测试访问
                cd /root/lnmp_soft/php_scripts/
                firefox 192.168.4.5/mysql.php
         3)排错
            当重启nginx服务没有错误时,且页面加载失败那么,可能是 php 错误
            Nginx的默认访问日志文件为/usr/local/nginx/logs/access.log
            Nginx的默认错误日志文件为/usr/local/nginx/logs/error.log
            PHP默认错误日志文件为/var/log/php-fpm/www-error.log
##################################################################
    地址重写
             NGINX服务器地址重写
             用到的参数 : rewrite
             rewrite regex replacement flag
             用到的参数 : rewrite 旧地址(支持正则表达式) 新地址 参数
             #######################
             地址重写格式【总结】
             #######################
             rewrite 旧地址 新地址 [选项];
             last 不再读其他rewrite
             break 不再读其他语句，结束请求
             redirect 临时重定向
             permament 永久重定向
         1.访问a跳转到b
            1)修改nginx配置参数

                [root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
                .. ..
                server {
                        listen       80;
                        server_name  localhost;
                charset utsf-8; ####支持中文显示
                rewrite /a.html  /b.html redirect; ####实现地址转换 ### redirect 访问a.html重定向到b.html（跳转地址栏）

                ###auth_basic "Input Password:"; #提示信息
                ###auth_basic_user_file "/usr/local/nginx/pass"; ###保存用户名密码的文件
                location / {
                    root   html;
                index  index.html index.htm;
                }
                }
            2) 测试访问
                重新加载配置文件
                /usr/local/nginx/sbin/nginx  -s  reload
                firefox  http://192.168.4.5/a.html 添加 redirect 后注意访问 地址栏的的变化

         2.访问192.168.4.5的请求重定向至www.tmooc.cn
            1)修改配置文件
                [root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
                .. ..
                server {
                        listen       80;
                        server_name  localhost;
         #####################################################
                rewrite ^/  http://www.tmooc.cn/;
         ####################################################
                location / {
                    root   html;
                index  index.html index.htm;
                # rewrite /a.html  /b.html  redirect;
                }
                }
            2)访问测试
                /usr/local/nginx/sbin/nginx  -s  reload
                firefox  http://192.168.4.5/a.html (真机测试 虚拟机 没有 网络)

         3.访问192.168.4.5/下面子页面，重定向至www.tmooc.cn/下相同的页面
            1)修改配置文件
                [root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
                .. ..
                server {
                        listen       80;
                        server_name  localhost;
                ############在正则中()表示复制 \1 表示粘贴第一个参数,
                ############但是 在 nginx中粘贴第一个复制参数  $1 表示;;; 注意这个不同
                rewrite ^/(.*)$  http://www.tmooc.cn/$1;
                location / {
                    root   html;
                index  index.html index.htm;
                }
                }
            2) 重新加载配置文件 ,访问测试
               /usr/local/nginx/sbin/nginx  -s  reload
               firefox 192.168.4.5/free

         4.修改配置文件(实现curl和火狐访问相同链接返回的页面不同)
            不同终端访问相同的网站 显示不同网页(移动端和桌面端网页的实现)
            1)修改配置文件
                [root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
                .. ..
                server {
                        listen       80;
                        server_name  localhost;
                location / {
                    root   html;
                index  index.html index.htm;
                }
                #这里，~符号代表模糊正则匹配，*符号代表不区分大小写,只要包含firefox 字符就执行
                if ($http_user_agent ~* firefox) {            //识别客户端firefox浏览器
                rewrite ^(.*)$  /firefox/$1;
                }
                }
            2) 添加网页
                [root@proxy ~]# echo "I am Normal page" > /usr/local/nginx/html/test.html
                [root@proxy ~]# mkdir  -p  /usr/local/nginx/html/firefox/
                [root@proxy ~]# echo "firefox page" > /usr/local/nginx/html/firefox/test.html
            3)重启服务 访问测试
                [root@proxy html]# nginx -s reload
                firefox 192.168.4.5/test.html
                Google-chrome 192.168.4.5/test.html


    NGINX反向代理服务器
        nginx负载均衡
        通过nginx反向代理实现负载均衡  https://blog.51cto.com/13480443/2105404
        ngixn负载均衡 7层
         正向代理客户端 : 服务器不知道用户(翻墙),代理用户访问服务器
         反向代理服务器 : 用户不知道自己访问的是那一台服务器
         功能: 调度(负载均衡).健康检查(/)
             使用Nginx实现Web反向代理功能，实现如下功能：
                后端Web服务器两台，可以使用httpd实现
                Nginx采用轮询的方式调用后端Web服务器
                两台Web服务器的权重要求设置为不同的值
                最大失败次数为1，失败超时时间为30秒

         算法: 轮询算法(roundrobin,RR)
                                 |------->web1
                clients---->proxy-
                                 |------->web2
                常用的 轮询算法
                WRR
                IP_hash
                URl_hash
                fair        由upstream_fair模块支持
         1.部署实施后端Web服务器
             1）部署后端Web1服务器
                [root@web1 ~]# yum  -y  install  httpd
                [root@web1 ~]# echo "192.168.2.100" > /var/www/html/index.html
                [root@web1 ~]# systemctl restart httpd
                [root@web1 ~]# firewall-cmd --set-default-zone=trusted
                [root@web1 ~]# setenforce 0
             2)部署后端Web2服务器
                [root@web2 ~]# yum  -y  install  httpd
                [root@web2 ~]# echo "192.168.2.200" > /var/www/html/index.html
                [root@web2 ~]# systemctl restart httpd
                [root@web2 ~]# firewall-cmd --set-default-zone=trusted
                [root@web2 ~]# setenforce 0
         2.配置Nginx服务器，添加服务器池，实现反向代理功能
             1）修改/usr/local/nginx/conf/nginx.conf配置文件
                [root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
                .. ..
                http {
                .. ..
                #使用upstream定义后端服务器集群，集群名称任意(如webserver)
                #使用server定义集群中的具体服务器和端口
                upstream webserver {
                                server 192.168.2.100:80;
                                server 192.168.2.200:80;
                        }
                .. ..
                server {
                        listen        80;
                        server_name  localhost;
                        location / {
                        #通过proxy_pass将用户的请求转发给webserver集群
                            proxy_pass http://webserver;
                        }
                }
             2)重启nginx服务
                [root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
                #请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
                #[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
             3）客户端使用浏览器访问代理服务器测试轮询效果
                [root@client ~]# curl http://192.168.4.5            //使用该命令多次访问查看效果
                [root@client ~]# curl http://192.168.4.5            //使用该命令多次访问查看效果

         3.配置upstream服务器集群池属性
             1）设置失败次数，超时时间，权重
                weight可以设置后台服务器的权重，max_fails可以设置后台服务器的失败次数，fail_timeout可以设置后台服务器的失败超时时间。
                [root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
                .. ..
                http {
                .. ..
                upstream webserver {
                           ####这里端口默认可以不写(80)         失败多少次后认为失败    超时(检测服务失败后重新开始检测的时间)
                                server 192.168.2.100 weight=1 max_fails=1 fail_timeout=30;
                                server 192.168.2.200 weight=2 max_fails=2 fail_timeout=30;
                                ####彻底关闭2.101的集群服务
                                server 192.168.2.101 down;
                                ip_hash; ###客户端访问网页后,之后的访问依然又第一次提供服务的server提供,除非该server挂了
                        }
                #weight设置服务器权重值，默认值为1
                #max_fails设置最大失败次数
                #fail_timeout设置失败超时时间，单位为秒
                #down标记服务器已关机，不参与集群调度
                .. ..
                server {
                        listen        80;
                        server_name  localhost;
                            location / {
                            proxy_pass http://webserver;
                        }
                }

             2）重启nginx服务
                [root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
                #请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
                #[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)

             3）关闭一台后端服务器（如web1）
                [root@web1 ~]# systemctl stop httpd

             4）客户端使用浏览器访问代理服务器测试轮询效果
                [root@client ~]# curl http://192.168.4.5            //使用该命令多次访问查看效果
             5)重启web1,再次进行测试
                [root@client ~]# curl http://192.168.4.5            //使用该命令多次访问查看效果

    Nginx的TCP/UDP调度器
         实现4层负载均衡
         问题

            使用Nginx实现TCP/UDP调度器功能，实现如下功能：
            后端SSH服务器两台
            Nginx编译安装时需要使用--with-stream，开启ngx_stream_core_module模块
            Nginx采用轮询的方式调用后端SSH服务器
         方案

            使用4台RHEL7虚拟机，其中一台作为Nginx代理服务器，该服务器需要配置两块网卡，
            IP地址分别为192.168.4.5和192.168.2.5，两台SSH服务器IP地址分别为192.168.2.100和192.168.2.200。
            客户端测试主机IP地址为192.168.4.10。

         步骤
         1.部署支持4层TCP/UDP代理的Nginx服务器
           1)部署nginx服务器

                编译安装必须要使用--with-stream参数开启4层代理模块。
                [root@proxy ~]# yum -y install gcc pcre-devel openssl-devel        //安装依赖包
                [root@proxy ~]# tar  -xf   nginx-1.12.2.tar.gz
                [root@proxy ~]# cd  nginx-1.12.2
                [root@proxy nginx-1.12.2]# ./configure   \
                > --with-http_ssl_module                                //开启SSL加密功能
                > --with-stream                                       //开启4层反向代理功能
                [root@proxy nginx-1.12.2]# make && make install           //编译并安装

         2.配置Nginx服务器，添加服务器池，实现TCP/UDP反向代理功能
            1)修改/usr/local/nginx/conf/nginx.conf配置文件
            ########################################################################
                注意这段配置文件应该在http 之前 ;;; 若写在 http中则会使用 http协议来传输数据
            ##########################################################################
                [root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
                stream {
                            upstream backend {
                               server 192.168.2.100:22;            //后端SSH服务器的IP和端口
                               server 192.168.2.200:22;
                }
                            server {
                                listen 12345;                    //Nginx监听的端口
                                proxy_connect_timeout 1s;         //连接的超时时间，可选配置
                                proxy_timeout 3s;
                                 proxy_pass backend;
                             }
                }
                http {
                .. ..
                }
            2)重启nginx服务
                [root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
                #请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
                #[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)


            3）客户端使用访问代理服务器测试轮询效果
                [root@client ~]# ssh 192.168.4.5 -p 12345            //使用该命令多次访问查看效果

    Nginx常见问题处理
         问题

            本案例要求对Nginx服务器进行适当优化，解决如下问题，以提升服务器的处理性能：
            如何自定义返回给客户端的404错误页面
            如何查看服务器状态信息
            如果客户端访问服务器提示“Too many open files”如何解决
            如何解决客户端访问头部信息过长的问题
            如何让客户端浏览器缓存数据

            日志切割(重要)

            开启gzip压缩功能，提高数据传输效率
            开启文件缓存功能
            然后客户机访问此Web服务器验证效果：
            使用ab压力测试软件测试并发量
            编写测试脚本生成长头部信息的访问请求
            客户端访问不存在的页面，测试404错误页面是否重定向

         步骤
         1.自定义报错页面
            1)优化前，客户端使用浏览器访问不存在的页面，会提示404文件未找到
                [root@client ~]# firefox http://192.168.4.5/xxxxx        //访问一个不存在的页面
            2）修改Nginx配置文件，自定义报错页面
                [root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
                .. ..
                        charset utf-8;                    //仅需要中文时需要改选项，可选项
                error_page   404  /404.html;    //自定义错误页面
                .. ..
                [root@proxy ~]# vim /usr/local/nginx/html/404.html        //生成错误页面
                Oops,No NO no page …
                [root@proxy ~]# nginx -s reload
                #请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
                #[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)

            3）优化后，客户端使用浏览器访问不存在的页面，会提示自己定义的40x.html页面
                [root@client ~]# firefox http://192.168.4.5/xxxxx        //访问一个不存在的页面

          ###############################################################################

         2.如何查看服务器状态信息（非常重要的功能）
            服务器状态信息
                1.实时并发量
                2.等待的数量
                3.总链接数量
                4.pv量和uv量 需要自己写脚本
                  page view
                  user view

                Web 集群并发量
 因素一：服务器网络带宽
 因素二：服务器系统内存（注意是内存不是硬盘哦）
 因素三：web容器
 因素四：程序代码

1：服务器网络带宽
       假如你的服务器带宽是5M，如果你的http求头是8k，那么你的服务器最大并发数是 5M/8k =640
2：操作系统内存
        假如你的操作系统内存是8G，如果你的每个请求占用内存256K，
        那么你的服务器最大支持并发数就是8G/256K=32758。这就是为啥购买服务器，内存越大，
        配置越高 支持的并发数越大的原因（当然money越多）。
3：web容器
       web容器的选择和配置也是至关重要的，比如说tomcat 的 baseio 和nio的区别就很大，
        tomcat配置一般启用的是线程池，maxThreads 一般配置为操作系统支持的最大并发数
4：程序代码
        程序代码放到第四才介绍，可见他的重要性，做了这么多年的程序猿，以前要是想提高并发，我总是抓破头皮的想如何提高代码质量，
        其实他别不那么重要（也许这样说你会感到很沮丧），更直接的且有效的方式就是提高服务器的配置即。
        但是，代码质量也是起着不可小觑的作用的，通常在所有的硬件条件都确定的情况下，
        入门级测试并发工具是 loaderrunner，我们通常挑选系统常用且耗资源的请求来测试，即可得到我们软件的并发量了。
            1）编译安装时使用--with-http_stub_status_module开启状态页面模块
                [root@proxy ~]# tar  -zxvf   nginx-1.12.2.tar.gz
                [root@proxy ~]# cd  nginx-1.12.2
                [root@proxy nginx-1.12.2]# ./configure   \
                > --with-http_ssl_module                        //开启SSL加密功能
                > --with-stream                                //开启TCP/UDP代理模块
                > --with-http_stub_status_module                //开启status状态页面 Nginx监控模块
                [root@proxy nginx-1.12.2]# make && make install    //编译并安装

            2）启用Nginx服务并查看监听端口状态
                ss命令可以查看系统中启动的端口信息，该命令常用选项如下：
                -a显示所有端口的信息
                -n以数字格式显示端口号
                -t显示TCP连接的端口
                -u显示UDP连接的端口
                -l显示服务正在监听的端口信息，如httpd启动后，会一直监听80端口
                -p显示监听端口的服务名称是什么（也就是程序名称）
                注意：在RHEL7系统中可以使用ss命令替代netstat命令，功能一样，选项一样。

                [root@proxy ~]# /usr/local/nginx/sbin/nginx
                [root@proxy ~]# netstat  -anptu  |  grep nginx
                tcp        0        0 0.0.0.0:80        0.0.0.0:*        LISTEN        10441/nginx
                [root@proxy ~]# ss  -anptu  |  grep nginx
            3）修改Nginx配置文件，定义状态页面
                [root@proxy ~]# cat /usr/local/nginx/conf/nginx.conf
                … …
                location /status {
                                stub_status on;
                                 #allow IP地址;
                                 #deny IP地址;
                        }
                … …
                [root@proxy ~]# nginx

            4）优化后，查看状态页面信息
                [root@proxy ~]# curl  http://192.168.4.5/status
                Active connections: 1
                server accepts handled requests
                 10 10 3
                Reading: 0 Writing: 1 Waiting: 0
            #######################################################
                Active connections：当前活动的连接数量。
                Accepts：已经接受客户端的连接总数量。
                Handled：已经处理客户端的连接总数量。
                （一般与accepts一致，除非服务器限制了连接数量）。
                Requests：客户端发送的请求数量。
                Reading：当前服务器正在读取客户端请求头的数量。
                Writing：当前服务器正在写响应信息的数量。
                Waiting：当前多少客户端在等待服务器的响应

         3.优化Nginx并发量
            nginx优化
            操作系统的资源限制
            软件限制(samba,nginx)
            这两者来管理 软件所占用的资源
            ulimit -a
            查看系统 资源限制
                [root@proxy ~]# ulimit -a
                [root@proxy ~]# ulimit -a
                    core file size          (blocks, -c) 0
                    data seg size           (kbytes, -d) unlimited
                    scheduling priority             (-e) 0
                    file size               (blocks, -f) unlimited
                    pending signals                 (-i) 5569
                    max locked memory       (kbytes, -l) 64
                    max memory size         (kbytes, -m) unlimited
                    open files                      (-n) 1024
                    pipe size            (512 bytes, -p) 8
                    POSIX message queues     (bytes, -q) 819200
                    real-time priority              (-r) 0
                    stack size              (kbytes, -s) 8192
                    cpu time               (seconds, -t) unlimited
                    max user processes              (-u) 5569
                    virtual memory          (kbytes, -v) unlimited
                    file locks                      (-x) unlimited
                #########修改硬限制#################################### (决断值)
                [root@proxy ~]# ulimit -Hn 100000
                #########修改软限制#####################################(警告值)
                [root@proxy ~]# ulimit -Sn 100000
                [root@proxy ~]# ulimit -a
                    core file size          (blocks, -c) 0
                    data seg size           (kbytes, -d) unlimited
                    scheduling priority             (-e) 0
                    file size               (blocks, -f) unlimited
                    pending signals                 (-i) 5569
                    max locked memory       (kbytes, -l) 64
                    max memory size         (kbytes, -m) unlimited
                ########################################################
                    open files                      (-n) 100000
                    pipe size            (512 bytes, -p) 8
                ########################################################
                    POSIX message queues     (bytes, -q) 819200
                    real-time priority              (-r) 0
                    stack size              (kbytes, -s) 8192
                    cpu time               (seconds, -t) unlimited
                    max user processes              (-u) 5569
                    virtual memory          (kbytes, -v) unlimited
                    file locks                      (-x) unlimited

            1）优化前使用ab高并发测试
                [root@proxy ~]# ab -n 2000 -c 2000 http://192.168.4.5/
                Benchmarking 192.168.4.5 (be patient)
                socket: Too many open files (24)                //提示打开文件数量过多
            2）修改Nginx配置文件，增加并发量
                [root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
                .. ..
                worker_processes  2;                    //与CPU核心数量一致
                events {
                worker_connections 65535;        //每个worker最大并发连接数
                }
                .. ..
                [root@proxy ~]# nginx -s reload

            3）优化Linux内核参数（最大文件数量）
                [root@proxy ~]# ulimit -a                        //查看所有属性值
                [root@proxy ~]# ulimit -Hn 100000                //设置硬限制（临时规则）
                [root@proxy ~]# ulimit -Sn 100000                //设置软限制（临时规则）
                ################## 永久限制 ###############################
                [root@proxy ~]# vim /etc/security/limits.conf
                    .. ..
                *               soft    nofile            100000
                *               hard    nofile            100000
                #该配置文件分4列，分别如下：
                #用户或组    硬限制或软限制    需要限制的项目   限制的值
            4）优化后测试服务器并发量（因为客户端没调内核参数，所以在proxy测试）
                ab命令最多支持2w并发
                [root@proxy ~]# ab -n 2000 -c 2000 http://192.168.4.5/
         4.优化Nginx数据包头缓存
            1）优化前，使用脚本测试长头部请求是否能获得响应
                [root@proxy ~]# cat lnmp_soft/buffer.sh
                    #!/bin/bash
                    URL=http://192.168.4.5/index.html?
                    for i in {1..5000}
                    do
                        URL=${URL}v$i=$i
                    done
                    curl $URL                                //经过5000次循环后，生成一个长的URL地址栏
                    [root@proxy ~]# ./buffer.sh
                    .. ..
                    <center><h1>414 Request-URI Too Large</h1></center>        //提示头部信息过大

            2）修改Nginx配置文件，增加数据包头部缓存大小
                [root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
                    .. ..
                    http {
                    client_header_buffer_size    1k;        //默认请求包头信息的缓存
                    large_client_header_buffers  4 4k;        //大请求包头部信息的缓存个数与容量
                    .. ..
                    }
                    [root@proxy ~]# nginx -s reload
                    3）优化后，使用脚本测试长头部请求是否能获得响应
                    [root@proxy ~]#cat cat buffer.sh
                    #!/bin/bash
                    URL=http://192.168.4.5/index.html?
                    for i in {1..5000}
                    do
                        URL=${URL}v$i=$i
                        done
                    curl $URL
                [root@proxy ~]# ./buffer.sh



         5.浏览器本地缓存静态数据
            1)浏览器具有缓存功能,但  缓存什么 缓存多久 则是由 服务器决定
                浏览器访问 查看缓存
                about:cache

            2）清空firefox本地缓存数据

            3）修改Nginx配置文件，定义对静态页面的缓存时间
                [root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
                server {
                        listen       80;
                        server_name  localhost;
                        location / {
                            root   html;
                            index  index.html index.htm;
                        }
                location ~* \.(jpg|jpeg|gif|png|css|js|ico|xml)$ {
                expires        30d;            //定义客户端缓存时间为30天
                }
                }
                [root@proxy ~]# cp /usr/share/backgrounds/day.jpg /usr/local/nginx/html
                [root@proxy ~]# nginx -s reload
                #请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
                #[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
            4）优化后，使用Firefox浏览器访问图片，再次查看缓存信息
                [root@client ~]# firefox http://192.168.4.5/day.jpg

                在firefox地址栏内输入about:cache，查看本地缓存数据，查看是否有图片以及过期时间是否正确。


         6.日志切割(重要)
            日志文件越来越大怎么办？单个文件10G? 如何切割？（非常常见的面试题）
            步骤：

            (1) 把旧的日志重命名
            (2) kill USR1 PID(nginx的进程PID号)   kill,(设计用来传递信息), 命令有许多功能 杀进程只是其中一个

            1）手动执行
                备注：/usr/local/nginx/logs/nginx.pid文件中存放的是nginx的进程PID号。
                [root@proxy ~]#  mv access.log access2.log
                [root@proxy ~]# kill -USR1 $(cat /usr/local/nginx/logs/nginx.pid)
            2）自动完成
                每周5的03点03分自动执行脚本完成日志切割工作。
                [root@proxy ~]# vim /usr/local/nginx/logbak.sh
                    #!/bin/bash
                    date=`date +%Y%m%d`
                    logpath=/usr/local/nginx/logs
                    mv $logpath/access.log $logpath/access-$date.log
                    mv $logpath/error.log $logpath/error-$date.log
                    kill -USR1 $(cat $logpath/nginx.pid)
                    [root@proxy ~]# crontab -e
                    03 03 * * 5  /usr/local/nginx/logbak.sh

         7.页面进行压缩处理
                所有主流浏览器支持gzip 压缩
                 小于 1000字节的文件 不压缩
                1）修改Nginx配置文件
                    [root@proxy ~]# cat /usr/local/nginx/conf/nginx.conf
                    http {
                    .. ..
                    gzip on;                            //开启压缩
                    gzip_min_length 1000;                //小文件不压缩
                    gzip_comp_level 4;                //压缩比率
                    gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;
                                                        //对特定文件压缩，类型参考mime.types
                    .. ..
                    }

         8.服务器内存缓存
                  加速用户读取 网页 ,默认不开启.
                1）如果需要处理大量静态文件，可以将文件缓存在(服务器)内存，下次访问会更快。
                http {
                open_file_cache          max=2000  inactive=20s;
                        open_file_cache_valid    60s;
                        open_file_cache_min_uses 5;
                        open_file_cache_errors   off;
                //设置服务器最大缓存2000个文件句柄，关闭20秒内无请求的文件句柄
                //文件句柄的有效时间是60秒，60秒后过期
                //只有访问次数超过5次会被缓存
                }

    Session与Cookie 、 部署memcached 、 Session共享
            通过Nginx调度器负载后端两台Web服务器，实现以下目标：
            部署Nginx为前台调度服务器
            调度算法设置为轮询
            后端为两台LNMP服务器
            部署测试页面，查看PHP本地的Session信息

         1.PHP的本地Session信息
            注册                           写数据
           clients ---------------------> server
            登录                          vim uuid.txt(session)
                                          tom,logined:true/f
            cookie <----------------------
           session: 储存在服务器端,保护用户名登录信息
           cookies: 储存在本地用户,由服务器下发给客户端,保存在客户端的一个文件中
           session和cookie是为了解决 用户登录状态
         搭建集群后 用户的登录会出现问题
            1)部署后端LNMP服务器相关软件(这里跳过)
            2)构建memcached服务
               安装memcached软件，并启动服务
               使用telnet测试memcached服务
               对memcached进行增、删、改、查等操

                验证时需要客户端主机安装telnet，远程memcached来验证服务器的功能：
                add name 0 180 10	//变量不存在则添加
                set name 0 180 10	//添加或替换变量
                replace name 0 180 10	//替换
                get name	//读取变量
                append name 0 180 10	//向变量中追加数据
                delete name	//删除变量
                flush_all	//清空所有
                提示：0表示不压缩，180为数据缓存时间，10为需要存储的数据字节数量。

            构建memcached服务

                (1）使用yum安装软件包memcached
                    [root@proxy ~]# yum -y  install   memcached
                    [root@proxy ~]# rpm -qa memcached
                    memcached-1.4.15-10.el7_3.1.x86_64
                (2) memcached配置文件（查看即可，不需要修改）
                    [root@proxy ~]# vim /usr/lib/systemd/system/memcached.service
                    ExecStart=/usr/bin/memcached -u $USER -p $PORT -m $CACHESIZE -c $MAXCONN $OPTIONS
                    [root@proxy ~]# vim /etc/sysconfig/memcached
                    PORT="11211"
                    USER="memcached"
                    MAXCONN="1024"
                    CACHESIZE="64"
                    OPTIONS=""
                (3）启动服务并查看网络连接状态验证是否开启成功：
                    netstat命令可以查看系统中启动的端口信息，该命令常用选项如下：
                    -a显示所有端口的信息
                    -n以数字格式显示端口号
                    -t显示TCP连接的端口
                    -u显示UDP连接的端口
                    -l显示服务正在监听的端口信息，如httpd启动后，会一直监听80端口
                    -p显示监听端口的服务名称是什么（也就是程序名称）
                    注意：在RHEL7系统中，使用ss命令可以替代netstat，功能与选项一样。
                    [root@proxy ~]# systemctl  start  memcached
                    [root@proxy ~]# systemctl  status  memcached
                    [root@proxy ~]# netstat  -anptu  |  grep memcached
                    tcp    0    0 0.0.0.0:11211        0.0.0.0:*        LISTEN        2839/memcached
                    tcp    0    0 :::11211            :::*                LISTEN        2839/memcached
                    udp    0    0 0.0.0.0:11211        0.0.0.0:*                    2839/memcached
                    udp    0    0 :::11211            :::*                            2839/memcached
                    [root@proxy ~]# setenforce 0
                    [root@proxy ~]# firewall-cmd --set-default-zone=trusted
               使用telnet访问memcached服务器

                (4）使用yum安装telnet
                    [root@proxy ~]# yum -y install telnet
                (5)使用telnet连接服务器测试memcached服务器功能，包括增、删、改、查等操作。
                    [root@proxy ~]# telnet  192.168.4.5  11211
                    Trying 192.168.4.5...
                    ……
                    ##提示：0表示不压缩，180为数据缓存时间，3为需要存储的数据字节数量。
                    set name 0 180 3                //定义变量，变量名称为name
                    plj                            //输入变量的值，值为plj
                    STORED
                    get name                        //获取变量的值
                    VALUE name 0 3                 //输出结果
                    plj
                    END
                    ##提示：0表示不压缩，180为数据缓存时间，3为需要存储的数据字节数量。
                    add myname 0 180 10            //新建，myname不存在则添加，存在则报错
                    set myname 0 180 10            //添加或替换变量
                    replace myname 0 180 10        //替换，如果myname不存在则报错
                    get myname                    //读取变量
                    append myname 0 180 10        //向变量中追加数据
                    delete myname                    //删除变量
                    flush_all                        //清空所有
                    quit                            //退出登录

                                                             web1 + php-pecl-memcache  链接 memcache
                client-------------proxy+memcached-----------
                                                             wbe2 + php-pecl-memcache

         LNMP(php动态网站)+memcached

                沿用已经部署的 LNMP+memcached 网站平台,通过PHP页面实现对memcached服务器的数据操作，
                实现以下目标：

            为PHP安装memcache扩展
                创建PHP页面，并编写PHP代码，实现对memcached的数据操作
            1.方案

                如果希望使用PHP来操作memcached，注意必须要为PHP安装memcache扩展（php-pecl-memcache），否则PHP无法解析连接memcached的指令。客户端测试时需要提前安装telnet远程工具。
            2. 步骤

                实现此案例需要按照如下步骤进行。
                步骤一：创建PHP页面，使用PHP语言测试memcached服务

               1）部署测试页面
                    创建PHP首页文档/usr/local/nginx/html/index.php，测试页面可以参考lnmp_soft/php_scripts/mem.php。
                    注意：192.168.2.5是memcached数据库。
                     [root@web1 ~]# vim /usr/local/nginx/html/mem.php
                    <?php
                    $memcache=new Memcache;                //创建memcache对象
                    $memcache->connect('192.168.2.5',11211) or die ('could not connect!!');
                    $memcache->set('key','test');             //定义变量
                    $get_values=$memcache->get('key');        //获取变量值
                    echo $get_values;
                    ?>
               2）客户端测试（结果会失败）
                    客户端使用浏览器访问服务器PHP首页文档，检验对memcached的操作是否成功：
                    [root@web1 ~]# firefox http://192.168.2.100/mem.php
                    注意：这里因为没有给PHP安装扩展包，默认PHP无法连接memcached数据库，需要给PHP安装扩展模块才可以连接memcached数据库。
               3）为PHP添加memcache扩展
                    [root@web1 ~]# yum -y install  php-pecl-memcache
                    [root@web1 ~]# systemctl restart php-fpm
               4）客户端再次测试（结果会成功显示数据结果）
                    [root@web1 ~]# firefox http://192.168.2.100/mem.php
                     显示test
         PHP实现session共享
            目标: 实现web1 和 web2 将session 写入 proxy  中  并 必要时在 proxy读取session
                  Nginx服务器除了承担调度器外，还需要担任memcached数据库的角色，
                  并在两台后端LNMP服务器上实现PHP的session会话共享。

            1)为PHP添加memcache扩展
                注意，因为后端两台web服务器(web1,web2)都需要连接memcached数据库，所以两台主机都需要安装PHP扩展模块(下面也web1为例)。
                [root@web1 ~]# yum -y install  php-pecl-memcache
                注意：这里因为没有给PHP安装扩展包，默认PHP无法连接memcached数据库，需要给PHP安装扩展模块才可以连接memcached数据库。
            2）客户端测试（结果会失败）
                客户端使用浏览器访问服务器PHP首页文档，检验对memcached的操作是否成功：
                [root@web1 ~]# firefox http://192.168.2.100/test.php
            3）为PHP添加memcache扩展
                [root@web1 ~]# yum -y install  php-pecl-memcache
                [root@web1 ~]# systemctl restart php-fpm
            4）客户端再次测试（结果会成功显示数据结果）
                [root@web1 ~]# firefox http://192.168.2.100/test.php

          ###############################################################
         TOMCATE+JAVA
            jdk(jre是jdk的阉割版)开放技术
                安装部署JDK基础环境
                安装部署Tomcat服务器
                创建JSP测试页面，文件名为test.jsp，显示服务器当前时间
                访问Tomcat服务器的8080端口，浏览默认首页
            常见的servlet容器


            1.安装部署Tomcat服务器
                1)使用RPM安装JDK环境
                    [root@web1 ~]# yum -y install  java-1.8.0-openjdk                //安装JDK
                    [root@web1 ~]# yum -y install java-1.8.0-openjdk-headless        //安装JDK
                    [root@web1 ~]# java -version                                    //查看JAVA版本
                2）安装Tomcat（apache-tomcat-8.0.30.tar.gz软件包，在lnmp_soft中有提供）
                    [root@web1 ~]# tar -xf  apache-tomcat-8.0.30.tar.gz
                    [root@web1 ~]# mv apache-tomcat-8.0.30  /usr/local/tomcat
                    [root@web1 ~]# ls /usr/local/tomcat
                    bin/                                            //主程序目录
                    lib/                                            //库文件目录
                    logs/                                          //日志目录
                    temp/                                         //临时目录
                    work/                                        //自动编译目录jsp代码转换servlet
                    conf/                                        //配置文件目录
                    webapps/                                        //页面目录
                3）启动服务
                    [root@web1 ~]# /usr/local/tomcat/bin/startup.sh

                4）服务器验证端口信息
                    [root@web1 ~]# netstat -nutlp |grep java        //查看java监听的端口
                    tcp        0      0 :::8080              :::*                LISTEN      2778/java
                    tcp        0      0 ::ffff:127.0.0.1:8005     :::*         LISTEN       2778/java

                    TOMCATE每次启动都需要读取足够多的随机数据 所以会造成8005 端口的服务起不来
                    提示：如果检查端口时，8005端口启动非常慢，可用使用下面的命令用urandom替换random（非必须操作）。
                    [root@web1 ~]# mv /dev/random  /dev/random.bak
                    [root@web1 ~]# ln -s /dev/urandom  /dev/random
                5）客户端浏览测试页面(proxy作为客户端)
                    [root@proxy ~]# firefox http://192.168.2.100:8080


            (2).修改Tomcat配置文件
                1）创建测试JSP页面
                    [root@web1 ~]# vim  /usr/local/tomcat/webapps/ROOT/test.jsp
                    <html>
                    <body>
                    <center>
                    Now time is: <%=new java.util.Date()%>            //显示服务器当前时间
                    </center>
                    </body>
                    </html>
                2）重启服务
                    [root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
                    [root@web1 ~]# /usr/local/tomcat/bin/startup.sh


            (3)验证测试
                1) 测试
                    [root@proxy ~]# firefox http://192.168.2.100:8080
                    [root@proxy ~]# firefox 使用Tomcat部署虚拟主机http://192.168.2.100:8080/test.jsp



            2.使用Tomcat部署虚拟主机(基于域名的虚拟主机)
                目标:
                    实现两个基于域名的虚拟主机，域名分别为：www.a.com和 www.b.com
                    使用www.a.com域名访问的页面根路径为/usr/local/tomcat/a/ROOT
                    使用www.b.com域名访问的页面根路径为/usr/local/tomcat/b/base
                    访问www.a.com/test时，页面自动跳转到/var/www/html目录下的页面
                    访问页面时支持SSL加密通讯
                    私钥、证书存储路径为/usr/local/tomcat/conf/cert
                    每个虚拟主机都拥有独立的访问日志文件
                    配置tomcat集群环境
                TOMCATE 修改 conf的 server.conf
                    中参数

                        <Host name="www.a.com"  appBase="a"
                        unpackWARs="true" autoDeploy="true">
                        </Host>

                        # cat /usr/local/tomcat/conf/server.xml
                        <Server>
                           <Service>
                             <Connector port=8080 />
                             <Connector port=8009 />
                             <Engine name="Catalina" defaultHost="localhost">
                        <Host name="www.a.com" appBase="a" unpackWARS="true" autoDeploy="true">
                        </Host>
                        <Host name="www.b.com" appBase="b" unpackWARS="true" autoDeploy="true">
                        </Host>

                (1)配置服务器虚拟主机
                    1）修改server.xml配置文件，创建虚拟主机
                        [root@web1 ~]# vim /usr/local/tomcat/conf/server.xml
                        … …
                        <Host name="www.a.com" appBase="a" unpackWARS="true" autoDeploy="true">
                        </Host>
                        <Host name="www.b.com" appBase="b" unpackWARS="true" autoDeploy="true">
                        </Host>
                    2）创建虚拟主机对应的页面根路径
                        [root@web1 ~]# mkdir -p  /usr/local/tomcat/{a,b}/ROOT
                        [root@web1 ~]# echo "AAA"   > /usr/local/tomcat/a/ROOT/index.html
                        [root@web1 ~]# echo "BBB" > /usr/local/tomcat/b/ROOT/index.html

                    3）重启Tomcat服务器
                        [root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
                        [root@web1 ~]# /usr/local/tomcat/bin/startup.sh
                    4)客户端设置host文件，并浏览测试页面进行测试(proxy充当客户端角色)
                        [root@proxy ~]# vim /etc/hosts
                        … …
                        192.168.2.100      www.a.com  www.b.com
                        [root@proxy ~]# firefox http://www.a.com:8080/        //注意访问的端口为8080
                        [root@proxy ~]# firefox http://www.b.com:8080/
                (2)修改www.b.com网站的首页目录为base

                    1）使用docBase参数可以修改默认网站首页路径
                        [root@web1 ~]# vim /usr/local/tomcat/conf/server.xml
                        … …
                        <Host name="www.a.com" appBase="a" unpackWARS="true" autoDeploy="true">
                        #########################################################3
                        curl www.a.com/test/ 显示 /var/www/html的 index.html页面
                        #######################################################
                        <Context path="/test" docBase="/var/www/html"/>
                        ################
                        </Host>
                        <Host name="www.b.com" appBase="b" unpackWARS="true" autoDeploy="true">
                        #############################
                        curl www.b.com 显示 base
                        <Context path="" docBase="base"/>
                        </Host>
                        … …
                        [root@web1 ~]# mkdir  /usr/local/tomcat/b/base
                        [root@web1 ~]# echo "BASE" > /usr/local/tomcat/b/base/index.html
                        [root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
                        [root@web1 ~]# /usr/local/tomcat/bin/startup.sh
                    2）测试查看页面是否正确(proxy充当客户端角色)
                        [root@proxy ~]# firefox http://www.b.com:8080/        //结果为base目录下的页面内容


                        TOMCATE的 https 默认做一次 就会给 全部的 虚拟主机启用加密
                        也就说 TOMCATE 不会将端口绑定到虚拟主机(端口只负责转发),

                (3)HTTPS网站加密
                    1)创建加密用的私钥和证书文件
                        [root@web1 ~]# keytool -genkeypair -alias tomcat -keyalg RSA -keystore /usr/local/tomcat/keystore                //提示输入密码为:123456
                        //-genkeypair     生成密钥对
                        //-alias tomcat     密钥别名
                        //-keyalg RSA     定义密钥算法为RSA算法
                        //-keystore         定义密钥文件存储在:/usr/local/tomcat/keystore
                    2)再次修改server.xml配置文件，创建支持加密连接的Connector
                        [root@web1 ~]# vim /usr/local/tomcat/conf/server.xml
                        … …
                        84 行左右
                        <Connector port="8443" protocol="org.apache.coyote.http11.Http11NioProtocol"
                        maxThreads="150" SSLEnabled="true" scheme="https" secure="true"
                    ######添加秘钥文件信息 和密码信息 默认没有需要手写
                        keystoreFile="/usr/local/tomcat/keystore" keystorePass="123456" clientAuth="false" sslProtocol="TLS" />
                        //备注，默认这段Connector被注释掉了，打开注释，添加密钥信息即可
                    3）重启Tomcat服务器
                        [root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
                        [root@web1 ~]# /usr/local/tomcat/bin/startup.sh
                    4）客户端设置host文件，并浏览测试页面进行测试(proxy充当客户端角色)
                        [root@proxy ~]# vim /etc/hosts
                        … …
                        192.168.2.100      www.a.com  www.b.com
                        [root@proxy ~]# firefox https://www.a.com:8443/
                        [root@proxy ~]# firefox https://www.b.com:8443/
                        [root@proxy ~]# firefox https://192.168.2.100:8443/

                (4)配置Tomcat日志

                    1)为每个虚拟主机设置不同的日志文件
                        [root@web1 ~]# vim /usr/local/tomcat/conf/server.xml
                        .. ..
                        <Host name="www.a.com" appBase="a" unpackWARS="true" autoDeploy="true">
                        <Context path="/test" docBase="/var/www/html/" />
                        #从默认localhost虚拟主机中把Valve这段复制过来，适当修改下即可
                        <Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"
                                       prefix=" a_access" suffix=".txt"
                                       pattern="%h %l %u %t &quot;%r&quot; %s %b" />
                        </Host>
                        <Host name="www.b.com" appBase="b" unpackWARS="true" autoDeploy="true">
                        <Context path="" docBase="base" />
                        <Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"
                                       prefix=" b_access" suffix=".txt"
                                       pattern="%h %l %u %t &quot;%r&quot; %s %b" />
                        </Host>
                        .. ..
                    2）重启Tomcat服务器
                        [root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
                        [root@web1 ~]# /usr/local/tomcat/bin/startup.sh
                    3）查看服务器日志文件
                        [root@web1 ~]# ls /usr/local/tomcat/logs/
            3.配置Tomcat集群

                    1) 在192.168.4.5主机上配置Nginx调度器（具体安装步骤参考前面的章节）
                        [root@proxy ~]# vim  /usr/local/nginx/conf/nginx.conf
                        http{
                            upstream toms {
                                server 192.168.2.100:8080;
                                server 192.168.2.200:8080;
                            }
                            server  {
                                listen 80;
                                server_name localhost;
                                location / {
                                    proxy_pass  http://toms;
                                }
                            }
                        }
                    2) 在192.168.2.100和192.168.2.200主机上配置Tomcat调度器
                        以下以Web1为例：
                        [root@web1 ~]# yum -y install  java-1.8.0-openjdk                //安装JDK
                        [root@web1 ~]# yum -y install java-1.8.0-openjdk-headless        //安装JDK
                        [root@web1 ~]# tar -xzf  apache-tomcat-8.0.30.tar.gz
                        [root@web1 ~]# mv apache-tomcat-8.0.30  /usr/local/tomcat
                    3）启动服务
                        [root@web1 ~]# /usr/local/tomcat/bin/startup.sh
                    4) 客户端验证
                        为了防止有数据缓存，可以使用真实主机的google-chrome访问代理服务器，输入Ctrl+F5刷新页面。

            4.使用Varnish加速Web
                    目标

                    通过配置Varnish缓存服务器，实现如下目标：
                    使用Varnish加速后端Web服务
                    代理服务器可以将远程的Web服务器页面缓存在本地
                    远程Web服务器对客户端用户是透明的
                    利用缓存机制提高网站的响应速度
                    使用varnishadm命令管理缓存页面
                    使用varnishstat命令查看Varnish状态
                    3.2 方案

                    通过源码编译安装Varnish缓存服务器
                    编译安装Varnish软件
                    修改配置文件，缓存代理源Web服务器，实现Web加速功能
                    使用3台RHEL7虚拟机，其中一台作为Web服务器（192.168.2.100）、一台作为Varnish代理服务器（192.168.4.5,192.168.2.5)，
                    另外一台作为测试用的Linux客户机（192.168.4.10）


                    对于Web服务器的部署，此实验中仅需要安装nginx或者httpd软件、启动服务，并生成测试首页文件即可，
                    默认httpd网站根路径为/var/www/html，首页文档名称为index.html，
                    默认nginx网站根路径为/usr/local/nginx/html，默认首页为index.html。下面的实验我们以httpd为例作为Web服务器。



                (1)构建Web服务器

                    1）使用yum安装web软件包
                        [root@web1 ~]# yum  -y  install  httpd
                    2）启用httpd服务（注意需要关闭nginx，否则端口冲突）
                        [root@web1 ~]# systemctl start httpd
                        httpd服务默认通过TCP 80端口监听客户端请求：
                        [root@web1 ~]# netstat  -anptu  |  grep httpd
                        tcp        0        0        :::80        :::*        LISTEN        2813/httpd
                    3）为Web访问建立测试文件
                        在网站根目录/var/www/html下创建一个名为index.html的首页文件：
                        [root@web1 ~]# cat /var/www/html/index.html
                        192.168.2.100
                    4）测试页面是否正常（代理服务器测试后台web）
                        [root@proxy ~]# firefox http://192.168.2.100
                (2)部署Varnish缓存服务器(192.168.4.5)

                    1）编译安装软件
                        [root@proxy ~]# yum -y install gcc readline-devel    //安装软件依赖包
                        [root@proxy ~]# yum -y install ncurses-devel         //安装软件依赖包
                        [root@proxy ~]# yum -y install pcre-devel            //安装软件依赖包
                        [root@proxy ~]# yum -y install python-docutils         //安装软件依赖包
                         [root@proxy ~]# useradd -s /sbin/nologin varnish                //创建账户
                        [root@proxy ~]# tar -xf varnish-5.2.1.tar.gz      /linux-soft/02/lnmp_soft.tar.gz
                        [root@proxy ~]# cd varnish-5.2.1
                        [root@proxy varnish-5.2.1]# ./configure
                        [root@proxy varnish-5.2.1]# make && make install
                    2）复制启动脚本及配置文件
                        [root@proxy varnish-5.2.1]# cp  etc/example.vcl   /usr/local/etc/default.vcl
                    3）修改代理配置文件
                        [root@proxy ~]# vim  /usr/local/etc/default.vcl
                        backend default {
                             .host = "192.168.2.100";
                             .port = "80";
                         }
                    4）启动服务
                         [root@proxy ~]# varnishd  -f /usr/local/etc/default.vcl
                        //varnishd命令的其他选项说明如下：
                        //varnishd -s malloc,128M        定义varnish使用内存作为缓存，空间为128M
                        //varnishd -s file,/var/lib/varnish_storage.bin,1G 定义varnish使用文件作为缓存
                (3)客户端测试

                    1）客户端开启浏览器访问
                        [root@client ~]# curl http://192.168.4.5
                (4)其他操作

                    1）查看varnish日志
                        [root@proxy ~]# varnishlog                        //varnish日志
                        [root@proxy ~]# varnishncsa                    //访问日志
                    2）更新缓存数据，在后台web服务器更新页面内容后，用户访问代理服务器看到的还是之前的数据，说明缓存中的数据过期了需要更新（默认也会自动更新，但非实时更新）。
                        [root@proxy ~]# varnishadm
                        varnish> ban req.url ~ .*
                        //清空缓存数据，支持正则表达式
    Git

         Git基本操作
            1.配置git服务器
                目标
                安装Git软件
                创建版本库
                客户端克隆版本仓库到本地
                本地工作目录修改数据
                提交本地修改到服务器

                方案
                1）YUM安装Git软件。
                    [root@web1 ~]# yum -y install git
                    [root@web1 ~]# git --version
                2) 初始化一个空仓库。
                    [root@web1 ~]# mkdir /var/git
                    [root@web1 ~]# git init /var/git/project --bare
                    [root@web1 ~]# ls /var/git/
                    config  description  HEAD  hooks  info  objects  refs

            2. 客户端测试 192.168.2.200
                 常用指令
                    clone  将远程服务器的仓库克隆到本地
                    config 修改git配置
                    add    添加修改到暂存区
                    commit 提交修改到本地仓库
                    push   提交的远程服务器
                    checkout 切换分支
                1) clone克隆服务器仓库到本地。
                    [root@web2 ~]# yum -y install git
                    [root@web2 ~]# git clone root@192.168.2.100 :/var/git/project
                    [root@web2 ~]# cd project
                    [root@web2 ~]# ls
                2) 修改git配置。
                    [root@web2 project]# git config --global user.email "you@example.com"
                    [root@web2 project]# git config --global user.name "Your Name"
                    [root@web2 project]# cat ~/.gitconfig
                    [user]
                        email = you@example.com
                        name = Your Name
                3） 本地工作区对数据进行增删改查(必须要先进入仓库再操作数据)。
                    [root@web2 project]# echo "init date" > init.txt
                    [root@web2 project]# mkdir demo
                    [root@web2 project]# cp /etc/hosts demo
                4） 查看仓库中数据的状态。
                    [root@web2 project]# git status
                5） 将工作区的修改提交到暂存区。
                    [root@web2 project]# git add .
                6) 将暂存区修改提交到本地仓库。
                    [root@web2 project]# git commit  -m  "注释，可以为任意字符"
                    [root@web2 project]# git status
                7） 将本地仓库中的数据推送到远程服务器(web2将数据推送到web1)。
                    [root@web2 project]# git config --global push.default simple
                    [root@web2 project]# git push
                    root@192.168.2.100's password:  输入服务器root密码
                    [root@web2 project]# git status
                8) 将服务器上的数据更新到本地（web1的数据更新到web2）。
                    备注：可能其他人也在修改数据并提交服务器，就会导致自己的本地数据为旧数据，使用pull就可以将服务器上新的数据更新到本地。
                    [root@web2 project]# git pull
                9) 查看版本日志。
                    [root@web2 project]# git log
                    [root@web2 project]# git log --pretty=oneline
                    [root@web2 project]# git log --oneline
                    [root@web2 project]# git reflog
                    备注：客户端也可以使用图形程序访问服务器。
            3.HEAD指针操作
                目标
                    查看Git版本信息
                    移动指针
                    通过移动HEAD指针恢复数据
                    合并版本
                方案
                    HEAD指针是一个可以在任何分支和版本移动的指针，
                    通过移动指针我们可以将数据还原至任何版本。
                    没做一次提交操作都会导致git更新一个版本，
                    HEAD指针也跟着自动移动
                HEAD指针基本操作

                1）准备工作（多对数据仓库进行修改、提交操作，以产生多个版本）。
                    [root@web2 project]# echo "new file" > new.txt
                    [root@web2 project]# git add .
                    [root@web2 project]# git commit -m "add new.txt"
                    [root@web2 project]# echo "first" >> new.txt
                    [root@web2 project]# git add .
                    [root@web2 project]# git commit -m "new.txt:first line"
                    [root@web2 project]# echo "second" >> new.txt
                    [root@web2 project]# git add .
                    [root@web2 project]# git commit -m "new.txt:second"
                    [root@web2 project]# echo "third" >> new.txt
                    [root@web2 project]# git add .
                    [root@web2 project]# git commit -m "new.txt:third"
                    [root@web2 project]# git push
                    [root@web2 project]# echo "123" > num.txt
                    [root@web2 project]# git add .
                    [root@web2 project]# git commit -m "num.txt:123"
                    [root@web2 project]# echo "456" > num.txt
                    [root@web2 project]# git add .
                    [root@web2 project]# git commit -m "num.txt:456"
                    [root@web2 project]# echo "789" > num.txt
                    [root@web2 project]# git add .
                    [root@web2 project]# git commit -m "num.txt:789"
                    [root@web2 project]# git push
                2) 查看Git版本信息。
                    [root@web2 project]# git reflog
                    [root@web2 project]# git log --oneline
                    04ddc0f num.txt:789
                    7bba57b num.txt:456
                    301c090 num.txt:123
                    b427164 new.txt:third
                    0584949 new.txt:second
                    ece2dfd new.txt:first line
                    e1112ac add new.txt
                    1a0d908 初始化
                3）移动HEAD指针，将数据还原到任意版本。
                    提示：当前HEAD指针为HEAD@{0}。
                    [root@web2 project]# git reset --hard 301c0
                    [root@web2 project]# git reflog
                    301c090 HEAD@{0}: reset: moving to 301c0
                    04ddc0f HEAD@{1}: commit: num.txt:789
                    7bba57b HEAD@{2}: commit: num.txt:456
                    301c090 HEAD@{3}: commit: num.txt:123
                    b427164 HEAD@{5}: commit: new.txt:third
                    0584949 HEAD@{6}: commit: new.txt:second
                    ece2dfd HEAD@{7}: commit: new.txt:first line
                    e1112ac HEAD@{8}: commit: add new.txt
                    1a0d908 HEAD@{9}: commit (initial): 初始化
                    [root@web2 project]# cat num.txt                #查看文件是否为123
                    123
                    [root@web2 project]# git reset --hard 7bba57b
                    [root@web2 project]# cat num.txt                #查看文件是否为123，456
                    123
                    456
                    [root@web2 project]# git reflog                #查看指针移动历史
                    7bba57b HEAD@{0}: reset: moving to 7bba57b
                    301c090 HEAD@{1}: reset: moving to 301c0
                    … …
                    [root@web2 project]# git reset --hard 04ddc0f    #恢复num.txt的所有数据
                4)模拟误删后的数据还原操作。
                    [root@web2 project]# git rm init.txt                    #删除文件
                    rm 'init.txt'
                    [root@web2 project]# git commit -m "delete init.txt"    #提交本地仓库
                    [root@web2 project]# git reflog                        #查看版本历史
                    0dc2b76 HEAD@{0}: commit: delete init.txt
                    7bba57b HEAD@{0}: reset: moving to 7bba57b
                    301c090 HEAD@{1}: reset: moving to 301c0
                    … …
                    [root@web2 project]# git reset --hard 04ddc0f            #恢复数据
                    [root@web2 project]# ls
                    demo  init.txt  new.txt  num.txt

            4.Git分支操作
                沿用上个练习，学习操作Git分支，具体要求如下：
                    查看分支
                    创建分支
                    切换分支
                    合并分支
                    解决分支的冲突
                Git支持按功能模块、时间、版本等标准创建分支，分支可以让开发分多条主线同时进行，每条主线互不影响

                常见的分支规范如下：
                    MASTER分支（MASTER是主分支，是代码的核心）。
                    DEVELOP分支（DEVELOP最新开发成果的分支）。
                    RELEASE分支（为发布新产品设置的分支）。
                    HOTFIX分支（为了修复软件BUG缺陷的分支）。
                    FEATURE分支（为开发新功能设置的分支）。

                (1)查看并创建分支

                1）查看当前分支。
                    [root@web2 project]# git status
                    # On branch master
                    nothing to commit, working directory clean
                    [root@web2 project]# git branch -v
                    * master 0dc2b76 delete init.txt
                2）创建分支。
                    [root@web2 project]# git branch hotfix
                    [root@web2 project]# git branch feature
                    [root@web2 project]# git branch -v
                      feature 0dc2b76 delete init.txt
                      hotfix  0dc2b76 delete init.txt
                    * master  0dc2b76 delete init.txt
                (2)切换与合并分支

                1）切换分支。
                    [root@web2 project]# git checkout hotfix ###切换分支
                    [root@web2 project]# git branch -v
                      feature 0dc2b76 delete init.txt
                    * hotfix  0dc2b76 delete init.txt
                    master  0dc2b76 delete init.txt
                2）在新的分支上可以继续进行数据操作（增、删、改、查）。
                    [root@web2 project]# echo "fix a bug" >> new.txt
                    [root@web2 project]# git add .
                    [root@web2 project]# git commit -m "fix a bug"
                3）将hotfix修改的数据合并到master分支。
                    注意，合并前必须要先切换到master分支，然后再执行merge命令。
                    [root@web2 project]# git checkout master
                    [root@web2 project]# cat new.txt        #默认master分支中没有hotfix分支中的数据
                    [root@web2 project]# git merge hotfix
                    Updating 0dc2b76..5b4a755
                    Fast-forward
                     new.txt | 1 ++
                     1 file changed, 1 insertions(+)
                4）将所有本地修改提交远程服务器。
                    [root@web2 project]# git push

                (3)解决版本分支的冲突问题

                1）在不同分支中修改相同文件的相同行数据，模拟数据冲突。
                    [root@web2 project]# git checkout hotfix
                    [root@web2 project]# echo "AAA" > a.txt
                    [root@web2 project]# git add .
                    [root@web2 project]# git commit -m "add a.txt by hotfix"
                    [root@web2 project]# echo "BBB" > a.txt
                    [root@web2 project]# git add .
                    [root@web2 project]# git commit -m "add a.txt by master"
                    自动合并 a.txt
                    冲突（添加/添加）：合并冲突于 a.txt
                    自动合并失败，修正冲突然后提交修正的结果。
                2）查看有冲突的文件内容，修改文件为最终版本的数据，解决冲突。
                    [root@web2 project]# cat a.txt                #该文件中包含有冲突的内容
                    <<<<<<< HEAD
                    BBB
                    =======
                    AAA
                    >>>>>>> hotfix
                    [root@web2 project]# vim a.txt              #修改该文件，为最终需要的数据，解决冲突
                    BBB
                    [root@web2 project]# git add .
                    [root@web2 project]# git commit -m "resolved"
                    总结：分支指针与HEAD指针的关系。
                    创建分支的本质是在当前提交上创建一个可以移动的指针
                    如何判断当前分支呢？答案是根据HEAD这个特殊指针



            Git服务器
                问题

                沿用练习三，学习Git不同的服务器形式，具体要求如下：
                创建SSH协议服务器
                创建Git协议服务器
                创建HTTP协议服务器
                方案

                Git支持很多服务器协议形式，不同协议的Git服务器，客户端就可以使用不同的形式访问服务器。
                创建的服务器协议有SSH协议、Git协议、HTTP协议。

            (1)：SSH协议服务器（支持读写操作）

                1）创建基于密码验证的SSH协议服务器（web1主机操作）。
                    [root@web1 ~]# git init --bare /var/git/base_ssh
                    Initialized empty Git repository in /var/git/base_ssh/
                2)客户端访问的方式（web2主机操作）。
                    [root@web2 ~]# git clone root@192.168.2.100:/var/git/base_ssh
                    [root@web2 ~]# rm -rf base_ssh
                3）客户端生成SSH密钥，实现免密码登陆git服务器（web2主机操作）。

                   将客户端生成的公钥 传递给 需要登录的机器, 本机保留私钥, 远程时通过 私钥解密.

                    -f 指定 id_rsa 文件位置
                    [root@web2 ~]# ssh-keygen -f /root/.ssh/id_rsa -N ''
                    [root@web2 ~]# ssh-copy-id  192.168.2.100
                    [root@web2 ~]# git clone root@192.168.2.100:/var/git
                    [root@web2 ~]# git push
                (2)Git协议服务器（只读操作的服务器）

                1）安装git-daemon软件包（web1主机操作）。
                    [root@web1 ~]# yum -y install git-daemon
                2）创建版本库（web1主机操作）。
                    [root@web1 ~]# git init --bare /var/git/base_git
                    Initialized empty Git repository in /var/git/base_git/
                3）修改配置文件，启动git服务（web1主机操作）。
                    [root@web1 ~]# vim /usr/lib/systemd/system/git@.service
                    修改前内容如下：
                    ExecStart=-/usr/libexec/git-core/git-daemon --base-path=/var/lib/git
                    --export-all --user-path=public_git --syslog --inetd –verbose
                    修改后内容如下：
                    ExecStart=-/usr/libexec/git-core/git-daemon --base-path=/var/git
                    --export-all --user-path=public_git --syslog --inetd –verbose
                    [root@web1 ~]# systemctl  start  git.socket
                4）客户端访问方式（web2主机操作）
                    [root@web2 ~]# git clone git://192.168.2.100/base_git
                (3)HTTP协议服务器（只读操作的服务器）

                    1）安装gitweb、httpd软件包（web1主机操作）。
                        [root@web1 ~]# yum -y install httpd gitweb
                    2）修改配置文件，设置仓库根目录（web1主机操作）。
                        [root@web1 ~]# vim +11 /etc/gitweb.conf  ###打开文件 后进入第 11 行
                        $projectroot = "/var/git";                        #添加一行
                    3) 创建版本仓库（web1主机操作）
                        [root@web1 ~]# git init --bare /var/git/base_http
                    4）启动httpd服务器
                        [root@web1 ~]# systemctl start httpd
                    5）客户端访问方式（web2主机操作）
                        注意：调用虚拟机中的firefox浏览器，需要在远程时使用ssh -X 服务器IP，并且确保真实主机的firefox已经关闭。
                        [root@web2 ~]# firefox http://192.168.2.100/git/
         制作nginx源码的RPM包(将源码包制作成rpm包)
            rpm就是一个压缩包
            方法
                安装 rpm-build
                1)yum -y install rpm-build
                生成 rpmbuild 目录及其文件
                2)rpmbuild -ba zone.spec
                    错误：stat /root/zone.spec 失败：没有那个文件或目录
                  ls rpmbuild/
                    BUILD  BUILDROOT  RPMS  SOURCES  SPECS  SRPMS
                想要谁的 rpm包就将 谁的源码tar放到/rpmbuild/source 目录下,修改配置文件(重要) 确认将谁 做成rpm包
                    cp /nginx-1.12.2.tar.gz .
                3)修改配置文件
                    该文件不存在但是当你敲完这个命令的时候将会出现文件的模板
                    vim /root/rpmbuild/SPECS/nginx.spec
                        Name:nginx                                        #源码包软件名称
                        Version:1.12.2                                    #源码包软件的版本号
                        Release:    10                                        #制作的RPM包版本号 默认为 1%{?dist}         #释出号，也就是第几次制作rpm
                        Summary: Nginx is a web server software.            #RPM软件的概述
                        License:GPL                                        #软件的协议
                        URL:    www.test.com                                    #网址
                        Source0:nginx-1.12.2.tar.gz                        #源码包文件的全称
                        #BuildRequires:                                    #制作RPM时的依赖关系,并不能解决依赖只能提示
                        #eg:#BuildRequires:   gcc,make
                        #Requires:                                        #安装RPM时的依赖关系
                        %description
                        nginx [engine x] is an HTTP and reverse proxy server.    #软件的详细描述
                        #下面的几步pre、post、preun、postun 没必要可以不写
                        %pre                                        #rpm安装前制行的脚本
                        %post                                       #安装后执行的脚本
                        useradd nginx                               #非必需操作：安装后脚本(创建账户,删根等危险操作 也可以执行,exe 同要的道理)
                        %preun                                      #卸载前执行的脚本
                        %postun                                     #卸载后执行的脚本
                        %prep                                       # 打包开始
                        %setup -q                                 #自动解压源码包，并cd进入目录
                        %build
                        ./configure
                        make %{?_smp_mflags}                        ###%{?_smp_mflags} 表示,若是多处理器就并行编译
                        %install
                        make install DESTDIR=%{buildroot}
                        %files
                        %doc
                        /usr/local/nginx/*                       #对哪些文件与目录打包
                        %changelog
                 打包 安装
                4)rpmbuild -ba /root/rpmbuild/SPECS/nginx.spec

                  yum -y install  gcc  pcre-devel openssl-devel zlib zlib-devel  automake autoconf  (编译的时候用到了pcre库)
                5) 安装
                  rpm -ivh RPMS/x86_64/nginx-1.12.2-10.x86_64.rpm
    VPN服务器
                vpn 虚拟专用网
                    在公网上建立专用的私有网络,进行加班通信,多用于集团公司的各地子公司建立链接
                    企业中广泛用于
                    可以用于 穿墙
                    主流软件  GRE  PPTP   L2TP+IPSec,SSL
                           不加密 部分加密  全部加密
         配置GRE VPN
            linux(默认支持) window(不支持) 网络设备默认支持
            要求
                启用内核模块ip_gre
                创建一个虚拟VPN隧道(10.10.10.0/24)
                实现两台主机点到点的隧道通讯
            方法
                使用lsmod查看当前计算机已经加载的模块，使用modprobe加载Linux内核模块，
                使用modinfo可以查看内核模块的信息。
                ip 设置
                    client  eth3 201.1.2.10/24
                    proxy  eth3 201.1.2.10/24
                    proxy  eth0 192.168.4.5/24
            1.启用GRE模块（client和proxy都需要操作）

                1）查看计算机当前加载的模块
                    [root@client ~]# lsmod                            //显示模块列表
                    [root@client ~]# lsmod  | grep ip_gre            //确定是否加载了gre模块
                2)加载模块ip_gre
                    [root@client ~]# modprobe  ip_gre
                3）查看模块信息
                    [root@client ~]# modinfo ip_gre
                    filename:       /lib/modules/3.10.0-693.el7.x86_64/kernel/net/ipv4/ip_gre.ko.xz
                    alias:          netdev-gretap0
                    alias:          netdev-gre0
                    alias:          rtnl-link-gretap
                    alias:          rtnl-link-gre
                    license:        GPL
                    rhelversion:    7.4
                    srcversion:     F37A2BF90692F86E3A8BD15
                    depends:        ip_tunnel,gre
                    intree:         Y
                    vermagic:       3.10.0-693.el7.x86_64 SMP mod_unload modversions
                    signer:         CentOS Linux kernel signing key
                    sig_key:        DA:18:7D:CA:7D:BE:53:AB:05:BD:13:BD:0C:4E:21:F4:22:B6:A4:9C
                    sig_hashalgo:   sha256
                    parm:           log_ecn_error:Log packets received with corrupted ECN (bool)

            2.Client主机创建VPN隧道

                1）创建隧道
                    [root@client ~]# ip tunnel add tun0  mode gre \
                    >  remote 201.1.2.5 local 201.1.2.10
                    //ip tunnel add创建隧道（隧道名称为tun0），ip tunnel help可以查看帮助
                    //mode设置隧道使用gre模式
                    //local后面跟本机的IP地址，remote后面是与其他主机建立隧道的对方IP地址
                2）启用该隧道（类似与设置网卡up）
                    [root@client ~]# ip link show
                    [root@client ~]# ip link set tun0 up         //设置UP
                    [root@client ~]# ip link show
                3）为VPN配置隧道IP地址
                    [root@client ~]# ip addr add 10.10.10.10/24 peer 10.10.10.5/24 \
                    >  dev tun0
                    //为隧道tun0设置本地IP地址（10.10.10.10.10/24）
                    //隧道对面的主机IP的隧道IP为10.10.10.5/24
                    [root@client ~]# ip a s                      //查看IP地址
                                     ip add show     etho       //查看网卡 0  的 IP信息
                4）关闭防火墙
                    [root@client ~]# firewall-cmd --set-default-zone=trusted

            3.Proxy主机创建VPN隧道

                1）查看计算机当前加载的模块
                    [root@client ~]# lsmod                            //显示模块列表
                    [root@client ~]# lsmod  | grep ip_gre            //确定是否加载了gre模块
                2)加载模块ip_gre
                    [root@client ~]# modprobe  ip_gre
                3）创建隧道
                    [root@proxy ~]# ~]# ip tunnel add tun0  mode gre \
                    >  remote 201.1.2.10 local 201.1.2.5
                    //ip tunnel add创建隧道（隧道名称为tun0），ip tunnel help可以查看帮助
                    //mode设置隧道使用gre模式
                    //local后面跟本机的IP地址，remote后面是与其他主机建立隧道的对方IP地址
                4）启用该隧道（类似与设置网卡up）
                    [root@proxy ~]# ip link show
                    [root@proxy ~]# ip link set tun0 up         //设置UP
                    [root@proxy ~]# ip link show
                5）为VPN配置隧道IP地址
                    [root@proxy ~]# ip addr add 10.10.10.5/24 peer 10.10.10.10/24 \
                    >  dev tun0
                    //为隧道tun0设置本地IP地址（10.10.10.10.5/24）
                    //隧道对面的主机IP的隧道IP为10.10.10.10/24
                    [root@proxy ~]# ip a s                      //查看IP地址
                6）开启路由转发、关闭防火墙
                    [root@proxy ~]# echo "1" > /proc/sys/net/ipv4/ip_forward
                    [root@proxy ~]# firewall-cmd --set-default-zone=trusted
                7)测试连通性
                    [root@client ~]#  ping 10.10.10.5
                    [root@proxy ~]#   ping 10.10.10.10


         创建PPTP VPN (W和L都支持)
                要求
                    本案例要求搭建一个PPTP VPN环境，并测试该VPN网络是否能够正常通讯，要求如下:
                    使用PPTP协议创建一个支持身份验证的隧道连接
                    使用MPPE对数据进行加密
                    为客户端分配192.168.3.0/24的地址池
                    客户端连接的用户名为jacob，密码为123456
            1.部署VPN服务器

                1）安装软件包（软件包参考lnmp_soft）
                    [root@proxy ~]# yum localinstall pptpd-1.4.0-2.el7.x86_64.rpm
                    [root@proxy ~]# rpm -qc pptpd
                    /etc/ppp/options.pptpd
                    /etc/pptpd.conf
                    /etc/sysconfig/pptpd
                2)修改配置文件
                    [root@proxy ~]# vim /etc/pptpd.conf
                    .. ..
                    localip 201.1.2.5                                    //服务器本地IP
                    remoteip 192.168.3.1-50                            //分配给客户端的IP池
                    [root@proxy ~]# vim /etc/ppp/options.pptpd
                    require-mppe-128                                    //使用MPPE加密数据
                    ms-dns 8.8.8.8                                    //DNS服务器
                    [root@proxy ~]# vim /etc/ppp/chap-secrets            //修改账户配置文件
                    jacob           *               123456      *
                    //用户名    服务器标记    密码    客户端
                    [root@proxy ~]# echo "1" > /proc/sys/net/ipv4/ip_forward    //开启路由转发
                3）启动服务
                    [root@proxy ~]# systemctl start pptpd
                    [root@proxy ~]# systemctl enable pptpd
                    [root@proxy ~]# firewall-cmd --set-default-zone=trusted
                4）翻墙设置（非必需操作）
                    [root@proxy ~]# iptables -t nat -A POSTROUTING -s 192.168.3.0/24 \
                    >  -j SNAT --to-source 201.1.2.5

                5)在Windows 上 配置 vpn 链接

         创建L2TP+IPSec VPN(W和L都支持)
                本案例要求搭建一个L2TP+IPSec VPN环境，并测试该VPN网络是否能够正常通讯，具体要求如下：
                使用L2TP协议创建一个支持身份验证与加密的隧道连接
                使用IPSec对数据进行加密
                为客户端分配192.168.3.0/24的地址池
                客户端连接的用户名为：jacob，密码为：123456
                预共享密钥为：randpass
            1.部署IPSec服务

                1）安装软件包
                    [root@client ~]# yum -y install libreswan
                2)新建IPSec密钥验证配置文件
                    [root@client ~]# cat /etc/ipsec.conf                //仅查看一下该主配置文件
                    .. ..
                    include /etc/ipsec.d/*.conf                    //加载该目录下的所有配置文件
                    [root@client ~]# vim /etc/ipsec.d/myipsec.conf
                    //新建该文件，参考lnmp_soft/vpn/myipsec.conf
                    conn IDC-PSK-NAT
                        rightsubnet=vhost:%priv                        //允许建立的VPN虚拟网络
                        also=IDC-PSK-noNAT
                    conn IDC-PSK-noNAT
                        authby=secret                                    //加密认证
                            ike=3des-sha1;modp1024                        //算法
                            phase2alg=aes256-sha1;modp2048                //算法
                        pfs=no
                        auto=add
                        keyingtries=3
                        rekey=no
                        ikelifetime=8h
                        keylife=3h
                        type=transport
                        left=201.1.2.10                                //重要，服务器本机的外网IP
                        leftprotoport=17/1701
                        right=%any                                    //允许任何客户端连接
                        rightprotoport=17/%any
                3)创建IPSec预定义共享密钥
                    [root@client ~]# cat /etc/ipsec.secrets                 //仅查看，不要修改该文件
                    include /etc/ipsec.d/*.secrets
                    [root@client ~]# vim /etc/ipsec.d/mypass.secrets        //新建该文件
                    201.1.2.10   %any:    PSK    "randpass"             //randpass为预共享密钥
                                                                    //201.1.2.10是VPN服务器的IP
                4)启动IPSec服务
                    [root@client ~]# systemctl start ipsec
                    [root@client ~]# netstat -ntulp |grep pluto
                    udp        0      0 127.0.0.1:4500          0.0.0.0:*           3148/pluto
                    udp        0      0 192.168.4.10:4500      0.0.0.0:*           3148/pluto
                    udp        0      0 201.1.2.10:4500         0.0.0.0:*           3148/pluto
                    udp        0      0 127.0.0.1:500           0.0.0.0:*           3148/pluto
                    udp        0      0 192.168.4.10:500       0.0.0.0:*           3148/pluto
                    udp        0      0 201.1.2.10:500          0.0.0.0:*           3148/pluto
                    udp6       0      0 ::1:500                 :::*                 3148/pluto

            2.部署XL2TP服务

                1）安装软件包（软件包参考lnmp_soft）
                    [root@client ~]# yum localinstall xl2tpd-1.3.8-2.el7.x86_64.rpm
                2) 修改xl2tp配置文件（修改3个配置文件的内容）
                    [root@client ~]#  vim  /etc/xl2tpd/xl2tpd.conf                //修改主配置文件
                    [global]
                    .. ..
                    [lns default]
                    .. ..
                    ip range = 192.168.3.128-192.168.3.254                    //分配给客户端的IP池
                    local ip = 201.1.2.10                                    //VPN服务器的IP地址
                    [root@client ~]# vim /etc/ppp/options.xl2tpd            //认证配置
                    require-mschap-v2                                         //添加一行，强制要求认证
                    #crtscts                                                //注释或删除该行
                    #lock                                                //注释或删除该行
                    root@client ~]# vim /etc/ppp/chap-secrets                    //修改密码文件
                    jacob   *       123456  *                //账户名称   服务器标记   密码   客户端IP
                3）启动服务
                    [root@client ~]# systemctl start xl2tpd
                    [root@client ~]# netstat  -ntulp |grep xl2tpd
                    udp     0      0 0.0.0.0:1701      0.0.0.0:*          3580/xl2tpd
                4）设置路由转发，防火墙
                    [root@client ~]# echo "1" > /proc/sys/net/ipv4/ip_forward
                    [root@client ~]# firewall-cmd --set-default-zone=trusted
                5）翻墙设置（非必需操作）
                    [root@client ~]# iptables -t nat -A POSTROUTING -s 192.168.3.0/24 \
                    >  -j SNAT --to-source 201.1.2.10
            3.客户端设置

                启动一台Windows虚拟机，将虚拟机网卡桥接到public2，配置IP地址为201.1.2.20。
                1) 新建网络连接（参考案例2），输入VPN服务器账户与密码（参考案例2）。
                    属性---选择----安全---xl2 ---- randpass
                    若是 win7 以上则不需要修改注册表
                2)设置Windows注册表（不修改注册表，连接VPN默认会报789错误），具体操作如下：
                    单击"开始"，单击"运行"，键入"regedit"，然后单击"确定"
                    找到下面的注册表子项，然后单击它：
                    HKEY_LOCAL_MACHINE\ System\CurrentControlSet\Services\Rasman\Parameters
                    在"编辑"菜单上，单击"新建"->"DWORD值"
                    在"名称"框中，键入"ProhibitIpSec"
                    在"数值数据"框中，键入"1"，然后单击"确定"
                    退出注册表编辑器，然后重新启动计算机

         linux 内核模块
                modprob  模块名称
                lsmod    查看安装模块
                rmmod    删除模块
                modinfo
                iptunnel add 创建隧道tun0
                ip addr add  网络地址
         pptpd
                3个配置文件
                vpn的私有网络
                localipremoteip
                ms-dns
                用户名和密码
         xl2tp和ipsec
                ipsec
                主配置文件
                /etc/ipsec.d/xxx.conf  加密算法
                /etc/ipsec.d//xxxx/secrets PSK 域共享秘钥
                xl2tp
                主配置文件
                3个配置文件
                /etc/xl2tpd/xl2tpd.conf
                /etc/ppp/options.xl2tpd
                /etc/ppp/chap-secrets
    NTP时间同步
        要求
            搭建一个NTP服务器，为整个网络环境中的所有主机提供时间校准服务，具体要求如下：
            部署一台NTP时间服务器
            设置时间服务器上层与0.centos.pool.ntp.org同步
            设置本地服务器层级数量为10
            允许192.168.4.0/24网络的主机同步时间
            客户端验证时间是否同步
        方案
            clients 作为客户端  192.168.4.5
            proxy 作为服务端  ---4.10

            软件 chrondy默认安装 最小化安装也会有
            Network Time Protocol（网络时间协议）采用的是分层设计
            Stratum层的总数限制在15以内（包括15）。(不超过16跳)
        1.部署NTP服务

            1）安装软件包
                [root@proxy ~]# yum -y install chrony
                [root@proxy ~]# rpm -qc chrony                        //查看配置文件列表
                /etc/chrony.conf
                /etc/chrony.keys
                .. ..
            2)修改配置文件
                [root@proxy ~]# cat /etc/chrony.conf
                .. ..
                server 0.centos.pool.ntp.org iburst         //server用户客户端指向上层NTP服务器
                allow 192.168.4.0/24                        //允许那个IP或网络访问NTP
                #deny  192.168.4.1                        //拒绝那个IP或网络访问NTP
                local stratum 10                            //设置NTP服务器的层数量 不超过15层
                .. ..
            3) 将客户端时间修改为错误的时间
                [root@client ~]#  date  -s  "hour:minute"         //调整时间（小时：分钟）
                [root@client ~]#  date                            //查看修改后的时间
            4) 重启chrony与服务器同步时间
                [root@client ~]# systemctl  restart  chronyd
            5) 确认时间是否已经同步
                [root@client ~]# date                            //多执行几次查看结果




    CLUSTER 集群,簇

            lvs也是实现高可用 高性能  高负载
            NTP(闰秒) 随机的多了一秒 60 无法预测提前准备
    集群以及LVS
        集群分类:
                高性能计算集群HPC 解决科学问题
                高可靠集群(HA)   互联网多用
                高负载均衡集群(LB)
        需要注意的是lvs 与 nginx 代理 原理不同
            clients 访问nginx(代理clients访问web1)   nginx 访问 web1
            clients 访问lvs(相当于路由器)    转发给    web1 / web2

        lvs(nat)==路由器(ip forward = 1 )
        web1 web2网关 必须陪

        优点:
            降低成本 提高成本 增加可靠性 高扩展

        LVS术语:
                Director Server  调度服务器
                real server      真实服务器
                VIP              虚拟IP
                RIP              真实IP
                DIP              调度器链接节点服务器的ip
        LVS 工作模式:
            NAT 模式 调度和真实服务器都在 局域网中,之间直接链接
                和nginx的调度服务器相同(瓶颈也是调度服务器,尤其是数据回传给用户的) 用户与调度服务器链接,由调度服务器 回传数据
            DR 模式 调度和真实服务器都在 局域网中,之间使用交换机链接服务器,用户直接与路由器 链接,访问时访问 lvs 的 vip ,
                lvs回传数据直接由 互联网 传递数据,不通过调度服务器.  需要注意mac地址广播的控制 arp (后端服务器调整内核参数实现)
            TUN 模式 (用的少) 所有的服务器都在互联网 中 调度服务器与真实服务器间 用 vpn 链接 ,数据回传有互联网 传输

            关于lvs-DR工作模式的补充:
                1、通过在调度器LB上修改数据包的目的MAC地址实现转发。注意，源IP地址仍然是CIP, 目的IP地址仍然是VIP。
                2、请求的报文经过调度器，而RS(后端真实服务器)响应处理后的报文无需经过调度器LB, 因此，并发访问量大时使用效率很高(和NAT模式比)
                3、因DR模式是通过MAC地址的改写机制实现的转发，因此，所有RS节点和调度器LB只能在一个局域网LAN中(小缺点)。
                4、需要注意RS节点的VIP的绑定(lo:vip/32,lo1:vip/32) 和ARP抑制问题。
                5、强调下: RS节点的默认网关不需要是调度器LB的DIP, 而直接是DC机房分配的上级路由器的IP (这是RS带有外网P地址的情况)，理论讲:只要RS可以出网即可，不是必须要配置外网IP。
                6、由于DR模式的调度器仅进行了目的MAC地址的改写，因此，调度器LB无法改变请求的报文的目的端口(和NAT要区别)
                7、当前，调度器LB支持几乎所有的UNIX，LINUX系统，但目前不支持WINDOWS系统。真实服务器RS节点可以是WINDOWS系统。
                8、总的来说DR模式效率很高，但是配置也较麻烦，因此，访问量不是特别大的公司可以用haproxy/nginx取代之。这符合运维的原则:简单、易用、高效。日1000-2000W PV或并发请求1万以下都可以考虑用haproxy/nginx (LVS NAT模式)
                9、直接对外的访问业务，例如:web服务做RS节点，RS最好用公网IP地址。如果不直接对外的业务，例如: MySQL,存储系统RS节点，最好只用内部IP地址。
                    DR模式的核心特点就是更改目标MAC地址进行转发


            -g (DR)
            -i (tun)
            -m (NAT)
        ipvsadm
            常用的命令
                ipvsadm-A               添加虚拟服务器
                ipvsadm-E               修改虚拟服务器
                ipvsadm-D               删除虚拟服务器
                ipvsadm-C               删除所有
                ipvsadm-e               修改真实服务器
                ipvsadm-a               添加真实服务器
                ipvsadm-d               删除真实服务器
                ipvsadm-L               查看LVS 规则表
                -s[rr|wrr|lc|wlc]       指定集群算法
                rr 论循算法
                wrr 加权轮循算法
                sh ip哈希
                lc 最小链接
                wlc 加权最少链接
            方案
                1.ipvsadm命令用法
                    1)创建lvs集群 算法为wrr
                        [root@proxy ~]# yum -y install ipvsadm
                        [root@proxy ~]# ipvsadm -A -t 192.168.4.5:80 -s wrr
                        [root@proxy ~]# ipvsadm -Ln
                        IP Virtual Server version 1.2.1 (size=4096)
                        Prot LocalAddress:Port Scheduler Flags
                          -> RemoteAddress:Port           Forward Weight ActiveConn InActConn
                        TCP  192.168.4.5:80 wrr
                    2)向集群添加rs
                        [root@proxy ~]# ipvsadm -a -t 192.168.4.5:80 -r 192.168.2.100 -m -w 1
                        ############# -m  指定工作模式  -w 指定权重  ############
                        [root@proxy ~]# ipvsadm -Ln
                        IP Virtual Server version 1.2.1 (size=4096)
                        Prot LocalAddress:Port Scheduler Flags
                          -> RemoteAddress:Port           Forward Weight ActiveConn InActConn
                        TCP  192.168.4.5:80 wrr
                          -> 192.168.2.100:80             Masq    1      0          0
                        [root@proxy ~]# ipvsadm -a -t 192.168.4.5:80 -r 192.168.2.200 -m -w 2
                        [root@proxy ~]# ipvsadm –a -t 192.168.4.5:80 -r 192.168.2.201 -m -w 3
                        [root@proxy ~]# ipvsadm –a -t 192.168.4.5:80 -r 192.168.2.202 -m -w 4
                    3）修改集群服务器设置(-E 修改调度器算法，将加权轮询修改为轮询)
                        [root@proxy ~]# ipvsadm -E -t 192.168.4.5:80 -s rr
                        [root@proxy ~]# ipvsadm -Ln
                        IP Virtual Server version 1.2.1 (size=4096)
                        Prot LocalAddress:Port Scheduler Flags
                          -> RemoteAddress:Port           Forward Weight ActiveConn InActConn
                        TCP  192.168.4.5:80 rr
                          -> 192.168.2.100:80             Masq    1      0          0
                          -> 192.168.2.200:80             Masq    2      0          0
                          -> 192.168.2.201:80             Masq    2      0          0
                          -> 192.168.2.202:80             Masq    1      0          0
                    4）修改read server（-e  使用-g选项，将模式改为DR模式）
                        [root@proxy ~]# ipvsadm -e -t 192.168.4.5:80 -r 192.168.2.202 -g

                    5）查看LVS状态
                        [root@proxy ~]# ipvsadm -Ln
                        6）创建另一个集群（算法为最少连接算法；使用-m选项，设置工作模式为NAT模式）
                        [root@proxy ~]# ipvsadm -A -t 192.168.4.5:3306 -s lc
                        [root@proxy ~]# ipvsadm -a -t 192.168.4.5:3306 -r 192.168.2.100 -m
                        [root@proxy ~]# ipvsadm -a -t 192.168.4.5:3306 -r 192.168.2.200 -m
                        6）永久保存所有规则
                        [root@proxy ~]# ipvsadm-save -n > /etc/sysconfig/ipvsadm
                        7）清空所有规则
                        [root@proxy ~]# ipvsadm -C

                2.部署LVS-NAT集群
                    配置思路:



                    要求
                        使用LVS实现NAT模式的集群调度服务器，为用户提供Web服务：
                        集群对外公网IP地址为192.168.4.5
                        调度器内网IP地址为192.168.2.5
                        真实Web服务器地址分别为192.168.2.100、192.168.2.200
                        使用加权轮询调度算法，真实服务器权重分别为1和2


                        将web1和 web2 的网关配置192.168.2.5
                        只保留一个网卡启用,不然会出错

                    (1)配置基础环境
                        1）设置Web服务器（以web1为例）
                            [root@web1 ~]# yum -y install httpd
                            [root@web1 ~]# echo "192.168.2.100" > /var/www/html/index.html
                        2）启动Web服务器软件
                            [root@web1 ~]# systemctl restart httpd
                        3)关闭防火墙与SELinux
                            [root@web1 ~]# systmctl stop firewalld
                            [root@web1 ~]# setenforce 0
                    (2)部署LVS-NAT模式调度器

                        1)确认调度器的路由转发功能(如果已经开启，可以忽略)
                            [root@proxy ~]# echo 1 > /proc/sys/net/ipv4/ip_forward
                            [root@proxy ~]# cat /proc/sys/net/ipv4/ip_forward
                            1
                            [root@proxy ~]# echo "net.ipv4.ip_forward = 1" >> /etc/sysctl.conf
                        #修改配置文件，设置永久规则
                        2）创建集群服务器
                            [root@proxy ~]# yum -y install ipvsadm
                            [root@proxy ~]# ipvsadm -A -t 192.168.4.5:80 -s wrr
                        2）添加真实服务器
                            [root@proxy ~]# ipvsadm -a -t 192.168.4.5:80 -r 192.168.2.100 -w 1 -m
                            [root@proxy ~]# ipvsadm -a -t 192.168.4.5:80 -r 192.168.2.200 -w 1 -m
                        3）查看规则列表，并保存规则
                            [root@proxy ~]# ipvsadm -Ln
                            [root@proxy ~]# ipvsadm-save -n > /etc/sysconfig/ipvsadm

                3.部署LVS-DR集群
                    配置思路 :
                            ####################################
                            为了防止冲突，VIP必须要配置在网卡的虚拟接口
                            ####################################
                        后端服务器(真实服务器):
                            配置web服务器
                            配置 vip
                            调整内核实现 arp 广播控制(mac地址广播控制)
                        lvs调度服务器 :
                            安装启用 ipvsadm
                            配置vip, 配置 dip
                            创建虚拟服务器,向虚拟服务器添加节点
                        client :
                            访问 虚拟服务器 测试

                    要求
                        使用LVS实现DR模式的集群调度服务器，为用户提供Web服务：
                        客户端IP地址为192.168.4.10
                        LVS调度器VIP地址为192.168.4.15
                        LVS调度器DIP地址设置为192.168.4.5
                        真实Web服务器地址分别为192.168.4.100、192.168.4.200
                        使用加权轮询调度算法，web1的权重为1，web2的权重为2
                    补充
                        CIP是客户端的IP地址；
                        VIP是对客户端提供服务的IP地址；
                        RIP是后端服务器的真实IP地址；
                        DIP是调度器与后端服务器通信的IP地址（VIP必须配置在虚拟接口）\

                                       _____web1 eth0 4.100
                                       |    lo:0 4.15/32()
                                       |
                    clients -------->lvs1 lvs2
                                       |     web1 eth0 4.200
                                       |_____lo:0 4.15/32(添加一个虚拟ip,也叫主机网络只有一个主机位,且只响应物理网卡ip)
                        keeplived (VRRP协议:虚拟路由热备协议) 提高可靠性

                    (1)配置实验网络环境

                        1）设置Proxy代理服务器的VIP和DIP

                            注意：为了防止冲突，VIP必须要配置在网卡的虚拟接口！！！

                             [root@proxy ~]# cd /etc/sysconfig/network-scripts/
                            [root@proxy ~]# cp ifcfg-eth0{,:0}
                            [root@proxy ~]# vim ifcfg-eth0
                            TYPE=Ethernet
                            BOOTPROTO=none
                            NAME=eth0
                            DEVICE=eth0
                            ONBOOT=yes
                            IPADDR=192.168.4.5
                            PREFIX=24
                            [root@proxy ~]# vim ifcfg-eth0:0
                            TYPE=Ethernet
                            BOOTPROTO=none
                            DEFROUTE=yes
                            NAME=eth0:0
                            DEVICE=eth0:0
                            ONBOOT=yes
                            IPADDR=192.168.4.15
                            PREFIX=24
                            [root@proxy ~]# systemctl restart network
                        2）设置Web1服务器网络参数
                            [root@web1 ~]# nmcli connection modify eth0 ipv4.method manual \
                            ipv4.addresses 192.168.4.100/24 connection.autoconnect yes
                            [root@web1 ~]# nmcli connection up eth0
                            接下来给web1配置VIP地址。
                            注意：这里的子网掩码必须是32（也就是全255），网络地址与IP地址一样，广播地址与IP地址也一样。
                            [root@web1 ~]# cd /etc/sysconfig/network-scripts/
                            [root@web1 ~]# cp ifcfg-lo{,:0}    ####将 ifcfg-lo 复制并重命名为 ifcfg-lo:0
                            [root@web1 ~]# vim ifcfg-lo:0
                            DEVICE=lo:0
                            IPADDR=192.168.4.15
                            NETMASK=255.255.255.255
                            NETWORK=192.168.4.15
                            BROADCAST=192.168.4.15
                            ONBOOT=yes
                            NAME=lo:0
                            防止地址冲突的问题：
                            这里因为web1也配置与代理一样的VIP地址，默认肯定会出现地址冲突；
                            sysctl.conf文件写入这下面四行的主要目的就是访问192.168.4.15的数据包，只有调度器会响应，其他主机都不做任何响应，这样防止地址冲突的问题。
                            [root@web1 ~]# vim /etc/sysctl.conf
                            #手动写入如下4行内容
                            net.ipv4.conf.all.arp_ignore = 1  arp_ignore  0 默认值 相应本地所有的arp广播   1 只回应配置在网卡借口上的任意ip的arp 广播
                            net.ipv4.conf.lo.arp_ignore = 1
                            net.ipv4.conf.lo.arp_announce = 2   arp_announce  0 默认 使用配置在任意接口上的本地ip地址 2 忽略IP数据包的源IP地址，选择该发送网卡上最合适的本地地址作为arp请求的源IP地址。
                            net.ipv4.conf.all.arp_announce = 2   ##announce 设置为2  目的是 (伪装lvs_proxy 服务器发送数据包)从web1 发出的数据包的地址 src_ip 设定为vip地址 目的地址则是 clientip
                            #当有arp广播问谁是192.168.4.15时，本机忽略该ARP广播，不做任何回应
                            #本机不要向外宣告自己的lo回环地址是192.168.4.15
                            [root@web1 ~]# sysctl -p
                            重启网络服务，设置防火墙与SELinux
                            [root@web1 ~]# systemctl restart network
                            [root@web1 ~]# ifconfig
                            [root@web1 ~]# systemctl stop firewalld
                            [root@web1 ~]# setenforce 0
                        3）设置Web2服务器网络参数
                            [root@web2 ~]# nmcli connection modify eth0 ipv4.method manual \
                            ipv4.addresses 192.168.4.200/24 connection.autoconnect yes
                            [root@web2 ~]# nmcli connection up eth0
                            接下来给web2配置VIP地址
                            注意：这里的子网掩码必须是32（也就是全255），网络地址与IP地址一样，广播地址与IP地址也一样。
                            [root@web2 ~]# cd /etc/sysconfig/network-scripts/
                            [root@web2 ~]# cp ifcfg-lo{,:0}
                            [root@web2 ~]# vim ifcfg-lo:0
                            DEVICE=lo:0
                            IPADDR=192.168.4.15
                            NETMASK=255.255.255.255
                            NETWORK=192.168.4.15
                            BROADCAST=192.168.4.15
                            ONBOOT=yes
                            NAME=lo:0
                            防止地址冲突的问题：
                            这里因为web1也配置与代理一样的VIP地址，默认肯定会出现地址冲突；
                            sysctl.conf文件写入这下面四行的主要目的就是访问192.168.4.15的数据包，只有调度器会响应，其他主机都不做任何响应，这样防止地址冲突的问题。
                            [root@web2 ~]# vim /etc/sysctl.conf
                            #手动写入如下4行内容
                            net.ipv4.conf.all.arp_ignore = 1
                            net.ipv4.conf.lo.arp_ignore = 1
                            net.ipv4.conf.lo.arp_announce = 2
                            net.ipv4.conf.all.arp_announce = 2
                            #当有arp广播问谁是192.168.4.15时，本机忽略该ARP广播，不做任何回应
                            #本机不要向外宣告自己的lo回环地址是192.168.4.15
                            [root@web2 ~]# sysctl -p
                            重启网络服务，设置防火墙与SELinux
                            [root@web2 ~]# systemctl restart network
                            [root@web2 ~]# ifconfig
                            [root@web2 ~]# systemctl stop firewalld
                            [root@web2 ~]# setenforce 0
                    (2)配置后端Web服务器

                        1）自定义Web页面
                            [root@web1 ~]# yum -y install httpd
                            [root@web1 ~]# echo "192.168.4.100" > /var/www/html/index.html
                            [root@web2 ~]# yum -y install httpd
                            [root@web2 ~]# echo "192.168.4.200" > /var/www/html/index.html
                        2）启动Web服务器软件
                            [root@web1 ~]# systemctl restart httpd
                            [root@web2 ~]# systemctl restart httpd
                    (3)proxy调度器安装软件并部署LVS-DR模式调度器

                        1）安装软件（如果已经安装，此步骤可以忽略）
                            [root@proxy ~]# yum -y install ipvsadm
                        2）清理之前实验的规则，创建新的集群服务器规则
                            [root@proxy ~]# ipvsadm -C                                #清空所有规则
                            [root@proxy ~]# ipvsadm -A -t 192.168.4.15:80 -s wrr
                        3）添加真实服务器(-g参数设置LVS工作模式为DR模式，-w设置权重)
                            [root@proxy ~]# ipvsadm -a -t 192.168.4.15:80 -r 192.168.4.100 -g -w 1
                            [root@proxy ~]# ipvsadm -a -t 192.168.4.15:80 -r 192.168.4.200 -g -w 1
                        4）查看规则列表，并保存规则
                            [root@proxy ~]# ipvsadm -Ln
                            TCP  192.168.4.15:80 wrr
                              -> 192.168.4.100:80             Route   1      0          0
                              -> 192.168.4.200:80             Route   2      0          0
                            [root@proxy ~]# ipvsadm-save -n > /etc/sysconfig/ipvsadm
                        5)访问测试
                            [root@client ~]# curl 192.168.4.15
                                <h1><marquee> I AM web1
                            [root@client ~]# curl 192.168.4.15
                                <h1>I AM WEB2


        keeplived高可用

                keeplived 和 lvs 连用时 keeplive 的 配置中需要指定  virtural server 部分
                如下
                和 haproxy 连用 时 则不需要 virtual server部分

                                #virtual_server 192.168.1.66 80 {
                                #   delay_loop 6
                                #   lb_algo rr
                                #   lb_kind DR
                                # #  persistence_timeout 50
                                #   protocol TCP

                                #   real_server 192.168.1.62 80 {
                                #       weight 1
                                #       TCP_CHECK {
                                #           connect_timeout 3
                                #           nb_get_retry 3
                                #           delay_before_retry 3
                                #      }

                                #   }

                                #  real_server 192.168.1.63 80 {
                                #       weight 2
                                #       TCP_CHECK {
                                #           connect_timeout 3
                                #           nb_get_retry 3
                                #           delay_before_retry 3
                                #      }
                                #   }


                                #}

                1.配置网络环境（如果在前面课程已经完成该配置，可以忽略此步骤）

                        1）设置Web1服务器网络参数、配置Web服务
                            [root@web1 ~]# nmcli connection modify eth0 ipv4.method manual ipv4.addresses 192.168.4.100/24 connection.autoconnect yes
                            [root@web1 ~]# nmcli connection up eth0
                            [root@web1 ~]# yum -y install httpd
                            [root@web1 ~]# echo "192.168.4.100" > /var/www/html/index.html
                            [root@web1 ~]# systemctl restart httpd
                        2）设置Web2服务器网络参数、配置Web服务
                            [root@web2 ~]# nmcli connection modify eth0 ipv4.method manual ipv4.addresses 192.168.4.200/24 connection.autoconnect yes
                            [root@web2 ~]# nmcli connection up eth0
                            [root@web2 ~]# yum -y install httpd
                            [root@web2 ~]# echo "192.168.4.200" > /var/www/html/index.html
                            [root@web2 ~]# systemctl restart httpd
                        3）配置proxy主机的网络参数（如果已经设置，可以忽略此步骤）
                            [root@proxy ~]# nmcli connection modify eth0 ipv4.method manual ipv4.addresses 192.168.4.5/24 connection.autoconnect yes
                            [root@proxy ~]# nmcli connection up eth0
                2.安装Keepalived软件

                        注意：两台Web服务器做相同的操作。
                            [root@web1 ~]# yum install -y keepalived
                            [root@web2 ~]# yum install -y keepalived
                3.部署Keepalived服务
                            1.实现vrrp vip  (vrrp虚拟路由热备协议,vip虚拟ip,会随着主服务而迁移)
                            2.自动配置lvs,健康检查
                        1）修改web1服务器Keepalived配置文件
                            [root@web1 ~]# vim /etc/keepalived/keepalived.conf
                            global_defs {
                              notification_email {
                                admin@tarena.com.cn                //设置报警收件人邮箱
                              }
                              notification_email_from ka@localhost    //设置发件人
                              smtp_server 127.0.0.1                //定义邮件服务器
                              smtp_connect_timeout 30
                              router_id  web1                        //设置路由ID号（实验需要修改）
                            }
                            vrrp_instance VI_1 {
                              state MASTER                         //主服务器为MASTER（备服务器需要修改为BACKUP）, state  (现在设定的参数) 是作为 软件开启是临时状态,最终状态会由 priority 的数值决定,当priority 也不能比较 出结果的时候,对 ip 和 mac 进行对比.
                              interface eth0                    //定义网络接口
                              virtual_router_id 51                //主备服务器VRID号必须一致  相当于虚拟交换机
                              priority 100                     //服务器优先级,优先级高优先获取VIP（实验需要修改）,也是最终决定 主副的 方式
                              advert_int 1
                              authentication {
                                auth_type pass
                                auth_pass 1111                       //主备服务器密码必须一致
                              }
                              virtual_ipaddress {                   //谁是主服务器谁获得该VIP（实验需要修改）
                                192.168.4.80
                              }
                              }
                        2）修改web2服务器Keepalived配置文件
                            [root@web2 ~]# vim /etc/keepalived/keepalived.conf
                            global_defs {
                              notification_email {
                                admin@tarena.com.cn                //设置报警收件人邮箱
                              }
                              notification_email_from ka@localhost    //设置发件人
                              smtp_server 127.0.0.1                //定义邮件服务器
                              smtp_connect_timeout 30
                              router_id  web2                        //设置路由ID号（实验需要修改）
                            }
                            vrrp_instance VI_1 {
                              state BACKUP                             //备服务器为BACKUP（实验需要修改）
                              interface eth0                        //定义网络接口
                              virtual_router_id 51                    //主辅VRID号必须一致
                              priority 50                             //服务器优先级（实验需要修改）
                              advert_int 1
                              authentication {
                                 auth_type pass
                                 auth_pass 1111                       //主辅服务器密码必须一致
                              }
                              virtual_ipaddress {                 //谁是主服务器谁配置VIP（实验需要修改）
                              192.168.4.80
                             }
                            }
                        3）启动服务
                            [root@web1 ~]# systemctl start keepalived
                            [root@web2 ~]# systemctl start keepalived
                        4）配置防火墙和SELinux
                            启动keepalived会自动添加一个drop的防火墙规则，需要清空！
                            [root@web1 ~]# iptables -F   ####关闭 IPtables防火墙
                            [root@web1 ~]# setenforce 0
                            [root@web2 ~]# iptables -F
                            [root@web1 ~]# setenforce 0


        Keepalived+LVS服务器
                要求
                        Keepalived为LVS调度器提供高可用功能，防止调度器单点故障，为用户提供Web服务：
                        LVS1调度器真实IP地址为192.168.4.5
                        LVS2调度器真实IP地址为192.168.4.6
                        服务器VIP地址设置为192.168.4.15  ##生产环境中这里应该配置外网ip  访问外网ip 经过lvs调度,传递给后端服务器
                        真实Web服务器地址分别为192.168.4.100、192.168.4.200
                        使用加权轮询调度算法，真实web服务器权重不同

                1.配置网络环境

                        1）设置Web1服务器的网络参数
                        [root@web1 ~]# nmcli connection modify eth0 ipv4.method manual \
                            ipv4.addresses 192.168.4.100/24 connection.autoconnect yes
                            [root@web1 ~]# nmcli connection up eth0
                            接下来给web1配置VIP地址
                            注意：这里的子网掩码必须是32me（也就是全255），网络地址与IP地址一样，广播地址与IP地址也一样。
                            [root@web1 ~]# cd /etc/sysconfig/network-scripts/
                            [root@web1 ~]# cp ifcfg-lo{,:0}
                            [root@web1 ~]# vim ifcfg-lo:0
                            DEVICE=lo:0                             //网卡配置文件的默认格式
                            IPADDR=192.168.4.15
                            NETMASK=255.255.255.255 //确保只有一个ip
                            NETWORK=192.168.4.15
                            BROADCAST=192.168.4.15
                            ONBOOT=yes
                            NAME=lo:0
                            注意：这里因为web1也配置与调度器一样的VIP地址，默认肯定会出现地址冲突。
                            写入下面四行的主要目的就是访问192.168.4.15的数据包，只有调度器会响应，其他主机都不做任何响应。
                            [root@web1 ~]# vim /etc/sysctl.conf
                            #手动写入如下4行内容
                            net.ipv4.conf.all.arp_ignore = 1
                            net.ipv4.conf.lo.arp_ignore = 1
                            net.ipv4.conf.lo.arp_announce = 2
                            net.ipv4.conf.all.arp_announce = 2
                            #当有arp广播问谁是192.168.4.15时，本机忽略该ARP广播，不做任何回应
                            #本机不要向外宣告自己的lo回环地址是192.168.4.15
                            重启网络服务，设置防火墙与SELinux
                            [root@web1 ~]# systemctl restart network
                            [root@web1 ~]# ifconfig
                            [root@web1 ~]# systemctl stop firewalld
                            [root@web1 ~]# setenforce 0
                        2）设置Web2服务器的网络参数
                            [root@web2 ~]# nmcli connection modify eth0 ipv4.method manual \
                            ipv4.addresses 192.168.4.200/24 connection.autoconnect yes
                            [root@web2 ~]# nmcli connection up eth0
                            接下来给web2配置VIP地址
                            注意：这里的子网掩码必须是32（也就是全255），网络地址与IP地址一样，广播地址与IP地址也一样。
                            [root@web2 ~]# cd /etc/sysconfig/network-scripts/
                            [root@web2 ~]# cp ifcfg-lo{,:0}
                            [root@web2 ~]# vim ifcfg-lo:0
                            DEVICE=lo:0
                            IPADDR=192.168.4.15
                            NETMASK=255.255.255.255
                            NETWORK=192.168.4.15
                            BROADCAST=192.168.4.15
                            ONBOOT=yes
                            NAME=lo:0
                            注意：这里因为web2也配置与代理一样的VIP地址，默认肯定会出现地址冲突。
                            写入这四行的主要目的就是访问192.168.4.15的数据包，只有调度器会响应，其他主机都不做任何响应。
                            [root@web2 ~]# vim /etc/sysctl.conf
                            #手动写入如下4行内容
                            net.ipv4.conf.all.arp_ignore = 1
                            net.ipv4.conf.lo.arp_ignore = 1
                            net.ipv4.conf.lo.arp_announce = 2
                            net.ipv4.conf.all.arp_announce = 2
                            #当有arp广播问谁是192.168.4.15时，本机忽略该ARP广播，不做任何回应
                            #本机不要向外宣告自己的lo回环地址是192.168.4.15
                            重启网络服务，设置防火墙与SELinux
                            [root@web2 ~]# systemctl restart network
                            [root@web2 ~]# ifconfig
                            [root@web2 ~]# systemctl stop firewalld
                            [root@web2 ~]# setenforce 0
                        3）配置proxy1主机的网络参数(不配置VIP，由keepalvied自动配置)
                            [root@proxy1 ~]# nmcli connection modify eth0 ipv4.method manual \
                            ipv4.addresses 192.168.4.5/24 connection.autoconnect yes
                            [root@proxy1 ~]# nmcli connection up eth0
                        4）配置proxy2主机的网络参数(不配置VIP，由keepalvied自动配置)
                            注意：按照前面的课程环境，默认没有该虚拟机，需要重新建一台虚拟机proxy2。
                            [root@proxy2 ~]# nmcli connection modify eth0 ipv4.method manual \
                            ipv4.addresses 192.168.4.6/24 connection.autoconnect yes
                            [root@proxy2 ~]# nmcli connection up eth0

                2.配置后台web服务

                        1）安装软件，自定义Web页面（web1和web2主机）
                            [root@web1 ~]# yum -y install httpd
                            [root@web1 ~]# echo "192.168.4.100" > /var/www/html/index.html
                            [root@web2 ~]# yum -y install httpd
                            [root@web2 ~]# echo "192.168.4.200" > /var/www/html/index.html
                        2）启动Web服务器软件(web1和web2主机)
                            [root@web1 ~]# systemctl start httpd ; systemctl enable httpd
                            [root@web2 ~]# systemctl start httpd ; systemctl enable httpd
                3.调度器安装Keepalived与ipvsadm软件

                        注意：两台LVS调度器执行相同的操作（如何已经安装软件，可用忽略此步骤）。
                        安装软件
                            [root@proxy1 ~]# yum install -y keepalived
                            [root@proxy1 ~]# systemctl enable keepalived
                            [root@proxy1 ~]# yum install -y ipvsadm
                            [root@proxy1 ~]# ipvsadm -C
                            [root@proxy2 ~]# yum install -y keepalived
                            [root@proxy2 ~]# systemctl enable keepalived
                            [root@proxy2 ~]# yum install -y ipvsadm
                            [root@proxy2 ~]# ipvsadm -C
                4.部署Keepalived实现LVS-DR模式调度器的高可用

                        1）LVS1调度器设置Keepalived，并启动服务
                            [root@proxy1 ~]# vim /etc/keepalived/keepalived.conf
                            global_defs {
                              notification_email {
                                admin@tarena.com.cn                //设置报警收件人邮箱
                              }
                              notification_email_from ka@localhost    //设置发件人
                              smtp_server 127.0.0.1                //定义邮件服务器
                              smtp_connect_timeout 30
                              router_id  lvs1                        //设置路由ID号(实验需要修改)
                            }
                            vrrp_instance VI_1 {
                              state MASTER                             //主服务器为MASTER
                              interface eth0                        //定义网络接口
                              virtual_router_id 50                    //主辅VRID号必须一致
                              priority 100                         //服务器优先级
                              advert_int 1
                              authentication {
                                auth_type pass
                                auth_pass 1111                       //主辅服务器密码必须一致
                              }
                              virtual_ipaddress {                   //配置VIP（实验需要修改）
                            192.168.4.15
                             }
                            }
                            virtual_server 192.168.4.15 80 {           //设置ipvsadm的VIP规则（实验需要修改）
                              delay_loop 6
                              lb_algo wrr                              //设置LVS调度算法为WRR
                              lb_kind DR                               //设置LVS的模式为DR
                              #persistence_timeout 50
                            #注意这样的作用是保持连接，开启后，客户端在一定时间内始终访问相同服务器
                              protocol TCP
                              real_server 192.168.4.100 80 {         //设置后端web服务器真实IP（实验需要修改）
                                weight 1                             //设置权重为1
                                TCP_CHECK {                            //对后台real_server做健康检查
                                connect_timeout 3
                                nb_get_retry 3
                                delay_before_retry 3
                                }
                              }
                            real_server 192.168.4.200 80 {       //设置后端web服务器真实IP（实验需要修改）
                                weight 2                          //设置权重为2
                                TCP_CHECK {
                                connect_timeout 3
                                nb_get_retry 3
                                delay_before_retry 3
                                }
                              }
                            }
                            [root@proxy1 ~]# systemctl start keepalived
                            [root@proxy1 ~]# ipvsadm -Ln                     #查看LVS规则
                            [root@proxy1 ~]# ip a  s                          #查看VIP配置
                        2）LVS2调度器设置Keepalived
                            [root@proxy2 ~]# vim /etc/keepalived/keepalived.conf
                            global_defs {
                              notification_email {
                                admin@tarena.com.cn                //设置报警收件人邮箱
                              }
                              notification_email_from ka@localhost    //设置发件人
                              smtp_server 127.0.0.1                //定义邮件服务器
                              smtp_connect_timeout 30
                              router_id  lvs2                        //设置路由ID号（实验需要修改）
                            }
                            vrrp_instance VI_1 {
                              state BACKUP                             //从服务器为BACKUP（实验需要修改）
                              interface eth0                        //定义网络接口
                              virtual_router_id 50                    //主辅VRID号必须一致
                              priority 50                             //服务器优先级（实验需要修改）
                              advert_int 1
                              authentication {
                                auth_type pass
                                auth_pass 1111                       //主辅服务器密码必须一致
                              }
                              virtual_ipaddress {                   //设置VIP（实验需要修改）
                            192.168.4.15
                            }
                            }
                            #################这里是lvs (ipvsadm)规则 实现集群###############
                            virtual_server 192.168.4.15 80 {          //自动设置LVS规则（实验需要修改）
                              delay_loop 6
                              lb_algo wrr                          //设置LVS调度算法为WRR
                              lb_kind DR                               //设置LVS的模式为DR
                              # persistence_timeout 50
                              #注意这样的作用是保持连接，开启后，客户端在一定时间内始终访问相同服务器
                              protocol TCP
                              real_server 192.168.4.100 80 {        //设置后端web服务器的真实IP（实验需要修改）
                                weight 1                              //设置权重为1
                                TCP_CHECK {                         //对后台real_server做健康检查
                                connect_timeout 3
                                nb_get_retry 3
                                delay_before_retry 3
                                }
                              }

                            real_server 192.168.4.200 80 {         //设置后端web服务器的真实IP（实验需要修改）
                                weight 2                              //设置权重为2
                                TCP_CHECK {
                                connect_timeout 3
                                nb_get_retry 3
                                delay_before_retry 3
                                }
                              }
                            }
                            [root@proxy2 ~]# systemctl start keepalived
                            [root@proxy2 ~]# ipvsadm -Ln                 #查看LVS规则
                            [root@proxy2 ~]# ip  a   s                    #查看VIP设置,可以查看ip地址



        配置HAProxy负载平衡集群  haproxy

                    haproxy通过 监听本机的任意端口(自定义),将监听的数据转发到目标ip:端口
                    优点: 支持 session cookie
                          可以通过 url 进行健康检查
                          效率 负载均衡速度 高于 nginx 低于 lvs
                          HAProxy 支出tcp udp 可以对mysql 进行负载均衡
                          调度算法丰富
                    缺点:正则弱于nginx
                        日志不如 nginx

                    注意事项：
                    将前面实验VIP、LVS等实验的内容清理干净！！！！！！
                    删除所有设备的VIP，清空所有LVS设置，关闭keepalived！！！
                    web1关闭多余的网卡与VIP，配置本地真实IP地址。

                    [root@web1 ~]# ifdown eth0
                    [root@web1 ~]# ifdown lo:0
                    [root@web1 ~]# nmcli connection modify eth1 ipv4.method manual \
                    ipv4.addresses 192.168.2.100/24 connection.autoconnect yes
                    [root@web1 ~]# nmcli connection up eth1
                    Web2关闭多余的网卡与VIP，配置本地真实IP地址。
                    [root@web2 ~]# ifdown eth0
                    [root@web2 ~]# ifdown lo:0
                    [root@web2 ~]# nmcli connection modify eth1 ipv4.method manual \
                    ipv4.addresses 192.168.2.200/24 connection.autoconnect yes
                    [root@web2 ~]# nmcli connection up eth1
                    proxy关闭keepalived服务，清理LVS规则。
                    [root@proxy ~]# systemctl stop keepalived
                    [root@proxy ~]# systemctl disable keepalived
                    [root@proxy ~]# ipvsadm -C
                    [root@proxy ~]# nmcli connection modify eth0 ipv4.method manual \
                    ipv4.addresses 192.168.4.5/24 connection.autoconnect yes
                    [root@proxy ~]# nmcli connection up eth0
                    [root@proxy ~]# nmcli connection modify eth1 ipv4.method manual \
                    ipv4.addresses 192.168.2.5/24 connection.autoconnect yes
                    [root@proxy ~]# nmcli connection up eth1

                    yum -y install haproxy


                    配置文件  vim/etc/haproxy/haproxy.cfg

                    global 全局设置
                        maxconn 软件最大并发量
                    default
                        maxconn 每个集群最大并发量 , 每个集群 并发量 相加超过   全局的maxconn 是不可以的

                    写法1 :listen
                            集群
                           listen
                            集群
                    写法2:
                         frontend main *:80
                            usr_backend static
                         backend static
                            balance     roundrobin
                            server      192.168.1.22
                    这两个写法都可以正常启动服务 推荐写法1,用的时候只保留一个 一下的全部删除
                    ##############################
                    # main frontend which proxys to the backends
                    #---------------------------------------------------------------------
                    frontend  main *:5000
                        acl url_static       path_beg       -i /static /images /javascript /stylesheets
                        acl url_static       path_end       -i .jpg .gif .png .css .js

                        use_backend static          if url_static
                        default_backend             app

                    #---------------------------------------------------------------------
                    # static backend for serving up images, stylesheets and such
                    #---------------------------------------------------------------------
                    backend static
                        balance     roundrobin
                        server      static 127.0.0.1:4331 check

                    #---------------------------------------------------------------------
                    # round robin balancing between the various backends
                    #---------------------------------------------------------------------
                    backend app
                        balance     roundrobin
                        server  app1 127.0.0.1:5001 check
                        server  app2 127.0.0.1:5002 check
                        server  app3 127.0.0.1:5003 check
                        server  app4 127.0.0.1:5004 check

                    ######################################################################



             1.配置后端Web服务器
                    设置两台后端Web服务（如果已经配置完成，可用忽略此步骤）
                        [root@web1 ~]# yum -y install httpd
                        [root@web1 ~]# systemctl start httpd
                        [root@web1 ~]# echo "192.168.2.100" > /var/www/html/index.html
                        [root@web2 ~]# yum -y install httpd
                        [root@web2 ~]# systemctl start httpd
                        [root@web2 ~]# echo "192.168.2.200" > /var/www/html/index.html
             2.部署HAProxy服务器
                    1）配置网络，安装软件
                        [root@haproxy ~]# yum -y install haproxy
                    2）修改配置文件
                        [root@haproxy ~]# vim /etc/haproxy/haproxy.cfg
                        global
                         log 127.0.0.1 local2   ###[err warning info debug]
                         chroot /usr/local/haproxy
                         pidfile /var/run/haproxy.pid ###haproxy的pid存放路径
                         maxconn 4000     ###最大连接数，默认4000
                         user haproxy
                         group haproxy
                         daemon       ###创建1个进程进入deamon模式运行
                        defaults
                         mode http    ###默认的模式mode { tcp|http|health } log global   ###采用全局定义的日志
                         option dontlognull  ###不记录健康检查的日志信息
                         option httpclose  ###每次请求完毕后主动关闭http通道
                         option httplog   ###日志类别http日志格式
                         option forwardfor  ###后端服务器可以从Http Header中获得客户端ip
                         option redispatch  ###serverid服务器挂掉后强制定向到其他健康服务器
                         timeout con nect 10000 #如果backend没有指定，默认为10s
                         timeout client 300000 ###客户端连接超时
                         timeout server 300000 ###服务器连接超时
                         maxconn  60000  ###最大连接数
                         retries  3   ###3次连接失败就认为服务不可用，也可以通过后面设置
                        listen stats 0.0.0.0:1080   #监听端口      这里使用 第一种写法
                            stats refresh 30s   #统计页面自动刷新时间
                            stats uri /stats   #统计页面url
                            stats realm Haproxy Manager #进入管理解面查看状态信息
                            stats auth admin:admin  #统计页面用户名和密码设置
                          #stats hide-version   #隐藏统计页面上HAProxy的版本信息
                        listen  websrv-rewrite 0.0.0.0:80
                           balance roundrobin
                           server  web1 192.168.2.100:80 check inter 2000 rise 2 fall 5   //2000 表示单次检测时间间隔 ms
                           server  web2 192.168.2.200:80 check inter 2000 rise 2 fall 5
                    3）启动服务器并设置开机启动
                        [root@haproxy ~]# systemctl start haproxy
                        [root@haproxy ~]# systemctl enable haproxy




             keepalived (vrrp)
                    浮动vip (高可用)
                    自动配置lvs规则 ,健康检查(tcp_check , http_get  , ssl_get)

                    两台proxy 配置文件 /etc/keeplive/keeplive.conf  只是请vrrp功能 没有配置其他 如下

                    ! Configuration File for keepalived

                    global_defs {
                       notification_email {
                         acassen@firewall.loc
                         failover@firewall.loc
                         sysadmin@firewall.loc
                       }
                       notification_email_from Alexandre.Cassen@firewall.loc
                       smtp_server 192.168.200.1
                       smtp_connect_timeout 30
                       router_id LVS_1   ###两台不同
                    }

                    vrrp_instance VI_1 {
                        state MASTER
                        interface eth0
                        virtual_router_id 51      ###两台相同
                        priority 100
                        advert_int 1
                        authentication {
                            auth_type PASS
                            auth_pass 1111      ###两台相同
                        }
                        virtual_ipaddress {
                            192.168.1.66          ###配置vip
                        }
                    }

关于块存储 文件存储 对象存储 之间的区别可查看 下面
https://www.zhihu.com/question/21536660

         块存储                文件存储                    对象存储
         （块设备）
概念    用高速网络（光纤）     使用文件系统，具有目录树        将数据和元数据
       专业连接服务器          结构                          当作一个对象
        的一种存储方式
速度    低延迟（10ms）热点突出  不同技术各有不同               100ms-1s 冷数据

可分步性  异地不现实            可分布式但又瓶颈                 适合各种大小

接口     Driver kernel module  POSIX （文件系统）             Restful api

典型技术    SAN                 HDFS                        AMAZON S3

适合场景   银行                  数据中心                     网络媒体文件存储

适合大文件
    ceph储存
        常见的存储类型(面试常考)
            DAS  直连存储(direct attach storage)  SATA  SAS(服务器)  IDE
            NAS  网络附加存储(network attach storage)  nfs  http samba  ftp  共享文件系统
            SAN  存储区域网络(iscsia):共享块设备(需要格式化后挂载使用)
        分布式存储(distributed filesystem 物理节点不一定要直连在本地)
            几乎可以扩展无线大的空间
            常见的分布式文件系统
                lustre
                Hadoop (大数据用的多)
                FastDFS
                Ceph  (目前比较多,且成分布式文件系统的标准)
                GlusterFS

        ceph 特点:
                高扩展 高可用 高性能
                提供对象存储 块存储 文件系统存储
                提供EB 级别 储存空间
                软件定义存储 已经成为行业趋势SDS(soft define storage) 不绑定厂商
        组成:
            osd     提供储存设备
            monitor 监控/管理  负责调度(取余算法,将数据平均分配到每个osd,至少三台负责 高可用)
            ceph    默认三副本, 大数据自动切割为小文件(要求至少三个osd)
                    若只装前 ceph-mon ceph-osd 只能块共享
            mds     文件系统
            rgw     提供对象存储 (类似于 百度云盘)
            clients 客户端
            journal(英文 日志) 缓存盘(生产环境需要ssd) 当用户储存文件时 ceph 会先存入缓存盘中,当ceph系统空闲的时候,转入后端 ceph储存盘

        要求
                准备四台KVM虚拟机，其三台作为存储集群节点，一台安装为客户端，实现如下功能：
                创建1台客户端虚拟机
                创建3台存储集群虚拟机
                配置主机名、IP地址、YUM源
                修改所有主机的主机名
                配置无密码SSH连接
                配置NTP时间同步
                创建虚拟机磁盘

            准备1 clients 3 node
            ip   4.10 4.11. 4.12 4.13

            1.安装准备
                1）物理机为所有节点配置yum源服务器。
                    提示：ceph10.iso在/linux-soft/02目录。
                    [root@room9pc01 ~]# mkdir  /var/ftp/ceph
                    [root@room9pc01 ~]# mount ceph10.iso /var/ftp/ceph/
                2）配置无密码连接(包括自己远程自己也不需要密码)，在node1操作。
                    [root@node1 ~]# ssh-keygen   -f /root/.ssh/id_rsa    -N ''
                    [root@node1 ~]# for i in 10  11  12  13
                     do
                         ssh-copy-id  192.168.4.$i
                     done
                3）修改/etc/hosts并同步到所有主机。
                    警告：/etc/hosts解析的域名必须与本机主机名一致！！！！
                     [root@node1 ~]# cat /etc/hosts
                    ... ...
                    192.168.4.10  client
                    192.168.4.11     node1
                    192.168.4.12     node2
                    192.168.4.13     node3
                    警告：/etc/hosts解析的域名必须与本机主机名一致！！！！
                    [root@node1 ~]# for i in 10  11  12  13
                    do
                    scp  /etc/hosts  192.168.4.$i:/etc/
                    done
                4）修改所有节点都需要配置YUM源，并同步到所有主机。
                    [root@node1 ~]# cat /etc/yum.repos.d/ceph.repo
                    [mon]
                    name=mon
                    baseurl=ftp://192.168.4.254/ceph/MON
                    gpgcheck=0
                    [osd]
                    name=osd
                    baseurl=ftp://192.168.4.254/ceph/OSD
                    gpgcheck=0
                    [tools]
                    name=tools
                    baseurl=ftp://192.168.4.254/ceph/Tools
                    gpgcheck=0
                    [root@node1 ~]# yum repolist                #验证YUM源软件数量
                    源标识            源名称                    状态
                    Dvd                redhat                    9,911
                    Mon                mon                        41
                    Osd                osd                        28
                    Tools            tools                    33
                    repolist: 10,013
                    [root@node1 ~]# for i in  10  11  12  13
                    do
                    scp  /etc/yum.repos.d/ceph.repo  192.168.4.$i:/etc/yum.repos.d/
                    done
                    5）所有节点主机与真实主机的NTP服务器同步时间。
                    提示：默认真实物理机已经配置为NTP服务器。
                    [root@node1 ~]# vim /etc/chrony.conf
                    … …
                    server 192.168.4.254   iburst
                    [root@node1 ~]# for i in 10 11 12 13
                    do
                         scp /etc/chrony.conf 192.168.4.$i:/etc/
                         ssh 192.168.4.$i "systemctl restart chronyd"
                     done
               5)准备存储磁盘

                    物理机上为每个虚拟机准备3块磁盘（可以使用命令，也可以使用图形直接添加）。
                     [root@room9pc01 ~]# virt-manager

            2.安装部署ceph集群

                要求
                    安装部署工具ceph-deploy
                    创建ceph集群
                    准备日志磁盘分区
                    创建OSD存储空间
                    查看ceph状态，验证
                ##################################
                思路
                    安装 ceph和插件
                        yum -y instal ceph-deploy
                        yum -y install ceph-mon ceph-osd ceph-mds ceph-radosgw
                        [monitor 是作为 监控主机的 osd 作为储存主机 ,扩容时 扩容osd 主机即可(将新的主机加入集群,修改配置文件;安装 ceph-osd.后准备磁盘 ,格式化 创建 osd 空间) ]
                    准备缓存盘(/dev/vdb)和磁盘(/dev/vdc d)
                        格式化磁盘
                        修改磁盘属主属组 为 ceph 确定其永久化设置
                    格式化osd磁盘(node1 node2 node3 只需要在node1 执行)
                        ceph-deploy disk  zap  node1:vdc   node1:vdd
                    创建OSD存储空间(node1 node2 node3 只需要在node1 执行)
                        ceph-deploy osd create node1:vdc:/dev/vdb1 node1:vdd:/dev/vdb2

                    检测状态
                        ceph -s
                    到这一步 块设备 就共享完成了
                    不考虑文件系统和对象存储
                ####################################################
                1）在node1安装部署工具，学习工具的语法格式。
                    [root@node1 ~]#  yum -y install ceph-deploy
                    #############################################
                    这个脚本需要无密码登录的支持
                    作用:远程链接 osd 启动服务 修改配置文件;;;当然没有也可以只不过需要手动配置 想想上千台
                    [root@node1 ~]#  ceph-deploy  --help    查询ceph-deploy 命令用法
                    [root@node1 ~]#  ceph-deploy mon --help 查询ceph-deploy mod 命令用法
                2）创建目录
                    [root@node1 ~]#  mkdir ceph-cluster
                    [root@node1 ~]#  cd ceph-cluster/   这个脚本只能在这个目录下执行,否则报错

            2.部署Ceph集群
                1）创建Ceph集群配置,在ceph-cluster目录下生成Ceph配置文件。
                    在ceph.conf配置文件中定义monitor主机是谁。
                    [root@node1 ceph-cluster]# ceph-deploy new node1 node2 node3
                    查看配置文件
                    [root@node1 ceph-cluster]# tailf ceph.conf
                    [global]
                    fsid = 6cfa3825-ca90-4d77-ae58-410bfb9cb0fd
                    集群包含的主机
                    mon_initial_members = node1, node2, node3
                    mon_host = 192.168.4.11,192.168.4.12,192.168.4.13
                    ##########需要密码#####密码文件在ceph.mon.keyring 中
                    auth_cluster_required = cephx ####密码占位符
                    auth_service_required = cephx
                    auth_client_required = cephx

                2）给所有节点安装ceph相关软件包。
                    [root@node1 ceph-cluster]# for i in node1 node2 node3
                    do
                        ssh  $i "yum -y install ceph-mon ceph-osd ceph-mds ceph-radosgw"
                    done
                3）初始化所有节点的mon服务，也就是启动mon服务（主机名解析必须对）。
                    [root@node1 ceph-cluster]# ceph-deploy mon create-initial


                4)常见错误及解决方法（非必要操作，有错误可以参考）：
                    如果提示如下错误信息：
                    [node1][ERROR ] admin_socket: exception getting command descriptions: [Error 2] No such file or directory


                解决方案如下（在node1操作）：
                    先检查自己的命令是否是在ceph-cluster目录下执行的！！！！如果确认是在该目录下执行的create-initial命令，依然报错，可以使用如下方式修复。
                    [root@node1 ceph-cluster]# vim ceph.conf      #文件最后追加以下内容
                    public_network = 192.168.4.0/24
                    修改后重新推送配置文件:
                    [root@node1 ceph-cluster]# ceph-deploy --overwrite-conf config push node1 node2 node3


            3.创建OSD
                备注：每台电脑的由vbd1分区而成(vdb1和vdb2)这两个分区用来做存储服务器的journal缓存盘。
                1)准备
                    [root@node1 ceph-cluster]# for i in node1 node2 node3
                    do
                         ssh $i "parted /dev/vdb mklabel gpt"
                         ssh $i "parted /dev/vdb mkpart primary 1 50%"
                         ssh $i "parted /dev/vdb mkpart primary 50% 100%"
                     done
                2)磁盘分区后的默认权限无法让ceph软件对其进行读写操作，需要修改权限。

                    node1、node2、node3都需要操作，这里以node1为例。
                    [root@node1 ceph-cluster]# chown  ceph.ceph  /dev/vdb1
                    [root@node1 ceph-cluster]# chown  ceph.ceph  /dev/vdb2
                    #上面的权限修改为临时操作，重启计算机后，权限会再次被重置。
                    #我们还需要将规则写到配置文件实现永久有效。
                    #规则：如果设备名称为/dev/vdb1则设备文件的所有者和所属组都设置为ceph。
                    #规则：如果设备名称为/dev/vdb2则设备文件的所有者和所属组都设置为ceph。
                    ###########################################################
                    [root@node1 ceph-cluster]# vim /etc/udev/rules.d/70-vdb.rules
                    ENV{DEVNAME}=="/dev/vdb1",OWNER="ceph",GROUP="ceph"
                    ENV{DEVNAME}=="/dev/vdb2",OWNER="ceph",GROUP="ceph"
                    将配置文件传递node2　node3
                    [root@node1 rules.d]# scp 70-vdb.rules root@node3:/etc/udev/rules.d/
                    [root@node1 rules.d]# scp 70-vdb.rules root@node2:/etc/udev/rules.d/

                3）初始化清空磁盘数据（仅node1操作即可）。 ceph 会远程链接node2 3 进行处理
                    [root@node1 ceph-cluster]# ceph-deploy disk  zap  node1:vdc   node1:vdd
                    [root@node1 ceph-cluster]# ceph-deploy disk  zap  node2:vdc   node2:vdd
                    [root@node1 ceph-cluster]# ceph-deploy disk  zap  node3:vdc   node3:vdd


                4）创建OSD存储空间（仅node1操作即可）
                    重要：很多同学在这里会出错！将主机名、设备名称输入错误！！！
                    [root@node1 ceph-cluster]# ceph-deploy osd create \
                     node1:vdc:/dev/vdb1 node1:vdd:/dev/vdb2
                    //创建osd存储设备，vdc为集群提供存储空间，vdb1提供JOURNAL缓存，
                    //一个存储设备对应一个缓存设备，缓存需要SSD，不需要很大
                    [root@node1 ceph-cluster]# ceph-deploy osd create \
                     node2:vdc:/dev/vdb1 node2:vdd:/dev/vdb2
                    [root@node1 ceph-cluster]# ceph-deploy osd create \
                     node3:vdc:/dev/vdb1 node3:vdd:/dev/vdb2

                    常见错误及解决方法（非必须操作）。
                    使用osd create创建OSD存储空间时，如提示下面的错误提示：
                    [ceph_deploy][ERROR ] RuntimeError: bootstrap-osd keyring not found; run 'gatherkeys'
                    可以使用如下命令修复文件，重新配置ceph的密钥文件：
                    [root@node1 ceph-cluster]#  ceph-deploy gatherkeys node1 node2 node3


            4.检测状态
                1) 查看集群状态
                    [root@node1 ceph-cluster]# ceph -s
                    cluster 6cfa3825-ca90-4d77-ae58-410bfb9cb0fd
                     health HEALTH_OK
                     monmap e2: 3 mons at {node1=192.168.4.11:6789/0,node2=192.168.4.12:6789/0,node3=192.168.4.13:6789/0}
                            election epoch 8, quorum 0,1,2 node1,node2,node3
                     osdmap e34: 6 osds: 6 up, 6 in
                            flags sortbitwise
                     pgmap v72: 64 pgs, 1 pools, 0 bytes data, 0 objects
                            202 MB used, 119 GB / 119 GB avail
                               64 active+clean

                2）常见错误（非必须操作）。
                     如果查看状态包含如下信息：
                     health: HEALTH_WARN
                            clock skew detected on  node2, node3…
                     clock skew表示时间不同步，解决办法：请先将所有主机的时间都使用NTP时间同步！！！
                     Ceph要求所有主机时差不能超过0.05s，否则就会提示WARN，如果使用NTP还不能精确同步时间，可以手动修改所有主机的ceph.conf，在[MON]下面添加如下一行：
                     mon clock drift allowed = 1
                     如果状态还是失败，可以尝试执行如下命令，重启ceph服务：
                     [root@node1 ~]#  systemctl restart ceph\*.service ceph\*.target


            5.创建Ceph块存储
                    使用Ceph集群的块存储功能:实现
                        创建块存储镜像
                        客户端映射镜像
                        创建镜像快照 #只对块设备有效
                        使用快照还原数据
                        使用快照克隆镜像
                        删除快照与镜像

                1）查看存储池
                    [root@node1 ~]# ceph osd lspools
                    0 rbd,
                2）创建镜像、查看镜像
                    [root@node1 ~]# rbd create demo-image --image-feature  layering --size 10G
                    [root@node1 ~]# rbd create rbd/image --image-feature  layering --size 10G  两种方法创建 镜像

                    #这里的demo-image和image为创建的镜像名称，可以为任意字符。
                    #--image-feature参数指定我们创建的镜像有哪些功能，layering是开启COW功能。
                    #提示：ceph镜像支持很多功能，但很多是操作系统不支持的，我们只开启layering。

                    [root@node1 ~]# rbd list
                    [root@node1 ~]# rbd info demo-image
                    rbd image 'demo-image':
                        size 10240 MB in 2560 objects
                        order 22 (4096 kB objects)
                        block_name_prefix: rbd_data.d3aa2ae8944a
                        format: 2
                        features: layering
            6.动态调整
                1）缩小容量
                    [root@node1 ~]# rbd resize --size 7G image --allow-shrink
                    [root@node1 ~]# rbd info image
                2）扩容容量
                    [root@node1 ~]# rbd resize --size 15G image
                    [root@node1 ~]# rbd info image
            7.通过KRBD访问

                1）客户端通过KRBD访问
                    #客户端需要安装ceph-common软件包
                    #拷贝配置文件（否则不知道集群在哪）
                    #拷贝连接密钥（否则无连接权限）
                    [root@client ~]# yum -y  install ceph-common
                    [root@client ~]# scp 192.168.4.11:/etc/ceph/ceph.conf  /etc/ceph/
                    [root@client ~]# scp 192.168.4.11:/etc/ceph/ceph.client.admin.keyring \
                    /etc/ceph/
                    #######################################################
                    块共享只要用户有权限就可以挂载,可以同时读,但是不可以同时写入.
                    文件系统 共享 就可以同时读写.
                    #######################################################
                    [root@client ~]# rbd map imagename //写创建镜像的名字
                    ###########将块设备连接到本机###########
                    [root@client ~]#  lsblk
                    [root@client ~]# rbd showmapped
                    #####查看块设备的信息#########
                    id pool image snap device
                    0  rbd  image -    /dev/rbd0
                2) 客户端格式化、挂载分区
                    [root@client ~]# mkfs.xfs /dev/rbd0
                    [root@client ~]# mount /dev/rbd0 /mnt/
                    [root@client ~]# echo "test" > /mnt/test.txt

            8.创建镜像快照
                1) 查看镜像快照（默认所有镜像都没有快照）。
                    [root@node1 ~]# rbd snap ls image  (image指的是刚创建的 镜像 )
                2) 给镜像创建快照。
                    [root@node1 ~]# rbd snap create image --snap image-snap1
                    #为image镜像创建快照，快照名称为image-snap1
                    [root@node1 ~]# rbd snap ls image
                    SNAPID NAME            SIZE
                         4 image-snap1 15360 MB
                3) 删除客户端写入的测试文件
                l    [root@client ~]# rm  -rf   /mnt/test.txt
                    不允许在线还原下线后还原
                    [root@client ~]# umount  /mnt
                4) 还原快照
                    [root@node1 ~]# rbd snap rollback image --snap image-snap1
                    #客户端重新挂载分区
                    [root@client ~]# mount /dev/rbd0 /mnt/
                    [root@client ~]# ls  /mnt
            9.创建快照克隆
                1)快照克隆
                     rbd snap protect image --snap image-snap1
                     rbd snap rm image --snap image-snap1 //会失败 ,已经保护了
                     rbd clone \
                     image --snap image-snap1 image-clone --image-feature layering
                    //使用image的快照image-snap1克隆一个新的名称为image-clone镜像

                2)查看克隆镜像与父镜像快照的关系
                    [root@node1 ~]#  rbd info image-clone
                    rbd image 'image-clone':
                        size 15360 MB in 3840 objects
                        order 22 (4096 kB objects)
                        block_name_prefix: rbd_data.d3f53d1b58ba
                        format: 2
                        features: layering
                        flags:
                        parent: rbd/image@image-snap1
                    #克隆镜像很多数据都来自于快照链
                    #如果希望克隆镜像可以独立工作，就需要将父快照中的数据，全部拷贝一份，但比较耗时！！！
                    [root@node1 ~]#  rbd flatten image-clone
                    [root@node1 ~]#  rbd info image-clone
                    rbd image 'image-clone':
                        size 15360 MB in 3840 objects
                        order 22 (4096 kB objects)
                        block_name_prefix: rbd_data.d3f53d1b58ba
                        format: 2
                        features: layering
                        flags:
                    #注意，父快照信息没了！
                    [root@node1 ~]#  rbd snap unprotect image --snap image-snap1     #取消快照保护
                    [root@node1 ~]#  rbd snap rm image --snap image-snap1            #可以删除快照

                3） 客户端撤销磁盘映射
                    [root@client ~]# umount /mnt
                    [root@client ~]# rbd showmapped
                    id pool image        snap device
                    0  rbd  image        -    /dev/rbd0
                    //语法格式:
                    [root@client ~]# rbd unmap /dev/rbd0


        块储存应用案例
            要求:使用上次实验,演示块存储在KVM虚拟化中的应用案例，实现以下功能：
                Ceph创建块存储镜像
                客户端安装部署ceph软件
                客户端部署虚拟机
                客户端创建secret
                设置虚拟机配置文件，调用ceph存储

            方法:
                使用Ceph存储创建镜像。
                KVM虚拟机调用Ceph镜像作为虚拟机的磁盘。
            1)创建磁盘镜像
                [root@node1 ~]# rbd create vm1-image --image-feature  layering --size 10G
                [root@node1 ~]# rbd  list
                [root@node1 ~]# rbd  info  vm1-image
                [root@node1 ~]# qemu-img  info  rbd:rbd/vm1-image
                image: rbd:rbd/vm1-image
                file format: raw
                virtual size: 10G (10737418240 bytes)
                disk size: unavailable
            2）Ceph认证账户（仅查看即可）。
                Ceph默认开启用户认证，客户端需要账户才可以访问，默认账户名称为client.admin，key是账户的密钥。
                可以使用ceph auth添加新账户（案例我们使用默认账户）。
                [root@node1 ~]# cat /etc/ceph/ceph.conf                    //配置文件
                [global]
                mon_initial_members = node1, node2, node3
                mon_host = 192.168.2.10,192.168.2.20,192.168.2.30
                auth_cluster_required = cephx                                //开启认证
                auth_service_required = cephx                                //开启认证
                auth_client_required = cephx                                //开启认证
                [root@node1 ~]# cat /etc/ceph/ceph.client.admin.keyring        //账户文件
                [client.admin]
                    key = AQBTsdRapUxBKRAANXtteNUyoEmQHveb75bISg==
            3）创建KVM虚拟机（注意：这里使用真实机当客户端！！！）。
                 使用virt-manager创建2台普通的KVM虚拟机。
            4）配置libvirt secret（注意：这里使用真实机当客户端！！！）。
                编写账户信息文件，让KVM知道ceph的账户名称。
                [root@room9pc01 ~]# vim secret.xml            //新建临时文件，内容如下
                <secret ephemeral='no' private='no'>
                        <usage type='ceph'>
                                <name>client.admin secret</name>
                        </usage>
                </secret>
                #使用XML配置文件创建secret
                [root@room9pc01 ~]# virsh secret-define secret.xml
                733f0fd1-e3d6-4c25-a69f-6681fc19802b
                //随机的UUID，这个UUID对应的有账户信息
            5)给secret绑定admin账户的密码，密码参考 node1 /etc/ceph/ceph.client.admin.keyring文件

                [root@room9pc01] virsh secret-set-value \
                --secret 733f0fd1-e3d6-4c25-a69f-6681fc19802b \
                --base64 AQBTsdRapUxBKRAANXtteNUyoEmQHveb75bISg
                //这里secret后面是之前创建的secret的UUID
                //base64后面是client.admin账户的密码
                //现在secret中既有账户信息又有密钥信息
            6）虚拟机的XML配置文件。
                每个虚拟机都会有一个XML配置文件，包括：
                虚拟机的名称、内存、CPU、磁盘、网卡等信息。
                [root@room9pc01 ~]# vim /etc/libvirt/qemu/vm1.xml
                //修改前内容如下
                <disk type='file' device='disk'>
                      <driver name='qemu' type='qcow2'/>
                      <source file='/var/lib/libvirt/images/vm1.qcow2'/>
                      <target dev='vda' bus='virtio'/>
                      <address type='pci' domain='0x0000' bus='0x00' slot='0x07' function='0x0'/>
                    </disk>
                不推荐直接使用vim修改配置文件，推荐使用virsh edit修改配置文件，效果如下：
                [root@room9pc01] virsh edit vm1                //vm1为虚拟机名称
                <disk type='network' device='disk'>
                      <driver name='qemu' type='raw'/>
                      <auth username='admin'>
                      <secret type='ceph' uuid='733f0fd1-e3d6-4c25-a69f-6681fc19802b'/>
                      </auth>
                      <source protocol='rbd' name='rbd/vm1-image'>          <host name='192.168.4.11' port='6789'/>     </source>
                    <target dev='vda' bus='virtio'/>
                      <address type='pci' domain='0x0000' bus='0x09' slot='0x08' function='0x0'/>
                 </disk>
                注意：如果有设备编号冲突的情况下，需要修改设备编号，任意修改一个数字即可。


                磁盘格式化前 叫块设备 完成后叫 文件系统
                fat32 ntfs ext4 xfs
                格式化后文件系统:
                iNode 默认254字节/每块 : 存放在block中存放的文件(数据,也叫元数据,数据的数据)的详细信息(在哪里存放了什么 权限 属主 大小 创建时间)  : 占磁盘的 少部分
                block 默认4k/每块     : 存放文件 数据 : 占磁盘的大部分

                ######这两部分默认的 大小可以调整####
                当磁盘存小文件的时候就不要用 大的block
                当磁盘存大文件的时候就不要用 小的block
                当block的数量 太大的时候寻址就会太慢
                删 压根就没删除
                写 真的写上去了
                mkfs.ext4 -i -b  /dev/vdbc


        Ceph文件系统

            问题:延续前面的实验，实现Ceph文件系统的功能。具体实现有以下功能：
                部署MDSs节点
                创建Ceph文件系统
                客户端挂载文件系统
            思路:
                创建两个rbd 共享池
                合并两个池子 a b(假装是一块硬盘)
                安装ceph-mds //支持文件系统

            注意 : 一下 方法和 案例中不同
                选取 node3
            1) 拷贝配置文件启动服务
                由于ceph-mds 已经安装到 node1-3 中 所以在 只需要在node1中
                node1 中操作
                先进入目录  才能 使用 ceph-deploy
                cd ceph-cluster/
                ceph-deploy mds create node3
                来启动服务
            2)制作共享池
                ceph中只能创建一个文件系统
                不同于 nfs samba
                node3中操作
                创建共享池
                #######################################################
                [root@node3 ~]# ceph osd pool create cephfs_data 128
                //创建存储池，对应128个PG
                [root@node3 ~]# ceph osd pool create cephfs_metadata 128
                //创建存储池，对应128个PG
                    PG  是个逻辑上的概念 ,  1 osd 对应 若干个  PG ,这里PG 相当于文件夹个数  且数量需为 2^n 个

                metadata 元数据
                创建文件系统
                #######################################################################

                创建Ceph文件系统
                [root@node3 ~]# ceph mds stat                     //查看mds状态
                e2:, 1 up:standby
                [root@node3 ~]# ceph fs new myfs1 cephfs_metadata cephfs_data
                new fs with metadata pool 2 and data pool 1
                //注意，先写medadata池，再写data池
                //默认，只能创建1个文件系统，多余的会报错
                检查
                [root@node3 ~]# ceph fs ls
                name: myfs1, metadata pool: cephfs_metadata, data pools: [cephfs_data ]
                [root@node3 ~]# ceph mds stat
                e4: 1/1/1 up {0=node3=up:creating}
            6）客户端挂载
                [root@client ~]# mount -t ceph 192.168.4.13:/  /mnt/cephfs/ \
                -o name=admin,secret=AQBTsdRapUxBKRAANXtteNUyoEmQHveb75bISg==
                //注意:文件系统类型为ceph
                //192.168.4.13为MON节点的IP（不是MDS节点）
                //admin是用户名,secret是密钥
                //密钥可以在/etc/ceph/ceph.client.admin.keyring中找到

        ceph 对象存储
            软件 : ceph-rad


            创建对象存储服务器
                要求:

                延续前面的实验，实现Ceph对象存储的功能。具体实现有以下功能：
                安装部署Rados Gateway
                启动RGW服务
                设置RGW的前端服务与端口
                客户端测试


            1.部署对象存储服务器

                1）准备实验环境，要求如下：
                    IP地址:192.168.4.15
                    主机名:node5
                    配置yum源（包括rhel、ceph的源）
                    与Client主机同步时间
                    node1允许无密码远程node5
                    修改node1的/etc/hosts，并同步到所有node主机
                2）部署RGW软件包
                    [root@node1 ~]# ceph-deploy install --rgw node5
                    同步配置文件与密钥到node5
                    [root@node1 ~]# cd /root/ceph-cluster
                    [root@node1 ~]# ceph-deploy admin node5
                3）新建网关实例
                    启动一个rgw服务
                    [root@node1 ~]# ceph-deploy rgw create node5
                    登陆node5验证服务是否启动
                    [root@node5 ~]# ps aux |grep radosgw
                    ceph      4109  0.2  1.4 2289196 14972 ?       Ssl  22:53   0:00 /usr/bin/radosgw -f --cluster ceph --name client.rgw.node4 --setuser ceph --setgroup ceph
                    [root@node5 ~]# systemctl  status ceph-radosgw@\*
                4）修改服务端口
                    登陆node5，RGW默认服务端口为7480，修改为8000或80更方便客户端记忆和使用
                    [root@node5 ~]#  vim  /etc/ceph/ceph.conf
                    [client.rgw.node5]
                    host = node5
                    rgw_frontends = "civetweb port=8000"
                    //node5为主机名
                    //civetweb是RGW内置的一个web服务
            2.客户端测试（扩展选做实验）

                1）curl测试
                    [root@client ~]# curl  192.168.4.15:8000
                    <?xml version="1.0" encoding="UTF-8"?><ListAllMyBucketsResult xmlns="http://s3.amazonaws.com/doc/2006-03-01/"><Owner><ID>anonymous</ID><DisplayName></DisplayName></Owner><Buckets></Buckets></ListAllMyBucketsResult>
                2）使用第三方软件访问
                                                登陆node5（RGW）创建账户
                    [root@node5 ~]#  radosgw-admin user create \
                    --uid="testuser" --display-name="First User"
                    … …
                    "keys": [
                            {
                                "user": "testuser",
                                "access_key": "5E42OEGB1M95Y49IBG7B",
                                "secret_key": "i8YtM8cs7QDCK3rTRopb0TTPBFJVXdEryRbeLGK6"
                            }
                        ],
                    ... ...
                    #
                    [root@node5 ~]# radosgw-admin user info --uid=testuser
                    //testuser为用户，key是账户访问密钥
                3）客户端安装软件
                    [root@client ~]#  yum install s3cmd-2.0.1-1.el7.noarch.rpm
                    修改软件配置（注意，除了下面设置的内容，其他提示都默认回车）
                    [root@client ~]#  s3cmd --configure
                    Access Key: 5E42OEGB1M95Y49IBG7BSecret Key: i8YtM8cs7QDCK3rTRopb0TTPBFJVXdEryRbeLGK6
                    S3 Endpoint [s3.amazonaws.com]: 192.168.4.15:8000
                    [%(bucket)s.s3.amazonaws.com]: %(bucket)s.192.168.4.15:8000
                    Use HTTPS protocol [Yes]: No
                    Test access with supplied credentials? [Y/n] n
                    Save settings? [y/N] y
                    //注意，其他提示都默认回车
                4）创建存储数据的bucket（类似于存储数据的目录）
                    [root@client ~]# s3cmd ls
                    [root@client ~]# s3cmd mb s3://my_bucket
                    Bucket 's3://my_bucket/' created
                    [root@client ~]# s3cmd ls
                    2018-05-09 08:14 s3://my_bucket
                    [root@client ~]# s3cmd put /var/log/messages s3://my_bucket/log/
                    [root@client ~]# s3cmd ls
                    2018-05-09 08:14 s3://my_bucket
                    [root@client ~]# s3cmd ls s3://my_bucket
                    DIR s3://my_bucket/log/
                    [root@client ~]# s3cmd ls s3://my_bucket/log/
                    2018-05-09 08:19 309034 s3://my_bucket/log/messages
                    测试下载功能
                    [root@client ~]# s3cmd get s3://my_bucket/log/messages /tmp/
                    测试删除功能
                    [root@client ~]# s3cmd del s3://my_bucket/log/message





shell
复杂的操作变得简单化,自动化
在编写脚本时需要考虑,使用费交互式命令
    eg: sleep 5 &
    将sleep 放入后台执行
    安装ksh
        yum repolist
        yum -y install ksh ###安装 ksh 解释器,没有bash 好用
        [root@server0 ~]# ksh
        #
    bash的快捷键
        ctr + a 回到行首
        ctr + e 回到行尾
        ctr + d 结束当前输入
        ctr + z 暂停挂起
        ctr + m 回车
        ctr + u 删除光标至行首的所有内容
        ctr + k 删除光标至行尾的所有内容
        ctr + w 删除光标 前面的一个单词
        ctr + s 冻结终端
        ctr + q 恢复终端
    修改命令的历史纪录
        [root@server0 ~]# vim /etc/profile
        HISTSIZE=1000
        [root@server0 ~]# ls -A
        .bash_history           ####该文件保存了最近的命令;历史记录
    重定向
         覆盖   追加
           >    >>  收集正确信息
           2>   2>> 收集错误信息
           &>   &>> 收集所有信息
           < 输入重定向

    bash 优点
         支持 tab 快捷键  历史命令  别名  重定向  管道 等等
         选项 -x
        pstree 进程树
    脚本编写步骤
        1.声明解释器
        2.书写脚本功能描述,变量含义, 使用位置, 作者(生产环境必写)
        3.编写执行指令
            1)添加x权限
            chmod +x test1.sh
            2)执行命令 时记得 在命令前 添加 ./ 指定当前目录下
            ./test1.sh
            3)或者使用解释器直接执行(可以不用添加权限,使用) ,新开启解释器
            bash test1.sh           //脚本执行完毕后退出新开启的解释器
            4)使用source 直接执行 脚本, 使用当前解释器执行
            source test1.sh    //执行完成后退出当前解释器, source 和 bash 使用时 在脚本中没有exit 时效果时一样的,
                               //但当脚本有了 exit 就会 不同,
                               //表现在 source 会在执行后关闭当前解释器,
                               ///bash则会关闭新开启的(其实脚本执行完毕后退出新开启的解释器,
                               //所以在结尾添加 exit 对于bash 来说区别不大).
    编写一个搭建yum仓库的脚本
            #!/bin/bash
            rm -rf /etc/yum.repos.d/*.repo
            echo '[nsd]
            name = nsd
            baseurl=ftp://172.25.254.250/centos-1804/
            enabled = 1
            gpgcheck = 0
            ' > /etc/yum.repos.d/abc.repo
            yum repolist

            bash -x test.sh 在执行脚本过程中 显示错误信息

    编写一个自动安装 vsftpd的 脚本 并检测服务  是否 启动
            #!/bin/bash
            yum -y install vsftpd &> /dev/null  ###安装 过程不显示
            systemctl restart vsftpd
            systemctl enable vsftpd
            systemctl status vsftpd   ###检测服务是否启动

    0 是一个文件描述符，表示标准输入(stdin)
    1 是一个文件描述符，表示标准输出(stdout)

    2 是一个文件描述符，表示标准错误(stderr)

    1>&2 意思是把标准输出重定向到标准错误.

    2>&1 意思是把标准错误输出重定向到标准输出。

    &>filename 意思是把标准输出和标准错误输出都重定向到文件filename中

    变量
        使用固定的名称表示变化的量
        自定义变量
            定义变量 : 变量名称= 变量值
            查看变量 : echo$变量名称
            取消变量 : unset 变量名称
        系统变量
            环境变量
                一级提示符
                    PS1
                二级提示符
                    PS2
            预定义变量
                $0 显示脚本名
                $$ 显示脚本进程号
                $? 显示上条指令是否成功  非0表示执行失败
                $# 统计变量个数
                $* 显示所有位置变量的内容
            位置变量
                $1 脚本名后第一个参数
                $2 脚本名后第二个参数
                $3 脚本名后第三个参数
                env 查看所有环境变量(了解)
                set 查看所有的变量(了解)
                '' 界定范围 取消字符的特殊定义, 比如$(屏蔽$的作用) 单引号
                "" 界定范围 双引号
                `` 反撇号 $() 获取指令的输出结果
            关闭回显 stty -echo
            开启回显 stty echo
            全局变量 export a=20  (系统变量默认为全局变量)
            局部变量 a=20(只在源解释器生效)
                [root@server0 opt]# export c=10089
                [root@server0 opt]# bash
                [root@server0 opt]# echo $c
                10089
                [root@server0 opt]# exit
                [root@server0 opt]#

                a+=b -----> a=a+b
        shell 中的 数学运算
            方法一 expr 值1 运算符 值2
                [root@svr5 ~]# X=1234                              //定义变量X
                [root@svr5 ~]# expr  $X  +  78                      //加法
                1312
                [root@svr5 ~]# expr  $X  -  78                       //减法
                1156
                [root@svr5 ~]# expr  $X  \*  78                      //乘法，操作符应添加\转义 或者 '*'
                96252
                [root@svr5 ~]# expr  $X  /  78                      //除法，仅保留整除结果
                15
                [root@svr5 ~]# expr  $X  %  78                     //(求余数)求模
                64

            方法二  echo $[值1 运算符 值2]  echo $((值1 运算符 值2))

                [root@svr5 ~]# X=1234
                [root@svr5 ~]# echo $[X+78]
                1312
                [root@svr5 ~]# echo $[X-78]
                1156
                [root@svr5 ~]# echo $[X*78]
                96252
                [root@svr5 ~]# echo $[X/78]
                15
                [root@svr5 ~]# echo $[X%78]
                64

            方法三  通常对变量进行计算,不显示结果(通常用来做 变量的增减 定义)
                [root@svr5 ~]# X=123                [root@svr5 ~]# let y=X+22
                [root@svr5 ~]# echo $y
                1256
                [root@svr5 ~]# let X++;  echo $X        # X++(X=X+1)
                [root@svr5 ~]# let X--;  echo $X        # X--(X=X-1)
                [root@svr5 ~]# let X+=78 ; echo $X        # X+=78(X=X+78)
                [root@svr5 ~]# let X-=78 ; echo $X     # X-=78(X=X-78)
                [root@svr5 ~]# let X*=78 ; echo $X     # X*=78(X=X*78)
                [root@svr5 ~]# let X/=78 ; echo $X     # X/=78(X=X/78)
                [root@svr5 ~]# let X%=78 ; echo $X     # X%=78(X=X%78)

            方法四 计算小数
                方法1-3 不支持小数
                交互式计算
                [root@svr5 ~]# bc
                bc 1.06.95
                Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation, Inc.
                This is free software with ABSOLUTELY NO WARRANTY.
                For details type `warranty'.
                12.34+56.78                                        //加法
                69.12
                12.34-56.78                                        //减法
                -44.44
                12.34*56.78                                        //乘法
                700.66
                12.34/56.78                                        //除法
                0
                quit                                              //退出交互计算器
                scale=3                                           // 小数点后3位

                非交互计算
                [root@svr5 ~]# echo 'scale=4;12.34+5.678' | bc
                18.018
                [root@svr5 ~]# echo 'scale=4;12.34*5.678' | bc
                70.0665
                [root@svr5 ~]# echo 'scale=4;12.34/5.678' | bc
                2.1733

    条件测试 (重要)
        作用:对于系统环境进行预判,增减脚本灵活性和成果率
            test 表达式  或   [表达式]
                表达式两边至少要留一个空格
                1)
                test $USER=='root'; echo $?  ###注意空格
                0
                2)
                [ $UID == '1' ] ; echo $?   ###注意空格 每个参数之间用空格隔开 //推荐使用第二种
                1

        && 前面执行成功后执行后面的命令 逻辑与
        || 前面执行失败后执行后面的命令  逻辑或
        ;  前面执行后执行后面命令,无逻辑关系
        -z 检测变量的值是否为空,空为真
                [root@svr5 ~]# var1="nb" ; var2=""
                [root@svr5 ~]# [ -z "$var1" ] && echo "空值" || echo "非空值"
                非空值
                [root@svr5 ~]# [ -z $var2 ] && echo "空值" || echo "非空值"
                空值                                      //变量var2已设置，但无任何值，视为空
                [root@svr5 ~]# [ ! -z $var1 ]                //测试var1是否为非空

        -eq   等于
        -ne   不等
        -gt   大于
        -ge   大于等于
        -lt   小于
        -le   小于等于
         wc -l 统计行数
         who查看 登录用户数量
        eg: 统计server 登录用户数量大于三时邮件报警 管理员
            #!/bin/bash
            n=`who | wc -l`
            [ $n -gt 3 ] && echo 'fbiwarning $n' |mail -s 'fbi' root && echo 'dangerous'|| echo 'seaf'
            crontab -e
            */2 * * * * /opt/test.sh
        -e 文档存在为真 (查询 文件和 目录 是否存在 )
        -d 文档存在,且必须为目录为真(只能查询 目录 是否存在)
        -f 文档存在,且必须文件为真(只能用来筛选文件是否存在)
        -r 判断对象是否可读
           此测试对root用户无效，无论文件是否设置r权限，root都可读
        -w 判断对象是否可写
            此测试同样对root用户无效，无论文件是否设置w权限，root都可写：
        -x 判断对象是否具有可执行权限
            这个取决于文件本身、文件系统级的控制，root或普通用户都适用：
            eg:
                [ -d root ]; echo $?
                1
                [ -d mail ]; echo $?
                0
                ls -ld mail
                drwxrwxr-x. 2 root mail 4096 5月   9 14:04 mail
                [ -r mail ];echo $?
                0
                [ -w mail ];echo $?
                0
                [ -x mail ];echo $?
                0

    判断语句
        格式:
            1)单分支
                    if [条件测试] ; then

                       命令序列

                    fi
            2)双分支
                    if [条件测试] ; then
                        命令序列1
                    else
                        命令序列2
                    fi
            3)多分支
                    if [条件测试] ; then
                        命令序列1
                    elif [条件测试] ; then
                        命令序列2
                        ...
                    else
                        命令序列n

                    fi
            eg:
                #!/bin/bash
                ping -c 5 -i 0.2 -W 1 $1 &> /dev/null
                if [ $? -eq 0  ] ;then
                        echo 'connect'
                else
                        echo 'disconnect'
                fi

    循环语句
        for循环
            for i in 值1 值2
            do
                执行命令
            done

        eg: 使用for循环编写测试 范围 ip 的连通性
            #!/bin/bash
            a=0
            b=0
            for i in {1..10}
            do
            ping -c 2 -i 0.3 -W 1 172.25.0.$i &> /dev/null
                    if [ $? -eq 0 ] ;then
                    echo "172.25.0.${i} connect"
                      let a++
                   else
                    echo "172.25.0.${i} disconnetcion'"
                     let b++
                    fi

            done

            echo "$a connect $b disconnetc"


        while 循环
            while 条件测试
            do
                命令
            done

        eg: 一个自动猜数字的 脚本 范围是 100以内
            #!/bin/bash
            #n=$[RANDOM%101]
            u=0
            while [ 1 -eq 1 ]
            do
            n=$[RANDOM%101]

            s=$[RANDOM%101]

             let u++
            # read -p '输入一个数字' s
              if [ $n -eq $s ] ; then
                   echo ' 似李'
                  echo "${u}次成功"
                  exit
              elif [ $s -gt $n ] ;then
                    echo '大了'
              else
                    echo '小了'
              fi
            done

        case 分支
                命令结束后 添加  `;;` 而非每行 结尾添加
                case 变量 in
                    条件)
                    命令1 ;;
                    条件)
                    命令2 ;;
                    *)
                    默认命令序列
                esac
            eg:创建 自动部署 nginx 的脚本

                #!/bin/bash
                yum -y install gcc openssl-devel pcre-devel
                tar -xf nginx-1.12.2.tar.gz
                cd nginx-1.12.2
                ./configure
                make
                make install

            Nginx默认安装路径为/usr/local/nginx,该目录下会提供4个子目录，分别如下：
            /usr/local/nginx/conf	配置文件目录
            /usr/local/nginx/html	网站页面目录
            /usr/local/nginx/logs	Nginx日志目录
            /usr/local/nginx/sbin	主程序目录
            [root@svr5 ~]# /usr/local/nginx/sbin/nginx                //启动服务
            [root@svr5 ~]# /usr/local/nginx/sbin/nginx    -s stop        //关闭服务
            [root@svr5 ~]# /usr/local/nginx/sbin/nginx    -V            //查看软件信息
            [root@server0 ~]# netstat -ntulp | grep nginx             //查看nginx 状态
            tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      32743/nginx: master

            netstat 命令
                    查询系统中启动的端口信息 ,
                    -ntulp 连着用 推荐
                    -n以数字格式显示端口号
                    -t显示TCP连接的端口
                    -u显示UDP连接的端口
                    -l显示服务正在监听的端口信息，如httpd启动后，会一直监听80端口
                    -p显示监听端口的服务名称是什么（也就是程序名称
            eg: 使用case 编辑一个 检测 nginx 启动 停止 显示 状态的命令.
                #!/bin/bash
                case $1 in
                start|o) ###这里表示 脚本后接的参数 可以为 start 或者 o 简写 提高输入效率
                        /usr/local/nginx/sbin/nginx ;;
                stop|e)
                        /usr/local/nginx/sbin/nginx -s stop ;;
                restart|r)
                        /usr/local/nginx/sbin/nginx -s stop
                         /usr/local/nginx/sbin/nginx  ;;
                status|u)
                        netstat -ntulp | grep -q nginx   ####这里的 -q 是查询后 不输出结果
                        [ $? -eq 0 ] && echo 'start success' || echo 'not start' ;;
                *)
                        echo 'enter start stop restart status' ;;
                esac

        函数
            格式1:
                 function 函数名 {
                         命令
                                }

            格式2:
                 函数名(){
                        命令序列
                        }
            改变终端颜色输出字符的颜色 并改 回来
            echo -e "\033[31mABCD\033[0M" ##31 表示颜色
                 #!/bin/bash
                co(){
                echo -e "\033[$1m$2\033[0m"
                }
                co 34 SIX
                co 35 SIX
        中断 退出 等待
            wait //等待所有后台结束后退出 程序 ;;配合  & 使用
            exit  //退出整个脚本
            break //退出脚本中的循环,执行循环后的任务
            continue  //退出当前循环进行下一次循环


            eg: 求出 1-20 以内 被 6 整除 数字的 平方
                #!/bin/bash
                for i in {1..20}
                do
                n=$[i%6]
                         [ $n -ne 0 ] && continue
                         echo $[i*i]

                done
        字符串截取及切割
            取出指定位置的字符串
            字符串截取
            字符字符串起始 第一位为0
            ${变量名:起始位置:长度}
            若起始位置为第一个字符 则 起始位可以省略
                ${x::5}

            这个和python中列表的字符切割是不同的

            >>> py_str = 'python'
            >>> py_str[2:4]    #包含起始下标的字符,不包含结束下标的字符
             'th'

            子串替换的两种用法：
            只替换第一个匹配结果：
            ${变量名/old/new}
            替换全部匹配结果：
            ${变量名//old/new}
            字符串掐头去尾：
            从左向右，最短匹配删除：${变量名#*关键词}
            从左向右，最长匹配删除：${变量名##*关键词}
            从右向左，最短匹配删除：${变量名%关键词*}
            从右向左，最长匹配删除：${变量名%%关键词*}

            最长匹配表示需要删除到该行 不包含  关键词即可
            最端匹配表示删除遇到的第一个 关键词

        eg:
                [root@server0 ~]# a=123asdfasdf
                [root@server0 ~]# echo ${a//asd/123}
                123123f123f

                [root@server0 ~]# echo $a
                root:x:0:0:root:/root:/bin/bash
                [root@server0 ~]# echo ${a%root*}       #从右往左 删除
                root:x:0:0:root:/
                [root@server0 ~]# echo ${a%%root*}

                [root@server0 ~]# echo ${a#*root}     #从左往右 删除
                :x:0:0:root:/root:/bin/bash
                [root@server0 ~]# echo ${a##*root}
                :/bin/bash

        eg:    将 后缀为 txt 的文件修改为 doc
                #!/bin/bash
                for i in `ls *.txt`
                do
                        m=${i%.*}
                        mv $i $m.doc
                        echo 'success'
                done
        字符串初值的处理
                定义初始值/默认值
                给变量进行备用数值定义:当 用户不输入 数据时  变量 为默认值
                ${p:-132}
                eg:
                #!/bin/bash
                read -p 'username' u
                useradd $u
                read -p  'passwd' p
                echo ${p:-132} | passwd --stdin $u
                #[ $p$# -eq 0 ] && echo 'passwd def'
                #[ $p -z  ] && echo 'passwd def'
                [ -z $p  ] && echo 'passwd def' #### -z 检测参数是否为空



    正则表达式   (非常重要啊)
        基本正则表达式

                    基本表

            正则符号                描述
               ^                 匹配行首
               $                 匹配行尾
               []                集合,匹配集合中的任意单个字符  // 或   ###[a-Z] 匹配任意字符大小写,- 表示范围
               [^]               对集合取反                  // 或    ###^[^a-z] 匹配不一小写字母开头的行
               .                 匹配任意单个字符
               *                 匹配前一个字符任意次数 [*不允许单独使用]
               \{n,m\}           匹配前一个字符n-m次
               \{n\}             匹配前一个n次
               \{n,\}            匹配前一个字符n次以上
               \{\}              保留



                         扩展表

            正则符号                描述
               +                 单个字符至少匹配一次
               ?                 单个字符最多匹配一次
               {n,m}             单个字符匹配n到m
               ()                组合为整体保留
               |                 或者
               *                 匹配前一个字符任意次数 [*不允许单独使用]
               \b                单词边界

                \w  匹配字母数字下划线 [a-Z0-9]
                \s  匹配空格 ,制表符(也就是tab)
                \d  匹配数字  使用时  添加-p 选项

                grep -n 查找时显示行号
                     -v 查找时取反
                     -i 忽略大小写

            保留(a)(b)  粘贴\1 \2root:$6$pxzChEI0$bc7XwvscnkXm1RJwxsKIeo7bTKOLEL0ncorcv8GxSFnyRhx8bSr4FvbPzEGdfMmjVTa9cq.HrwQnKoerhYswo/::0:99999:7:::
            eg:  [root@server0 ~]# grep "bash$" /etc/passwd
                    root:x:0:0:root:/root:/bin/bash    //匹配开头
                 [root@server0 ~]# grep "^root" /etc/passwd
                    root:x:0:0:root:/root:/bin/bash    //匹配结尾

                 [root@server0 ~]# grep "[ab]" 1.txt  //查找有字符a或b 的行
                    a
                    abc
                    aa
                    bb
                    abcd
                    xyzaa                                         ^ 这里表示取反
                 [root@server0 ~]# grep "[^ab]" 1.txt  //查找除了字符 a或b 以外的行
                    abc
                    ccc
                    abcd
                    xyzaa
                 [root@server0 ~]# grep "ab." 1.txt   // 查找 有ab或任意单个字符在一起的行
                    abc
                    abcd

                 [root@server0 ~]# grep ".*" 1.txt   // 匹配任意 . 代表任意字符 * 代表 不限次数
                    a
                    abc
                    aa
                    bb
                    ccc
                    abcd
                    xyzaa
                 [root@server0 ~]# grep "c\{2\}" 1.txt    //匹配字符c 两次和行
                    ccc
                 [root@server0 ~]# grep "c\{1,2\}" 1.txt  //匹配字符c 出现 1-2 次的行
                    abc
                    ccc
                    abcd
                 [root@server0 ~]# grep "c\{2,\}" 1.txt     //匹配字符 c 出现 2次 及 以上之上的 行
                    ccc
                 扩展 使用 egroup  , group 不支持扩展

                 [root@server0 ~]# egrep "bc{1,1}" 1.txt    // 匹配字符 bc 出现 1次的行
                    abc
                    abcd
                 [root@server0 ~]# egrep "c{2}" 1.txt         // 匹配c 出现两次的行
                    ccc
                 [root@server0 ~]# egrep "c{1,2}" 1.txt      // 匹配 c 出现1-2 次
                    abc
                    ccc
                    abcd

                 [root@server0 ~]# egrep "c+" 1.txt          //单个字符c 最少匹配一次 (一次以上)
                    abc
                    ccc
                    abcd
                 [root@server0 ~]# egrep "c?" 1.txt      // 单个字符c 最多匹配一次(最多1次)
                    a
                    abc
                    aa
                    bb
                    ccc
                    abcd
                    xyzaa

                 [root@server0 ~]# egrep "ac?" 1.txt   // 单个字符c 最多匹配一次(最多1次) 且a 必须存在
                    a
                    abc
                    aa
                    abcd
                    xyzaa
                    zaa

                 [root@server0 ~]# egrep "ac?|a+" 1.txt  //c 最多一次 a至少一次  a 必须存在
                    a
                    abc
                    aa
                    abcd
                    xyzaa
                    zaa
                 [root@server0 ~]# egrep "a\b" 1.txt    // 以a 结尾且 后面为空字符或者与其他字符隔开
                    a
                    aa
                    xyzaa
                    zaa
                 [root@server0 ~]# egrep "(ab){2}" 1.txt  // 查找单词ab 出现两次

                    ababazc

                 [root@server0 ~]# egrep "\bab" 1.txt   // 查找 单词 ab 且前面无 字符 或者 与字符隔开
                    tta abc
                    ttan abcd
                    ababazc

                 [root@server0 ~]# egrep "[0-9]" 1.txt    //查找数字  字母也相似 [a-z]
                    45646134654
                    1323yttyyaas

        sed 流式编辑器  (非常重要, 主要用来修改配置文件,可以查看和编辑文档 ,逐行处理)
                选项 :
                        -n 屏蔽默认输出
                        -r 支持扩展正则
                        -i 写入文件 (加入这个选项才 意味着 确认写入   )

                        p 输入出文件内容
                        d 删除文件内容
                        s 替换
                        s/old/new
            sed 用法
                  1) 前置命令|  sed [选项] '条件指令'
                  2) sed [选项] '条件指令' 文件

                sed -n '$=' 1.txt       //统计文件行数
                sed -n 'p' 1.txt        //看全部
                sed -n '1p' 1.txt       //看第一行
                sed -n '1,3p' 1.txt     //看前三行  ','
                sed -n '1p;3p' 1.txt   //看前第1行和第3行  ';'
                sed -n '2,+2p' 1.txt  //查看从第2行以及,后面两行
                sed -n '1~2p' 1.txt  //查看从奇数行
                sed -n '2~2p' 1.txt  //查看从偶数行  从第二行开始 步长为2
                sed -n '/^root/,/^adm/p' /etc/passwd  //匹配 以root 开头 到以adm开头 的行  , 表示区间 ; 表示语句结束

                sed 'p' 1.txt      //输出文件所有行,并附加默认输出
                ###注意使用正则表达式的语法
                sed -n '/^root/p' 1.txt   // 输出以root开头的
                sed -n '/^root/!p' 1.txt  // 输出不以root 开头的
                sed -rn '/o{2}/p' 1.txt   // 使用 扩展正则,匹配两个o的行
                sed -n '2,+2p' 1.txt        //输出第2行以及后面两行

                d 删除

                sed -n '2~2d' 1.txt        //删除偶数行
                sed -n '$d' 1.txt        //删除最后一行
                sed -n '/xml/!d' 1.txt        //删除不包含xml的行  ! 取反
                sed  '/svr5/,$d' /etc/hosts  //删除匹配到的svr5一行,到最后一行


                sed -n 's/2017/2077/' 2.txt // 将每行第一个2017 替换为2077
                sed -n 's/2017/2077/g' 2.txt // 将每行所有2017 替换为2077
                sed -n '2s/2017/2077/2' 2.txt // 将第二行的第二个2017 替换为2077
                sed -n '2s/2017/2077/2 ; 2s/2017/2077/2' 2.txt // 将第二行的第二个和第二行第三个2017 替换为2077
                               先执行      后执行
                sed 's!/bin/bash!/sbin/sh!' 2.txt  //将bin/bash 替换为 sbin/sh  !为分隔符号同 /
                sed 's/.//2 ; s/.$//' 2.txt   //删除每行第2个字符和最后一个字符

                                                        \1 可视为位置变量
                sed -r 's/(^.)(.*)(.$)/\3\2\1/' 2.txt  //使用扩展正则表达式 将文件的 头和尾互换 // ()有复制的效果


                sed -rn '75s/(        #)(.*)(fastcgi)(.*)/\2\3.conf;/p' nginx.conf   //测试  将75 行 # 取消并且将 fastcgi_params; 替换为fastcgi.conf;
                        #    include        fastcgi_params; //源
                             include        fastcgi.conf;   //修改后


                sed -i "106,120 s/    #//"  nginx.conf  //取消配置文件中 开头的#,来取消注释
                sed -n "106,120 s/    #//p"  nginx.conf //测试取消注释输出是否正常,在替换时不要写p否则会在文件中再输出.


            eg: 编写一个自动部署 ftp 的 脚本 并开启自动上传功能
                #!/bin/bash
                yum -y install vsftpd
                cp /etc/vsftpd/vsftpd.conf /etc/vsftpd/backup.conf
                sed -i 's/^#anon/anon/' /etc/vsftpd/vsftpd.conf
                chmod 777 /var/ftp/pub
                systemctl restart vsftpd
                systemctl enable vsftpd

                #### 将 passwd 文件 上下倒过来 输出,且 每行从左右倒过来;;; 不加 rev 只上下倒
                tac /etc/passwd | rev
                nigolon/nibs/:/::27:27:x:pmudpct

        sed文本块处理动作
                i    行前插入文本         ###2iyy 在第二行前添加文本yy; 4,7iyy 在4-7 每行前插入
                a    行后插入文本         ###2auu 在第二行后添加文本uu ;/^xx/ayy 在以xx开头的行后添加
                c    替换整行            ###2cyy  将第二行替换为 yy
                sed -i '17a test' a.txt 这里加空格是为了 好区分
                面试问 取出指定行的文本
                head -10 a.txt | head -1 取出第10 行
                sed -n '10p' a.txt
            多行文本的修改
                    sed -n '2cxx\nyy' m.txt  ####将第二行 替换为xx yyy
                    #### 在 hosts 文件末尾添加 两行
                    sed  '$a192.168.4.5 server0.tarena.com svr5\n192.175.217.56 www.baidu.com' /etc/hosts
            eg:   ###  取出 对应用户的密码 并将其输出
                  ###  取出以bash 结尾 且替换 ':' 之后的部分 为空
                  sed  -n '/bash$/s/:.*//p' /etc/passwd
                  sed  -n '/bash$/p' /etc/passwd | sed -n 's/:.*//p' /etc/passwd
                  ###
                  遍历 文本的写法 while中的选项read 不可更换
                  cat /etc/passwd | while read line ; do echo "[$line]"; done
                  ### 从 shadow 中 取出 root的 密码
                  ####################################
                  匹配 以root 开头且不包含:部分的 \1  表示粘贴 第一个部分

                  sed -rn 's/root:([^:]+).*/\1/p' /etc/shadow
            #######################################################################
                  #!/bin/bash
                  sed -n '/bash$/s/:.*//p' /etc/passwd | while read var ;
                  do
                  echo -n "$var -->"
                  #####################?????#############
                  sed  -rn "s/$var:([^:]+1).*/\1/p" /etc/shadow
                  done
        awk基本用法(非常重要;;;字符串的处理)
            按行读,按列取
            格式:
                1) 前置命令|awk [选项] '[条件][指令]'
                2) awk[选项] '[条件][指令]' 文件
                有多条指令可以以; 分割
            常用的参数
                -F : 定义分隔符;;; 可省略(默认空格或者tab位)
                -F, 分隔符为','

                    ###显示文件的第三行 第一行
                    eg:awk '{print $3,$1}' user.txt
                    ###取出passwd 中的 用户名
                    awk -F: '{print $1}' /etc/passwd
                    ###取出shadow 中的密码
                    awk -F: '{print $2}' /etc/shadow
                    /var/log/secure 保存的安全相关的 日志文件
                    ### 检测等失败的 ip 地址
                    awk '$6=="Failed"{print $11}' /var/log/secure
                    #### 查看空闲 内存
                    free |awk '{print $3}'
                    ###查看网络流量
                    ifconfig eth0 |awk '/RX p/{print $5}'
            awk 内置变量
                有特殊含义,可直接使用
                    变量           用法
                    FS           保存或设置字段分隔符,例如FS=":" ,与-F功能一样
                    $n           指定分割的第n个字段,如   $1 , $3 分别表示第 1,3 列
                    $0           当前读入的整行文本内容
                    NF           纪录当前处理的字段个数(列数)
                    NR           纪录当前已读入行的数量 (行数)
                awk 过滤的时机
                    开始BEGIN{}
                        读入第一行 文本之前执行
                        初始化操作
                    过程{}
                        逐行处理文本执行相应的处理
                        常见的指令编辑模块
                    结束END{}
                        处理完最后一行文本后执行
                        一般用来输出结果
                eg:
                     输出行列
                    awk -F: '{print NR,NF}' /etc/passwd
                     输入 每行的最后一列
                    awk -F: '{print $NF} '  /etc/passwd
                    统计passwd 中以bash 结尾的 用户数量并打野出来
                    awk -F: 'BEGIN{x=0}/bash$/{print $1;x++}END{print x} '  /etc/passwd

                eg: 如何筛选出系统中cpu使用率最高的部分,并输出
                    ### 显示 系统信息
                    [root@server0 ~]# ps -eo %mem,%cpu,ucmd
                  ### $1  $2   $3
                    %MEM %CPU CMD
                     0.7  0.0 systemd
                     0.0  0.0 kthreadd
                     0.0  0.0 ksoftirqd/0
                                                    A=A+$2
                    ps -eo %mem,%cpu,ucmd | awk '{A[$3]+=$2}END{for (i in A)print A[i],i}' | sort -n
                    ### 显示 系统中内存占用最大的部分
                    ps -eo %mem,%cpu,ucmd | awk '{A[$3]+=$1}END{for (i in A)print A[i],i}' | sort -n


                eg: 编写脚本 要求如下
                    检测cpu 负载              uptime    uptime | awk '{print $(NF-2)}'|  sed 's/,//'
                    网卡流量                  ifconfig   ifconfig eth0 | awk '/RX p/{print $5/1024^2"Mib"}'
                    内存剩余容量               free       free -m | awk '/Mem/{print $4"MIB"}'
                    计算机账户数量             df          df -h | awk '/\/$/{print $(NF-2)}'
                    当前登录计算机账户数量      /etc/passwd /  who  awk 'END{print NR}' /etc/passwd
                    计算机当前开启进程数量      ps aux          ps aux | awk 'END{print NR}'
                    本机安装软件包数量         rpm -qa         rpm -qa | awk 'END{print NR}'
                脚本如下:
                    #!/bin/bash
                    echo -ne "系统负载:\t"
                    uptime | awk '{print $(NF-2)}'|  sed 's/,//'
                    uptime | awk '{printf "%.2F",$(NF-2)}'
                                 echo -ne "网卡流量\t"
                    ifconfig eth0 | awk '/RX p/{print $5/1024^2"Mib"}'
                                 echo -ne " 内存剩余容量\t"
                    free -m | awk '/Mem/{print $4"MIB"}'
                                       echo -ne "计算机账户数量\t"
                    df -h | awk '/\/$/{print $(NF-2)}'
                                     echo -ne  " 当前登录计算机账户数量\t"
                    awk 'END{print NR}' /etc/passwd
                                     echo -ne  "计算机当前开启进程数量\t"
                    ps aux | awk 'END{print NR}'
                           echo -ne " 本机安装软件包数量\t"
                    rpm -qa | awk 'END{print NR}'
            补充:
            每秒执行一次 xxx,配合其他命令使用 来持续检测 .
            watch -n 1 'ps aux'
            echo -n  不换行
            echo -e  对转义字符进行解释
            echo -t  tab
            echo -r  回到行首显示
                    ###实现类似 计时器的功能
                    for i in {00..99};do
                    > echo -ne "id:${i}\r "
                    > sleep 1
                    > done
                      id:05
                    ### 进度条  主要用 \033[110Ga 的 功能
                                          110 表示输出的列数,a 代表输出内容
                    #!/bin/bash
                    astr="|-->"
                    for i in {00..100};do
                            echo -en "\033[110G${i}%"
                            echo -en "\033[${i}G${astr}"
                            sleep 0.2
                    done




            用awk写一个 wc 功能
                awk按行读,按列取
                #!/bin/bash
                #自定义变量 chars 变量存储字符个数,自定义变量 words 变量存储单词个数
                #awk 内置变量 NR 存储行数
                #length()为 awk 内置函数,用来统计每行的字符数量,因为每行都会有一个隐藏的$,所以每次统计后都+1
                #wc 程序会把文件结尾符$也统计在内,可以使用 cat -A 文件名,查看该隐藏字符
                # $0  当前读入的整行文本内容
                awk '{chars+=length($0)+1;words+=NF} END{print NR,words,chars}' $1

                chars=chars+length($0)+1
                words=words+NF   //awk按列


LNMP

    以一个完整的项目来演示第二个阶段所学

        project DAY01
                1.服务器硬件
                    ECC内存 具有数据校验功能
                    服务器宽度
                    1U = 44.45mm =4.45cm
                    2U
                    4U
                    机柜也分 1u 2u 的
                    服务器用sas 接口 (硬盘) 也指出SATA 接口
                    远程控制卡
                    RAID : 服务器的RAID 支持类型需要有RAID卡 来提供支持
                        write_back  回写 : 先写缓存,再写磁盘 写入速度块但是 突发断电会导致 数据丢失
                        write_throuth  直写: 同时写入 缓存和磁盘 安全 写入速度慢

                        若RADI中磁盘损坏,将坏掉的磁盘拿出来,换上新的磁盘 RAID会自动恢复
                        但是当损毁的磁盘数量超过RAID的限制的时候,会导致数据恢复失败
                        ,可以使用热备盘(hote spares 不推荐在RAID5 上做热备 最好用RAID6 )来减少,RAID数据丢失的可能性.

                    服务的远程管理:
                        1)dell服务器 远程管理
                        iDARAC 远程管理配置iDRAC需要授权使用，
                        有授权的情况下可以直接通过浏览器访问：http://服务器IP，
                        远程管理服务器，没有授权的情况下可以通过端口重定向将服务器上的显示内容重定向到远程管理端的电脑上
                        （一般是用自己的笔记本远程服务器），这种方式不需要授权。
                        进入BIOS Settings后，选择Serial Communication菜单
                        将控制台重定向到com2，设置Serial Device=com1，Serial Device=com2
                        2）初始化清空iDRAC设置
                        进入iDRAC Setting界面选择Rest iDRAC configuration to defaults

                        3）配置iDRAC网络
                        进入iDRAC Setting界面选择network
                        选择网卡并配置IP地址
                        开启IPMI智能平台管理接口（配置后可以通过命令行管理服务器），客户端安装ipmitool软件包

                        4）配置远程管理账户
                        进入iDRAC Setting界面选择User Configuration

                        配置账户名称root，并设置密码

                        5）远程管理端主机配置，安装ipmitool软件包
                        [root@centos7 ~]# yum -y install ipmitool
                        常用命令操作列表如下。
                        [root@centos7 ~]# ipmitool -I lanplus -U root -H 服务器IP  power status
                        #查看服务器电源状态
                        [root@centos7 ~]# ipmitool -I lanplus -U root -H 服务器IP  power on
                        #开启服务器电源
                        [root@centos7 ~]# ipmitool -I lanplus -U root -H 服务器IP  power off
                        #关闭服务器电源
                        [root@centos7 ~]# ipmitool -I lanplus -U root -H 服务器IP  power reset
                        #重启服务器电源
                        [root@centos7 ~]# ipmitool -I lanplus -U root -H 服务器IP  sol activate
                        #远程管理

            使用LNMP搭建网站WordPress
                    配置 IP eht1 为 192.168.2.11

                    记得扩容 虚拟机磁盘
                    ##########################################################
                    LANG=en growpart /dev/vda 1  ##扩展/dev/vda 的第一个分区空间
                    lsblk
                    blkid /dev/vda1
                    xfs_growfs /dev/vda1###扩展/dev/vda1 文件系统
                    df -h
                    ########################################################
                2.部署lnmp
                    要求:
                        安装LNMP平台相关软件
                        配置Nginx实现动静分离
                        配置数据库，创建账户与密码
                        上线Wordpress代码
                        使用Wordpress后台管理界面，调整Wordpress版式
                        所需软件 在运维 下的 WordPress 中有

                    物理机作为clients 虚拟机作为 ser 2.11


                    1)安装部署LNMP软件
                        mariadb（数据库客户端软件）、mariadb-server（数据库服务器软件）、
                        mariadb-devel（其他客户端软件的依赖包）、php（解释器）
                        、php-fpm（进程管理器服务）、php-mysql（PHP的数据库扩展包）


                            yum -y install gcc automake autoconf libtool make
                            [root@centos7 ~]# yum -y install gcc openssl-devel pcre-devel
                            [root@centos7 ~]# useradd -s /sbin/nologin  nginx
                            [root@centos7 ~]# tar -xvf nginx-1.12.2.tar.gz
                            [root@centos7 ~]# cd nginx-1.12.2
                            [root@centos7 nginx-1.12.2]# ./configure   \
                            --user=nginx   --group=nginx \
                            --with-http_ssl_module   \
                            --with-http_stub_status_module  ////Nginx监控模块
                            [root@centos7 nginx-1.12.2]# make && make install
                            [root@centos7 ~]# yum -y install   mariadb   mariadb-server   mariadb-devel
                            [root@centos7 ~]# yum -y install   php        php-mysql        php-fpm
                        2)启动服务(nginx、mariadb、php-fpm)
                            [root@centos7 ~]# /usr/local/nginx/sbin/nginx                 #启动Nginx服务
                            [root@centos7 ~]# echo "/usr/local/nginx/sbin/nginx" >> /etc/rc.local
                            #########这两个文件都需要添加x权限,似乎在虚拟机中只给 /etc/rc.local x 权限 某些开机自启不会执行
                            [root@centos7 ~]# chmod +x /etc/rc.local                       #给开机自启文件添加x权限
                            [root@centos7 ~]# chmod +x /etc/rc.d/rc.local                  #给开机自启文件添加x权限

                            [root@centos7 ~]# ss -utnlp | grep :80                        #查看端口信息
                            [root@centos7 ~]# systemctl start   mariadb                   #启动mariadb服务器
                            [root@centos7 ~]# systemctl enable  mariadb
                            [root@centos7 ~]# systemctl start  php-fpm                   #启动php-fpm服务
                            [root@centos7 ~]# systemctl enable php-fpm
                        3）修改Nginx配置文件，实现动静分离
                            修改配置文件，通过两个location实现动静分离，一个location匹配动态页面，一个loation匹配其他所有页面。
                            注意修改默认首页为index.php!
                            [root@centos7 ~]# vim /usr/local/nginx/conf/nginx.conf
                            ...省略部分配置文件内容...
                            location / {
                                        root   html;
                                        index  index.php index.html index.htm;
                                    }
                            ...省略部分配置文件内容...
                            location ~ \.php$ {
                                        root           html;
                                        fastcgi_pass   127.0.0.1:9000;
                                        fastcgi_index  index.php;
                                        include        fastcgi.conf;
                                    }
                            ...省略部分配置文件内容...
                            [root@centos7 ~]# /usr/local/nginx/sbin/nginx -s reload            #重新加载配置
                        3）配置数据库账户与权限
                            为网站提前创建一个数据库、添加账户并设置该账户有数据库访问权限。
                            [root@centos7 ~]# mysql
                            MariaDB [(none)]> create database wordpress character set utf8mb4;
                            MariaDB [(none)]> grant all on wordpress.* to wordpress@'%' identified by 'wordpress';
                            MariaDB [(none)]> grant all on wordpress.* to wordpress@'localhost' identified by 'wordpress';
                            MariaDB [(none)]> flush privileges;
                            MariaDB [(none)]> exit
                            提示：在mysql和mariadb中%代表匹配所有，这里是授权wordpress用户可以从任意主机连接数据库服务器，生产环境建议仅允许特定的若干主机访问数据库服务器。


                    (2)上线wordpress代码
                        1）上线PHP动态网站代码
                            [root@centos7 ~]# unzip wordpress.zip
                            [root@centos7 ~]# cd wordpress
                            [root@centos7 wordpress]# tar -xf wordpress-5.0.3-zh_CN.tar.gz
                            [root@centos7 wordpress]# cp -r  wordpress/*  /usr/local/nginx/html/
                            [root@centos7 wordpress]# chown -R apache.apache  /usr/local/nginx/html/
                             //我们应当保证php-fpm用户与 /nginx/html/的属主属组一致,才能确保WordPress各个插件能够正常升级
                            提示：动态网站运行过程中，php脚本需要对网站目录有读写权限，而php-fpm默认启动用户为apache。
                        2)初始化网站配置（使用客户端访问web服务器IP）
                            [root@client ~]# firefox http://192.168.2.11/
                            密码wordpress
                            用户名wordpress
                            数据库名wordpress
                            数据库主机192.168.2.11
                            之后按照 步骤来

        project day02
            我们将网站分为 耦合(所有业务在一台服务器上,) 和 解耦合(将业务分开,在不同的服务器上运行,提高可靠性)
            1.网站架构的转变
                接上一个实验我门将web1中的 动态网站 数据库独立(由于数据库还没有学,只将数据库基本的功能做分离)出去,
                并保证数据库迁移到新的数据库中,

                数据库 是会消耗 较高的内存的
                脚本则消耗 较高的 cpu


                从单机版本转变到集群架构
                    单机版本单台服务器包场
                    集群对任务进行细分 不同服务器提供不同 任务

                                                 web服务器(静态页面集群,不需要链接数据库)

                    client-------->调度服务器集群  ----web服务器集群 (动态页面需要数据库 代码 php Java, -------->数据库务器(mariadb 数据库,之后还会做数据库集群,高可用,读写分离  ) ------->存储服务器(专门用来对整个系统提供存储空间)
                               |                     web服务器集群 session 保持)
                               |
                            DNS服务器


                            缓存服务器
                    一下是从 软件角度 将 lnmp 分类

                    1.单机版LNMP
                        用户量少时使用，简单、成本低、存在单点故障
                    2.独立数据库服务器

                          独立数据库服务器是将网站静态文件、代码文件等资料与数据库分离的架构，当用户量增加时单机的处理能力有限，
                        PHP或JAVA代码的执行需要消耗大量CPU资源，数据库的增删改查需要调用大量的内存资源，将两者分离可以减轻服务器的压力

                        Web服务器和数据库服务器的压力都可以得到有效改善，访问量有所增加。但是服务器依然存在单点故障问题。
                    3.Web服务器集群与Session保持
                          我们可以通过Nginx、Haproxy代理服务器实现Web负载均衡集群，也可以使用LVS调度器实现Web负载均衡集群。
                        部署完Web集群后还需要考虑如何进行Session会话保持，方法很多，如：根据源IP保持，代理服务器重写Cookie信息，
                        共享文件系统保存session，使用数据库共享session等等。

                        但是如果只有一台调度器依然会导致单点故障的问题，因此还需要使用Keepalived或Heartbeat之类的软件进行高可用配置

                        对于网站内容而言可以分离为动态页面和静态页面，静态页面就需要数据文件，动态页面则需要CPU解析代码，需要消耗大量的CPU资源，
                        因此可以将静态和动态分离为两组服务器，动态页面有脚本代码组成，是一种基于网页的应用程序，因此这一组服务器也称为应用服务器，


                    4.动静分离、数据库集群

                        随着服务器的增加，虽然性能与并发量得到了明显的提升，但是数据的一致性、管理的便利性成为了新的问题，因此就需要增加统一的存储服务器，
                        实现数据的同步一致，可以使用NFS，GlusterFS、Ceph等软件实现该功能

                        此时所有应用服务器都连接一台数据库服务器进行读写操作，而且后期随着数据库中的数据不断增加，
                        会导致数据库成为整个网站的瓶颈！这就需要我们对数据进行分库分表，创建数据库主从或者数据库集群，实现读写分离

                    5.缓存服务器与业务模型

                        对于静态数据我们可以通过varnish、squid或者nginx进行缓存，将数据缓存到距离用户更近的位置，构建CDN（内容分发网络）架构。
                        对于传统的SQL数据库而言，我们也可以通过增加NoSQL数据库，实现数据缓存的功能，提升数据库的访问速度。
                        备注：数据库相关知识在第三阶段课程有详细介绍，第二阶段项目暂时不做数据库优化。
                        最后，基于前面的架构，我们还可以将网站按照公司的业务进行分离，每个业务都可以是一个独立的集群


                        也可以通过 业务对lnmp 进行分类(解耦合)





                LNP+Mariadb 数据库分离

                    配置 IP eht1 为 192.168.2.21
                    1.部署数据库服务器

                        1）准备一台独立的服务器，安装数据库软件包
                            [root@database ~]# yum -y install mariadb mariadb-server mariadb-devel
                            [root@database ~]# systemctl start mariadb
                            [root@database ~]# systemctl enable mariadb
                        2)将之前单机版LNMP网站中的数据库迁移到新的数据库服务器。
                            登陆192.168.2.11主机，备份数据库并拷贝给新的服务器，关闭旧的数据库服务。
                                #################冷迁移##############数据量过大时不推荐使用#######
                                #################热迁移--配合灰度发布############################
                            [root@centos7 ~]# mysqldump wordpress > wordpress.bak
                            [root@centos7 ~]# scp wordpress.bak 192.168.2.21:/root/
                            [root@centos7 ~]# systemctl stop mariadb
                            [root@centos7 ~]# systemctl disable mariadb
                            登陆192.168.2.21主机，使用备份文件还原数据库。
                            创建空数据库：
                            [root@database ~]# mysql
                            MariaDB [(none)]> create database wordpress character set utf8mb4;
                            MariaDB [(none)]> exit
                            使用备份文件还原数据：
                            [root@database ~]# mysql wordpress < wordpress.bak
                            重新创建账户并授权访问：
                            [root@database ~]# mysql
                            MariaDB [(none)]> grant all on wordpress.* to wordpress@'%' identified by 'wordpress';
                            MariaDB [(none)]> flush privileges;
                            MariaDB [(none)]> exit
                        3）修改wordpress网站配置文件，调用新的数据库服务器。
                            Wordpress在第一次初始化操作时会自动生产配置文件：wp-config.php，登陆192.168.2.11修改该文件即可调用新的数据库服务。
                            [root@centos7 ~]# vim /usr/local/nginx/html/wp-config.php
                            修改前内容如下：
                            define('DB_HOST', '192.168.2.11');
                            修改后内容如下：
                            define('DB_HOST', '192.168.2.21');
                    2.客户端测试

                        1）客户端使用浏览器访问wordpress网站。
                           [root@client ~]# firefox http://192.168.2.11


                Web服务器集群

                    目标:
                        使用HAProxy部署Web服务器集群，实现以下目标：
                        部署三台Web服务器
                        迁移网站数据，使用NFS实现数据共享
                        部署HAProxy代理服务器实现负载均衡
                        部署DNS域名解析服务器

                        client                      2.11/24
                        proxy (DNS+代理 服务器)     eth0  4.5/24
                                                   eth1  2.5/24
                        web1                       eth1  2.11/24
                        web2                       eth1 2.12 /24
                        web3                       eth1 2.13 /24
                        database                   eth1 2.21 /24
                        NFS                        eth1 2.31 /24

                    1.部署web2和web3服务器

                        1）安装LNP软件包
                            [root@web2 ~]# yum -y install gcc pcre-devel openssl-devel
                            [root@web2 lnmp_soft]# tar -xf nginx-1.12.2.tar.gz
                            [root@web2 lnmp_soft]# cd nginx-1.12.2/
                            [root@web2 nginx-1.12.2]# ./configure \
                            --with-http_ssl_module \
                            --with-http_stub_status_module   ////Nginx监控模块
                            [root@web2 nginx-1.12.2]# make && make instal
                            [root@web2 ~]# yum -y install php php-fpm php-mysql mariadb-devel
                            [root@web3 ~]# yum -y install gcc pcre-devel openssl-devel
                            [root@web3 lnmp_soft]# tar -xf nginx-1.12.2.tar.gz
                            [root@web3 lnmp_soft]# cd nginx-1.12.2/
                            [root@web3 nginx-1.12.2]# ./configure \
                            --with-http_ssl_module \
                            --with-http_stub_status_module
                            [root@web3 nginx-1.12.2]# make && make instal
                            [root@web3 ~]# yum -y install php php-fpm php-mysql mariadb-devel
                        2）修改nginx配置实现动静分离（web2和web3操作）
                            方法1:
                                web1 将动态页面请求转发给 web2/web3的调度服务器的9000端口再由调度器转发给动态web集群9000
                            方法2:
                                从web1 的nginx.conf 配置文件 直接指定 接受服务器和端口
                            这里我们使用方法2
                            web2修改默认首页index.php，配置两个location实现动静分离。
                            [root@web2 ~]# vim /usr/local/nginx/conf/nginx.conf
                            location / {
                                        root   html;
                                        index  index.php index.html index.htm;
                                    }
                            location ~ \.php$ {
                                        root            html;
                                        fastcgi_pass   127.0.0.1:9000;
                                        fastcgi_index  index.php;
                                        include         fastcgi.conf;
                                    }
                            web3修改默认首页index.php，配置两个location实现动静分离。
                            [root@web3 ~]# vim /usr/local/nginx/conf/nginx.conf
                            location / {
                                        root   html;
                                        index  index.php index.html index.htm;
                                    }
                            location ~ \.php$ {
                                        root            html;
                                        fastcgi_pass   127.0.0.1:9000;
                                        fastcgi_index  index.php;
                                        include         fastcgi.conf;
                                    }
                        3）启动相关服务
                            [root@web2 ~]# echo "/usr/local/nginx/sbin/nginx" >> /etc/rc.local
                            [root@web2 ~]# chmod +x /etc/rc.local
                            [root@web2 ~]# /usr/local/nginx/sbin/nginx
                            [root@web2 ~]# systemctl start  php-fpm                   #启动php-fpm服务
                            [root@web2 ~]# systemctl enable php-fpm
                            [root@web3 ~]# echo "/usr/local/nginx/sbin/nginx" >> /etc/rc.local
                            [root@web3 ~]# chmod +x /etc/rc.local
                            [root@web3 ~]# /usr/local/nginx/sbin/nginx
                            [root@web3 ~]# systemctl start  php-fpm                   #启动php-fpm服务
                            [root@web3 ~]# systemctl enable php-fpm
                    2.部署NFS，将网站数据迁移至NFS共享服务器

                        1）部署NFS共享服务器
                            [root@nfs ~]# yum install nfs-utils
                            [root@nfs ~]# mkdir /web_share
                            [root@nfs ~]# vim /etc/exports
                            /web_share  192.168.2.0/24(rw,no_root_squash)
                            [root@nfs ~]# systemctl restart rpcbind
                            [root@nfs ~]# systemctl eanble rpcbind
                            NFS使用的是随机端口，每次启动NFS都需要将自己的随机端口注册到rpcbind服务，这样客户端访问NFS时先到rpcbind查询端口信息，得到端口信息后再访问NFS服务。
                            [root@nfs ~]# systemctl restart nfs
                            [root@nfs ~]# systemctl enable nfs
                        2）迁移旧的网站数据(冷迁移,需要将用户停止访问)到NFS共享服务器,
                            #####################迁移的方法有许多 将在数据库阶段学到##########################
                            ###################数据库中的概念'锁' 只能看不能写,不印象访问.只是不能购买###########
                            ####若是要热迁移(保障业务,不下线,迁移数据库,结合灰度发布)的则需要其他方法###############
                            ###############给数据库快照,通过快照进行恢复,将剩余的部分同步过来###################
                            ####将web1（192.168.2.11）上的wordpress代码拷贝到NFS共享。########################
                            [root@web1 ~]# cd /usr/local/nginx/
                            [root@web1 nginx]# tar -czpf html.tar.gz html/     -p保留权限
                            [root@web1 nginx]# scp html.tar.gz 192.168.2.31:/web_share/
                            登陆nfs服务器，将压缩包解压
                            [root@nfs ~]# cd /web_share/
                            [root@nfs web_share]# tar -xf html.tar.gz
                        3)所有web服务器访问挂载NFS共享数据。
                            [root@web1 ~]# rm -rf /usr/local/nginx/html/*
                            [root@web1 ~]# yum -y install nfs-utils
                            [root@web1 ~]# echo "192.168.2.31:/web_share/html /usr/local/nginx/html/ nfs defaults 0 0" >> /etc/fstab
                            [root@web1 ~]# mount -a
                            [root@web2 ~]# yum -y install nfs-utils
                            [root@web2 ~]# echo "192.168.2.31:/web_share/html /usr/local/nginx/html/ nfs defaults 0 0" >> /etc/fstab
                            [root@web2 ~]# mount -a
                            [root@web3 ~]# yum -y install nfs-utils
                            [root@web3 ~]# echo "192.168.2.31:/web_share/html /usr/local/nginx/html/ nfs defaults 0 0" >> /etc/fstab
                            [root@web3 ~]# mount -a
                    3.部署HAProxy代理服务器

                        1）部署HAProxy
                        安装软件，手动修改配置文件，添加如下内容。
                        [root@proxy ~]# yum -y install haproxy
                        [root@proxy ~]# vim /etc/haproxy/haproxy.cfg
                        listen wordpress *:80
                          balance roundrobin
                          server web1 192.168.2.11:80 check inter 2000 rise 2 fall 3
                          server web2 192.168.2.12:80 check inter 2000 rise 2 fall 3
                          server web3 192.168.2.13:80 check inter 2000 rise 2 fall 3
                        [root@proxy ~]# systemctl start haproxy
                        [root@proxy ~]# systemctl enable haproxy
                    4.部署DNS域名服务器

                        1）安装DNS相关软件（192.168.4.5操作）。
                            [root@proxy ~]# yum -y  install bind bind-chroot
                        2）修改主配置文件，添加zone。
                            [root@proxy ~]# vim /etc/named.conf
                            options {
                                    listen-on port 53 { any; };           #服务监听的地址与端口
                                    directory       "/var/named";         #数据文件路径
                                    allow-query     { any; };             #允许任何主机访问DNS服务
                            ... ...
                            };
                            zone "lab.com" IN {                        #定义正向区域
                                    type master;
                                    file "lab.zone";
                            };
                            #include "/etc/named.rfc1912.zones";        #注释掉改行
                            #include "/etc/named.root.key";              #注释掉改行
                            [root@proxy ~]# named-checkconf /etc/named.conf            #检查语法
                        3）修改正向解析记录文件。
                            注意：保留文件权限。
                            [root@proxy named]# cp -p /var/named/named.localhost /var/named/lab.com.zone
                            [root@proxy named]# vim /var/named/lab.zone
                            $TTL 1D
                            @       IN SOA  @ rname.invalid. (
                                                                    0       ; serial
                                                                    1D      ; refresh
                                                                    1H      ; retry
                                                                    1W      ; expire
                                                                    3H )    ; minimum
                            @        NS     dns.lab.com.
                            dns     A       192.168.4.5
                            www     A       192.168.4.5
                        4）启动服务
                            [root@proxy named]# systemctl start named
                            [root@proxy named]# systemctl enable named
                        5）客户端修改DNS解析文件
                            提示：做完实验修改回原始内容。
                            [root@room9pc01 data]# cat /etc/resolv.conf
                            # Generated by NetworkManager
                            search tedu.cn
                            nameserver 192.168.4.5
                            nameserver 172.40.1.10
                            nameserver 192.168.0.220
                    5.修改wordpress配置文件

                        1）修改wp-config.php
                            在define('DB_NAME', 'wordpress')这行前面添加如下两行内容：
                            [root@web3 html]# vim /usr/local/nginx/html/wp-config.php
                            define('WP_SITEURL', 'http://www.lab.com');
                            define('WP_HOME', 'http://www.lab.com');

                        2)测试
                            Firefox www.lab.com


        project day03
            1.keeplived高可用
                要求:
                    部署两台代理服务器,实现 利用keeplived的高可用
                    配置VIP为192.168.4.80
                    修改对应的域名解析服务


                                    proxy1+dns    web1
                                     |            |------------- NFS服务器
                    client-----------|------------|
                                |    |            |
                                |    |            |-------------数据库 服务器
                               DNS  proxy2        web2,web3

                要求: 部署量两台代理服务器 通过keeplived 实现高可用
                      配置vip 为192.168.4.80
                      修改对应的域名解析服务

                      proxy1  eth0 192.168.4./24 eth2 192.168.2.5/24
                      proxy2  eth0 192.168.4.6/24 eth2 192.168.2.6/24

                (1)配置第二台代理服务器
                    由于已经有了第一台 代理服务器,所以这里只配置第二台
                    1）部署HAProxy
                        安装软件，手动修改配置文件，添加如下内容。
                        [root@proxy2 ~]# yum -y install haproxy
                        [root@proxy2 ~]# vim /etc/haproxy/haproxy.cfg
                        listen wordpress *:80
                          balance roundrobin
                          server web1 192.168.2.11:80 check inter 2000 rise 2 fall 3
                          server web2 192.168.2.12:80 check inter 2000 rise 2 fall 3
                          server web3 192.168.2.13:80 check inter 2000 rise 2 fall 3
                        [root@proxy2 ~]# systemctl start haproxy
                        [root@proxy2 ~]# systemctl enable haproxy
                (2)为两台代理服务器配置keepalived
                        1）配置第一台代理服务器proxy（192.168.4.5）。
                        [root@proxy ~]# yum install -y keepalived
                        [root@proxy ~]# vim /etc/keepalived/keepalived.conf
                        global_defs {
                          router_id  proxy1                        //设置路由ID号
                        }
                        vrrp_instance VI_1 {
                          state MASTER                         //主服务器为MASTER（备服务器需要修改为BACKUP）
                          interface eth0                    //定义网络接口
                          virtual_router_id 51
                          priority 100                     //服务器优先级,优先级高优先获取VIP（实验需要修改）
                          advert_int 1
                          authentication {
                            auth_type pass
                            auth_pass 1111                       //主备服务器密码必须一致
                          }
                          virtual_ipaddress {                   //谁是主服务器谁获得该VIP（实验需要修改）
                        192.168.4.80
                        }
                        }
                        [root@proxy ~]# systemctl start keepalived
                        [root@proxy ~]# iptables -F               #清空防火墙规则
                    2）配置第二台代理服务器proxy（192.168.4.6）。
                        [root@proxy2 ~]# yum install -y keepalived
                        [root@proxy2 ~]# vim /etc/keepalived/keepalived.conf
                        global_defs {
                          router_id  proxy2                        //设置路由ID号
                        }
                        vrrp_instance VI_1 {
                          state BACKUP                         //主服务器为MASTER（备服务器需要修改为BACKUP）
                          interface eth0                    //定义网络接口
                          virtual_router_id 51
                          priority 50                         //服务器优先级,优先级高优先获取VIP
                          advert_int 1
                          authentication {
                            auth_type pass
                            auth_pass 1111                       //主备服务器密码必须一致
                          }
                          virtual_ipaddress {                   //谁是主服务器谁获得该VIP
                        192.168.4.80
                        }
                        }
                        [root@proxy2 ~]# systemctl start keepalived
                        [root@proxy2 ~]# iptables -F               #清空防火墙规则
                (3)修改DNS服务器
                    1）修改网站域名对应的解析记录，解析到新的VIP地址。
                        192.168.4.5为DNS服务器。
                        [root@proxy ~]# vim /var/named/lab.com.zone
                        $TTL 1D
                        @       IN SOA  @ rname.invalid. (
                                                                0       ; serial
                                                                1D      ; refresh
                                                                1H      ; retry
                                                                1W      ; expire
                                                                3H )    ; minimum
                        @       NS      dns.lab.com.
                        dns     A       192.168.4.5
                        www     A       192.168.4.80
                    2）重启DNS服务
                        [root@proxy ~]# systemctl restart named


                    3) 测试访问

            2.部署ceph分布式存储
                要求:使用三台服务器实现 ceph分布式存储
                     实现ceph 文件系统 共享
                     将网站数据库从nfs中迁移到ceph存储

                     node1 eth1 2.41/25
                     node2 eth1 2.42/25
                     node3 eth1 2.43/25


                (1)准备实验环境
                    1）物理机为所有节点配置yum源服务器。
                        提示：ceph10.iso在/linux-soft/02目录。
                        [root@room9pc01 ~]# mkdir  /var/ftp/ceph
                        [root@room9pc01 ~]# mount ceph10.iso /var/ftp/ceph/
                    2）在node1配置SSH密钥，让node1可用无密码连接node1,node2,node3
                        [root@node1 ~]# ssh-keygen  -f /root/.ssh/id_rsa  -N  ''
                        [root@node1 ~]# for i in   41  42  43
                        do
                        ssh-copy-id  192.168.2.$i
                        done
                    3)修改/etc/hosts域名解析记录（不要删除原有的数据），同步给所有ceph节点。
                        [root@node1 ~]# vim /etc/hosts
                        192.168.2.41    node1
                        192.168.2.42     node2
                        192.168.2.43    node3
                        [root@node1 ~]# for i in 41 42 43
                        do
                             scp /etc/hosts 192.168.2.$i:/etc
                        done
                    4）为所有ceph节点配置yum源，并将配置同步给所有节点
                        [root@node1 ~]# cat /etc/yum.repos.d/ceph.repo
                        [mon]
                        name=mon
                        baseurl=ftp://192.168.2.254/ceph/MON
                        gpgcheck=0
                        [osd]
                        name=osd
                        baseurl=ftp://192.168.2.254/ceph/OSD
                        gpgcheck=0
                        [tools]
                        name=tools
                        baseurl=ftp://192.168.2.254/ceph/Tools
                        gpgcheck=0
                        [root@node1 ~]# yum repolist                #验证YUM源软件数量
                        源标识            源名称                    状态
                        Dvd                redhat                    9,911
                        Mon                mon                        41
                        Osd                osd                        28
                        Tools            tools                        33
                        repolist: 10,013
                        [root@node1 ~]# for i in 41 42 43
                        do
                             scp /etc/yum.repos.d/ceph.repo 192.168.2.$i:/etc/yum.repos.d/
                        done
                    5）所有节点主机与真实主机的NTP服务器同步时间。
                        提示：默认真实物理机已经配置为NTP服务器。
                        [root@node1 ~]# vim /etc/chrony.conf
                        … …
                        server 192.168.2.254   iburst
                        [root@node1 ~]# for i in 41  42  43
                        do
                             scp /etc/chrony.conf 192.168.2.$i:/etc/
                             ssh 192.168.2.$i "systemctl restart chronyd"
                        done
                    6）使用virt-manager为三台ceph虚拟机添加磁盘。
                        每台虚拟机添加3块20G的磁盘。 一共 提供120G文件系统 同时提供60G空间作为缓存磁盘


                (2)部署ceph集群
                    1）给node1主机安装ceph-deploy，创建工作目录，初始化配置文件。
                        [root@node1 ~]# yum -y install ceph-deploy
                        [root@node1 ~]# mkdir ceph-cluster
                        [root@node1 ~]# cd ceph-cluster
                        [root@node1 ceph-cluster]# ceph-deploy new node1 node2 node3
                    2）给所有ceph节点安装ceph相关软件包
                        [root@node1 ceph-cluster]# for i in node1 node2 node3
                        do
                                 ssh $i "yum -y install ceph-mon ceph-osd ceph-mds"
                        done
                        创建mon 创建osd
                        [root@node1 ceph-cluster]# ceph -s                    #查看结果
                            cluster 9f3e04b8-7dbb-43da-abe6-b9e3f5e46d2e
                             health HEALTH_ERR
                             monmap e2: 3 mons at

                         {node1=192.168.2.41:6789/0,node2=192.168.2.42:6789/0,node3=192.168.2.43:6789/0}

                    3）准备磁盘分区，创建journal盘，并永久修改设备权限。
                        [root@node1 ceph-cluster]# for i in node1 node2 node3
                        do
                             ssh $i "parted /dev/vdb mklabel gpt"
                             ssh $i "parted /dev/vdb mkpart primary 1 50%"
                             ssh $i "parted /dev/vdb mkpart primary 50% 100%"
                         done
                        提示：下面的步骤在所有主机都需要操作（node1，node2，node3）
                        #临时修改权限：
                        [root@node1 ceph-cluster]# chown  ceph.ceph  /dev/vdb1
                        [root@node1 ceph-cluster]# chown  ceph.ceph  /dev/vdb2
                        #永久修改权限：
                        [root@node1 ceph-cluster]# vim /etc/udev/rules.d/70-vdb.rules
                        ENV{DEVNAME}=="/dev/vdb1",OWNER="ceph",GROUP="ceph"
                        ENV{DEVNAME}=="/dev/vdb2",OWNER="ceph",GROUP="ceph"
                    4）使用ceph-deploy工具初始化数据磁盘（仅node1操作）。
                        [root@node1 ceph-cluster]# ceph-deploy disk  zap  node1:vdc   node1:vdd   journal磁盘
                        [root@node1 ceph-cluster]# ceph-deploy disk  zap  node2:vdc   node2:vdd
                        [root@node1 ceph-cluster]# ceph-deploy disk  zap  node3:vdc   node3:vdd
                    5）初始化OSD集群。
                        [root@node1 ceph-cluster]# ceph-deploy osd create \
                         node1:vdc:/dev/vdb1 node1:vdd:/dev/vdb2
                        //创建osd存储设备，vdc为集群提供存储空间，vdb1提供JOURNAL缓存，
                        //一个存储设备对应一个缓存设备，缓存需要SSD，不需要很大
                        [root@node1 ceph-cluster]# ceph-deploy osd create \
                         node2:vdc:/dev/vdb1 node2:vdd:/dev/vdb2
                        [root@node1 ceph-cluster]# ceph-deploy osd create \
                         node3:vdc:/dev/vdb1 node3:vdd:/dev/vdb2
                        [root@node1 ceph-cluster]# ceph -s                 #查看集群状态

                (3) 部署ceph文件系统
                    1）启动mds服务
                        [root@node1 ceph-cluster]# ceph-deploy mds create node3
                    2）创建存储池（文件系统由inode和block组成）
                        [root@node1 ceph-cluster]# ceph osd pool create cephfs_data 128
                        [root@node1 ceph-cluster]# ceph osd pool create cephfs_metadata 128
                        [root@node1 ceph-cluster]# ceph osd lspools
                        0 rbd,1 cephfs_data,2 cephfs_metadata
                    3）创建文件系统
                        [root@node1 ceph-cluster]# ceph fs new myfs1 cephfs_metadata cephfs_data
                        [root@node1 ceph-cluster]# ceph fs ls
                        name: myfs1, metadata pool: cephfs_metadata, data pools: [cephfs_data ]
                (4)迁移网站数据到ceph集群
                    1）卸载web1，web2，web3的NFS共享。
                        暂停服务防止有人实时读写文件。
                        [root@web1 ~]# /usr/local/nginx/sbin/nginx -s stop
                        [root@web2 ~]# /usr/local/nginx/sbin/nginx -s stop
                        [root@web3 ~]# /usr/local/nginx/sbin/nginx -s stop
                        [root@web1 ~]# umount /usr/local/nginx/html
                        [root@web2 ~]# umount /usr/local/nginx/html
                        [root@web3 ~]# umount /usr/local/nginx/html
                        [root@web1 ~]# vim /etc/fstab
                        #192.168.2.31:/web_share/html /usr/local/nginx/html/ nfs defaults 0 0
                        [root@web2 ~]# vim /etc/fstab
                        #192.168.2.31:/web_share/html /usr/local/nginx/html/ nfs defaults 0 0
                        [root@web3 ~]# vim /etc/fstab
                        #192.168.2.31:/web_share/html /usr/local/nginx/html/ nfs defaults 0 0
                    2）web服务器永久挂载Ceph文件系统（web1、web2、web3都需要操作）。
                        在任意ceph节点，如node1查看ceph账户与密码。
                        [root@node1 ~]# cat /etc/ceph/ceph.client.admin.keyring
                        [client.admin]
                            key = AQA0KtlcRGz5JxAA/K0AD/uNuLI1RqPsNGC7zg==
                        /etc/rc.local是开机启动脚本，任何命令放在该文件中都是开机自启。
                        [root@web1 ~]#  mount -t ceph 192.168.2.41:6789:/ /usr/local/nginx/html/ \
                        -o name=admin,secret=AQA0KtlcRGz5JxAA/K0AD/uNuLI1RqPsNGC7zg==
                        [root@web1 ~]# echo 'mount -t ceph 192.168.2.41:6789:/ /usr/local/nginx/html/ \
                        -o name=admin,secret=AQA0KtlcRGz5JxAA/K0AD/uNuLI1RqPsNGC7zg==' >> /etc/rc.local
                        [root@web1 ~]# chmod +x /etc/rc.local
                        [root@web2 ~]#  mount -t ceph 192.168.2.41:6789:/ /usr/local/nginx/html/ \
                        -o name=admin,secret=AQA0KtlcRGz5JxAA/K0AD/uNuLI1RqPsNGC7zg==
                        [root@web2 ~]# echo 'mount -t ceph 192.168.2.41:6789:/ /usr/local/nginx/html/ \
                        -o name=admin,secret=AQA0KtlcRGz5JxAA/K0AD/uNuLI1RqPsNGC7zg==' >> /etc/rc.local
                        [root@web2 ~]# chmod +x /etc/rc.local
                        [root@web3 ~]#  mount -t ceph 192.168.2.41:6789:/ /usr/local/nginx/html/ \
                        -o name=admin,secret=AQA0KtlcRGz5JxAA/K0AD/uNuLI1RqPsNGC7zg==
                        [root@web3 ~]# echo 'mount -t ceph 192.168.2.41:6789:/ /usr/local/nginx/html/ \
                        -o name=admin,secret=AQA0KtlcRGz5JxAA/K0AD/uNuLI1RqPsNGC7zg==' >> /etc/rc.local
                        [root@web3 ~]# chmod +x /etc/rc.local
                    3)迁移NFS服务器中的数据到Ceph存储
                        登陆NFS服务器备份数据，将备份数据拷贝给web1或web2或web3，tar备份数据时注意使用-f选项保留文件权限。
                        [root@nfs ~]# cd /web_share/html/
                        [root@nfs html]# tar -czpf /root/html.tar.gz ./*
                        [root@nfs html]# scp /root/html.tar.gz 192.168.2.11:/usr/local/nginx/html/
                        登陆web1将数据恢复到Ceph共享目录
                        [root@web1 html]# tar -xf html.tar.gz
                        [root@web1 html]# rm -rf html.tar.gz
                    3）恢复web服务
                        [root@web1 ~]# /usr/local/nginx/sbin/nginx
                        [root@web2 ~]# /usr/local/nginx/sbin/nginx
                        [root@web3 ~]# /usr/local/nginx/sbin/nginx


                 ######################################################################################
                ceph 安装思路
                    本次不需要共享对象存储
                    1.环境准备
                        yum源
                        /etc/hosts
                        ssh秘钥 同步给 ceph机器
                        NTP时间同步
                        给虚拟机添加磁盘
                    2.部署ceph
                        yum -y install ceph-deploy
                        mkdir ceph-cluster
                        cd  ceph-cluster
                        所有主机安装 ceph-mon  ceph-osd ceph- mds
                        ceph-deploy new node1 node2 node3
                        ceph-deploy mon create-initial
                        给磁盘分区格式化 /dev/vdb [手动] ,修改/dev/vdb 权限
                        chown ceph.ceph /dev/vdb
                        vim /ete/udev/rules.d/xxx.rules
                        ceph-deploy disk zap node1:xxx node1:xxx   ###初始化数据磁盘 journal磁盘
                        每个 xxx 都是 本机中 的缓存磁盘
                        ceph-deploy osd create node1:journal 数据盘:xxx ###初始化 osd 集群 数据磁盘 : 缓存磁盘(xxx)
                        ceph-deploy osd create node2:journal 数据盘:xxx

                    创建文件系统
                        创建两个存储池子
                            [root@node1 ceph-cluster]# ceph osd pool create cephfs_data 128
                            [root@node1 ceph-cluster]# ceph osd pool create cephfs_metadata 128
                            [root@node1 ceph-cluster]# ceph osd lspools
                            0 rbd,1 cephfs_data,2 cephfs_metadata
                        创建共享文件系统
                            [root@node1 ceph-cluster]# ceph fs new myfs1 cephfs_metadata cephfs_data
                            [root@node1 ceph-cluster]# ceph fs ls
                            name: myfs1, metadata pool: cephfs_metadata, data pools: [cephfs_data ]
                        启动服务
                        ceph-deploy mds creat enode3 ##启动 mds服务
                        挂载
                        写入 /etc/rc.local
                        和写入 /etc/rc.d/rc.local
                        mount -t ceph 192.168.2.41:6789:/ /usr/local/nginx/html/ -o name=admin,secret=AQCyL/ZcAjqLBRAAxDHl9Hvwlx9ynD92VYR5vw==

                     ##################################################################################################




        project day04
            生产环境 中 git 是一个独立的服务器

            部署git版本控制
                要求: 部署git版本控制协议,管理网站代码,
                     基于ssh协议的服务器
                     基于git协议的服务器
                     基于http协议的服务器
                     上传代码版本仓库

                生产环境 应该有一台独立的git服务器,这里使用数据库主机作为git服务器
                    数据库 2.21/24

            1.部署SSH协议的版本控制服务器

                1）安装软件包，创建空仓库。
                [root@database ~]# yum -y install git
                [root@database ~]# git init --bare /var/git/wordpress.git            #创建空仓库
                2）登陆web1服务器克隆git仓库，上传网站代码到git服务器。
                [root@web1 var]# git config --global push.default simple
                [root@web1 var]# git config --global user.email you@example.com
                [root@web1 var]# git config --global user.name "Your Name"
                [root@web1 var]# cd /var/
                [root@web1 var]# git clone root@192.168.2.21:/var/git/wordpress.git
                [root@web1 var]# cd /var/wordpress
                [root@web1 wordpress]# cp -a /usr/local/nginx/html/*  ./
                [root@web1 wordpress]# git add .
                [root@web1 wordpress]# git commit -m "wordpress code"
                [root@web1 wordpress]# git push
                root@192.168.2.21's password:<输入192.168.2.21主机root的密码>
            2.部署Git协议的版本控制服务器

                1）安装软件包（192.168.2.21操作）
                    [root@database ~]# yum -y install git-daemon
                2）修改配置文件，启动Git服务
                    [root@database ~]# vim /usr/lib/systemd/system/git@.service
                    修改前内容如下：
                    ExecStart=-/usr/libexec/git-core/git-daemon --base-path=/var/lib/git --export-all --user-path=public_git --syslog --inetd –verbose
                    修改后内容如下：
                    ExecStart=-/usr/libexec/git-core/git-daemon --base-path=/var/git --export-all --user-path=public_git --syslog --inetd –verbose
                    [root@database ~]# systemctl start git.socket
                    [root@database ~]# systemctl status git.socket
                3)客户端测试（使用web2做完客户端主机，192.168.2.12）
                    在web2执行clone等同于是把代码又备份了一份。
                    [root@web2 ~]# cd /var/
                    [root@web2 var]# git clone git://192.168.2.21/wordpress.git
            3.部署HTTP协议的版本控制服务器

                1）安装软件包（192.168.2.21操作）
                    [root@database ~]# yum -y install httpd gitweb
                2）修改配置文件
                    [root@database ~]# vim /etc/gitweb.conf
                    $projectroot = "/var/git";                        #添加一行
                3）启动服务
                    [root@database ~]# systemctl start httpd
                4）客户端验证
                    [root@room9pc01 ~]# firefox http://192.168.2.21/git
                    访问测试 是否可以看到 git 仓库




























