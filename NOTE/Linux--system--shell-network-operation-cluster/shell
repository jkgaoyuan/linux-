shell
复杂的操作变得简单化,自动化
在编写脚本时需要考虑,使用费交互式命令
    eg: sleep 5 &
    将sleep 放入后台执行
    安装ksh
        yum repolist
        yum -y install ksh ###安装 ksh 解释器,没有bash 好用
        [root@server0 ~]# ksh
        #
    bash的快捷键
        ctr + a 回到行首
        ctr + e 回到行尾
        ctr + d 结束当前输入
        ctr + z 暂停挂起
        ctr + m 回车
        ctr + u 删除光标至行首的所有内容
        ctr + k 删除光标至行尾的所有内容
        ctr + w 删除光标 前面的一个单词
        ctr + s 冻结终端
        ctr + q 恢复终端
    修改命令的历史纪录
        [root@server0 ~]# vim /etc/profile
        HISTSIZE=1000
        [root@server0 ~]# ls -A
        .bash_history           ####该文件保存了最近的命令;历史记录
    重定向
         覆盖   追加
           >    >>  收集正确信息
           2>   2>> 收集错误信息
           &>   &>> 收集所有信息
           < 输入重定向

    bash 优点
         支持 tab 快捷键  历史命令  别名  重定向  管道 等等
         选项 -x
        pstree 进程树
    脚本编写步骤
        1.声明解释器
        2.书写脚本功能描述,变量含义, 使用位置, 作者(生产环境必写)
        3.编写执行指令
            1)添加x权限
            chmod +x test1.sh
            2)执行命令 时记得 在命令前 添加 ./ 指定当前目录下
            ./test1.sh
            3)或者使用解释器直接执行(可以不用添加权限,使用) ,新开启解释器
            bash test1.sh           //脚本执行完毕后退出新开启的解释器
            4)使用source 直接执行 脚本, 使用当前解释器执行
            source test1.sh    //执行完成后退出当前解释器, source 和 bash 使用时 在脚本中没有exit 时效果时一样的,
                               //但当脚本有了 exit 就会 不同,
                               //表现在 source 会在执行后关闭当前解释器,
                               ///bash则会关闭新开启的(其实脚本执行完毕后退出新开启的解释器,
                               //所以在结尾添加 exit 对于bash 来说区别不大).
    编写一个搭建yum仓库的脚本
            #!/bin/bash
            rm -rf /etc/yum.repos.d/*.repo
            echo '[nsd]
            name = nsd
            baseurl=ftp://172.25.254.250/centos-1804/
            enabled = 1
            gpgcheck = 0
            ' > /etc/yum.repos.d/abc.repo
            yum repolist

            bash -x test.sh 在执行脚本过程中 显示错误信息

    编写一个自动安装 vsftpd的 脚本 并检测服务  是否 启动
            #!/bin/bash
            yum -y install vsftpd &> /dev/null  ###安装 过程不显示
            systemctl restart vsftpd
            systemctl enable vsftpd
            systemctl status vsftpd   ###检测服务是否启动

    变量
        使用固定的名称表示变化的量
        自定义变量
            定义变量 : 变量名称= 变量值
            查看变量 : echo$变量名称
            取消变量 : unset 变量名称
        系统变量
            环境变量
                 一级提示符
                    PS1
                二级提示符
                    PS2
            预定义变量
                $0 显示脚本名
                $$ 显示脚本进程号
                $? 显示上条指令是否成功  非0表示执行失败
                $# 统计变量个数
                $* 显示所有位置变量的内容
            位置变量
                $1 脚本名后第一个参数
                $2 脚本名后第二个参数
                $3 脚本名后第三个参数
                env 查看所有环境变量(了解)
                set 查看所有的变量(了解)
                '' 界定范围 取消字符的特殊定义, 比如$(屏蔽$的作用)
                "" 界定范围
                `` 反撇号 $() 获取指令的输出结果
            关闭回显 stty -echo
            开启回显 stty echo
            全局变量 export a=20  (系统变量默认为全局变量)
            局部变量 a=20(只在源解释器生效)
                [root@server0 opt]# export c=10089
                [root@server0 opt]# bash
                [root@server0 opt]# echo $c
                10089
                [root@server0 opt]# exit
                [root@server0 opt]#
        shell 中的 数学运算
            方法一 expr 值1 运算符 值2
                [root@svr5 ~]# X=1234                              //定义变量X
                [root@svr5 ~]# expr  $X  +  78                      //加法
                1312
                [root@svr5 ~]# expr  $X  -  78                       //减法
                1156
                [root@svr5 ~]# expr  $X  \*  78                      //乘法，操作符应添加\转义 或者 '*'
                96252
                [root@svr5 ~]# expr  $X  /  78                      //除法，仅保留整除结果
                15
                [root@svr5 ~]# expr  $X  %  78                     //(求余数)求模
                64

            方法二  echo $[值1 运算符 值2]  echo $((值1 运算符 值2))

                [root@svr5 ~]# X=1234
                [root@svr5 ~]# echo $[X+78]
                1312
                [root@svr5 ~]# echo $[X-78]
                1156
                [root@svr5 ~]# echo $[X*78]
                96252
                [root@svr5 ~]# echo $[X/78]
                15
                [root@svr5 ~]# echo $[X%78]
                64

            方法三  通常对变量进行计算,不显示结果(通常用来做 变量的增减 定义)
                [root@svr5 ~]# X=123                [root@svr5 ~]# let y=X+22
                [root@svr5 ~]# echo $y
                1256
                [root@svr5 ~]# let X++;  echo $X        # X++(X=X+1)
                [root@svr5 ~]# let X--;  echo $X        # X--(X=X-1)
                [root@svr5 ~]# let X+=78 ; echo $X        # X+=78(X=X+78)
                [root@svr5 ~]# let X-=78 ; echo $X     # X-=78(X=X-78)
                [root@svr5 ~]# let X*=78 ; echo $X     # X*=78(X=X*78)
                [root@svr5 ~]# let X/=78 ; echo $X     # X/=78(X=X/78)
                [root@svr5 ~]# let X%=78 ; echo $X     # X%=78(X=X%78)

            方法四 计算小数
                方法1-3 不支持小数
                交互式计算
                [root@svr5 ~]# bc
                bc 1.06.95
                Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation, Inc.
                This is free software with ABSOLUTELY NO WARRANTY.
                For details type `warranty'.
                12.34+56.78                                        //加法
                69.12
                12.34-56.78                                        //减法
                -44.44
                12.34*56.78                                        //乘法
                700.66
                12.34/56.78                                        //除法
                0
                quit                                              //退出交互计算器
                scale=3                                           // 小数点后3位

                非交互计算
                [root@svr5 ~]# echo 'scale=4;12.34+5.678' | bc
                18.018
                [root@svr5 ~]# echo 'scale=4;12.34*5.678' | bc
                70.0665
                [root@svr5 ~]# echo 'scale=4;12.34/5.678' | bc
                2.1733

    条件测试 (重要)
        作用:对于系统环境进行预判,增减脚本灵活性和成果率
            test 表达式  或   [表达式]
                表达式两边至少要留一个空格
                1)
                test $USER=='root'; echo $?  ###注意空格
                0
                2)
                [ $UID == '1' ] ; echo $?   ###注意空格 每个参数之间用空格隔开 //推荐使用第二种
                1

        && 前面执行成功后执行后面的命令
        || 前面执行失败后执行后面的命令
        ;  前面执行后执行后面命令,无逻辑关系
        -z 检测变量的值是否为空,空为真
                [root@svr5 ~]# var1="nb" ; var2=""
                [root@svr5 ~]# [ -z "$var1" ] && echo "空值" || echo "非空值"
                非空值
                [root@svr5 ~]# [ -z $var2 ] && echo "空值" || echo "非空值"
                空值                                      //变量var2已设置，但无任何值，视为空
                [root@svr5 ~]# [ ! -z $var1 ]                //测试var1是否为非空

        -eq   等于
        -ne   不等
        -gt   大于
        -ge   大于等于
        -lt   小于
        -le   小于等于
         wc -l 统计行数
         who查看 登录用户数量
        eg: 统计server 登录用户数量大于三时邮件报警 管理员
            #!/bin/bash
            n=`who | wc -l`
            [ $n -gt 3 ] && echo 'fbiwarning $n' |mail -s 'fbi' root && echo 'dangerous'|| echo 'seaf'
            crontab -e
            */2 * * * * /opt/test.sh
        -e 文档存在为真 (查询 文件和 目录 是否存在 )
        -d 文档存在,且必须为目录为真(只能查询 目录 是否存在)
        -f 文档存在,且必须文件为真(只能用来筛选文件是否存在)
        -r 判断对象是否可读
           此测试对root用户无效，无论文件是否设置r权限，root都可读
        -w 判断对象是否可写
            此测试同样对root用户无效，无论文件是否设置w权限，root都可写：
        -x 判断对象是否具有可执行权限
            这个取决于文件本身、文件系统级的控制，root或普通用户都适用：
            eg:
                [ -d root ]; echo $?
                1
                [ -d mail ]; echo $?
                0
                ls -ld mail
                drwxrwxr-x. 2 root mail 4096 5月   9 14:04 mail
                [ -r mail ];echo $?
                0
                [ -w mail ];echo $?
                0
                [ -x mail ];echo $?
                0

    判断语句
        格式:
            1)单分支
                    if [条件测试] ; then

                       命令序列

                    fi
            2)双分支
                    if [条件测试] ; then
                        命令序列1
                    else
                        命令序列2
                    fi
            3)多分支
                    if [条件测试] ; then
                        命令序列1
                    elif [条件测试] ; then
                        命令序列2
                        ...
                    else
                        命令序列n

                    fi
            eg:
                #!/bin/bash
                ping -c 5 -i 0.2 -W 1 $1 &> /dev/null
                if [ $? -eq 0  ] ;then
                        echo 'connect'
                else
                        echo 'disconnect'
                fi

    循环语句
        for循环
            for i in 值1 值2
            do
                执行命令
            done

        eg: 使用for循环编写测试 范围 ip 的连通性
            #!/bin/bash
            a=0
            b=0
            for i in {1..10}
            do
            ping -c 2 -i 0.3 -W 1 172.25.0.$i &> /dev/null
                    if [ $? -eq 0 ] ;then
                    echo "172.25.0.${i} connect"
                      let a++
                   else
                    echo "172.25.0.${i} disconnetcion'"
                     let b++
                    fi

            done

            echo "$a connect $b disconnetc"


        while 循环
            while 条件测试
            do
                命令
            done

        eg: 一个自动猜数字的 脚本 范围是 100以内
            #!/bin/bash
            #n=$[RANDOM%101]
            u=0
            while [ 1 -eq 1 ]
            do
            n=$[RANDOM%101]

            s=$[RANDOM%101]

             let u++
            # read -p '输入一个数字' s
              if [ $n -eq $s ] ; then
                   echo ' 似李'
                  echo "${u}次成功"
                  exit
              elif [ $s -gt $n ] ;then
                    echo '大了'
              else
                    echo '小了'
              fi
            done

        case 分支
                命令结束后 添加  `;;` 而非每行 结尾添加
                case 变量 in
                    条件)
                    命令1 ;;
                    条件)
                    命令2 ;;
                    *)
                    默认命令序列
                esac
            eg:创建 自动部署 nginx 的脚本

                #!/bin/bash
                yum -y install gcc openssl-devel pcre-devel
                tar -xf nginx-1.12.2.tar.gz
                cd nginx-1.12.2
                ./configure
                make
                make install

            Nginx默认安装路径为/usr/local/nginx,该目录下会提供4个子目录，分别如下：
            /usr/local/nginx/conf	配置文件目录
            /usr/local/nginx/html	网站页面目录
            /usr/local/nginx/logs	Nginx日志目录
            /usr/local/nginx/sbin	主程序目录
            [root@svr5 ~]# /usr/local/nginx/sbin/nginx                //启动服务
            [root@svr5 ~]# /usr/local/nginx/sbin/nginx    -s stop        //关闭服务
            [root@svr5 ~]# /usr/local/nginx/sbin/nginx    -V            //查看软件信息
            [root@server0 ~]# netstat -ntulp | grep nginx             //查看nginx 状态
            tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      32743/nginx: master

            netstat 命令
                    查询系统中启动的端口信息 ,
                    -ntulp 连着用 推荐
                    -n以数字格式显示端口号
                    -t显示TCP连接的端口
                    -u显示UDP连接的端口
                    -l显示服务正在监听的端口信息，如httpd启动后，会一直监听80端口
                    -p显示监听端口的服务名称是什么（也就是程序名称
            eg: 使用case 编辑一个 检测 nginx 启动 停止 显示 状态的命令.
                #!/bin/bash
                case $1 in
                start|o) ###这里表示 脚本后接的参数 可以为 start 或者 o 简写 提高输入效率
                        /usr/local/nginx/sbin/nginx ;;
                stop|e)
                        /usr/local/nginx/sbin/nginx -s stop ;;
                restart|r)
                        /usr/local/nginx/sbin/nginx -s stop
                         /usr/local/nginx/sbin/nginx  ;;
                status|u)
                        netstat -ntulp | grep -q nginx   ####这里的 -q 是查询后 不输出结果
                        [ $? -eq 0 ] && echo 'start success' || echo 'not start' ;;
                *)
                        echo 'enter start stop restart status' ;;
                esac

        函数
            格式1:
                 function 函数名 {
                         命令
                                }

            格式2:
                 函数名(){
                        命令序列
                        }
            改变终端输出字符的颜色 并改 回来
            echo -e "\033[31mABCD\033[0M" ##31 表示颜色
                 #!/bin/bash
                co(){
                echo -e "\033[$1m$2\033[0m"
                }
                co 34 SIX
                co 35 SIX
        中断 退出 等待
            wait //等待所有后台结束后退出 程序 ;;配合  & 使用
            exit  //退出整个脚本
            break //退出脚本中的循环,执行循环后的任务
            continue  //退出当前循环进行下一次循环


            eg: 求出 1-20 以内 被 6 整除 数字的 平方
                #!/bin/bash
                for i in {1..20}
                do
                n=$[i%6]
                         [ $n -ne 0 ] && continue
                         echo $[i*i]

                done
        字符串截取及切割
            字符串截取
            字符字符串起始 第一位为0
            ${变量名:起始位置:长度}
            若起始位置为第一个字符 则 起始位可以省略
                ${x::5}

            子串替换的两种用法：
            只替换第一个匹配结果：
            ${变量名/old/new}
            替换全部匹配结果：
            ${变量名//old/new}
            字符串掐头去尾：
            从左向右，最短匹配删除：${变量名#*关键词}
            从左向右，最长匹配删除：${变量名##*关键词}
            从右向左，最短匹配删除：${变量名%关键词*}
            从右向左，最长匹配删除：${变量名%%关键词*}
        eg:
                [root@server0 ~]# a=123asdfasdf
                [root@server0 ~]# echo ${a//asd/123}
                123123f123f

                [root@server0 ~]# echo $a
                root:x:0:0:root:/root:/bin/bash
                [root@server0 ~]# echo ${a%root*}
                root:x:0:0:root:/
                [root@server0 ~]# echo ${a%%root*}

                [root@server0 ~]# echo ${a#*root}
                :x:0:0:root:/root:/bin/bash
                [root@server0 ~]# echo ${a##*root}
                :/bin/bash

        eg:    将 后缀为 txt 的文件修改为 doc
                #!/bin/bash
                for i in `ls *.txt`
                do
                        m=${i%.*}
                        mv $i $m.doc
                        echo 'success'
                done

