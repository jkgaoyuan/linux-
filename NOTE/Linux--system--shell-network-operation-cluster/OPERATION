运维 (7天)
        主机ip 以及ip地址
        clients eth0 192.168.4.10/24
        proxy   eth0 192.168.4.5/24
                eth1 192.168.2.5/24
        web1    eth1 192.168.2.100/24
        web2    eth2 192.168.2.200/24
    web服务器对比
        unix 与 linux 平台下
        -apache  Nginx  Tengine Lighttp
        -Tomcat   IBM websphere Jboss
        windows
        -IIS Internet information server
        Nginx(相比于Apache,开源) 更快 更小  效率更高 并发量更高
        Tengine 为Nginx的改编
    LNMP(PHP) NGNIX+PHP  只能这么配合
    TOMCATE+JAVA

    Nginx 介绍
        轻量级的http服务器
        高性能http和反向代理服务器同时 也是 imap /pops smtp 代理服务器
        现代化软件都是模块化设计

    如何查看 网页使用的服务器
        F12 进入 network 选项 ,选择其中一项, 查看 response head  找关键词    server
    安全策略都是针对用户和用户组的
        谁启动服务,该服务就具有谁的权限.
    安装 NGINX
        root ------>httpd(nginx)--------客户访问
        useradd nginx
        root执行命令---->以nginx普通用户启动服务 systemctl restart
        ##########################################################
        由于软件可能存在 漏洞 ,在yum 安装程序的时候 会自动创建一个用户名称和软件相同的用户,启动服务的时候以该用户启动.
        若该程序被攻击,那么攻击者也只能获取该用户的权限 与 / 无关. 而在使用源码安装的的时候 这些需要 手动 操作.
        ##########################################################
        1)安装依赖包
            若不知道依赖包 则 查看 官方文档 或者直接安装 包什么错误 装什么包
        2)./configure 安装
            [root@proxy ~]# yum -y install gcc pcre-devel openssl-devel        //安装依赖包
            [root@proxy ~]# useradd -s /sbin/nologin nginx
            [root@proxy ~]# tar  -xf   nginx-1.10.3.tar.gz
            [root@proxy ~]# cd  nginx-1.10.3
            [root@proxy nginx-1.10.3]# ./configure   \
            > --prefix=/usr/local/nginx   \                //指定安装路径
            > --user=nginx   \                            //指定用户
            > --group=nginx  \                            //指定组
            > --with-http_ssl_module                        //开启SSL加密功能 ###with XXX 安装附加模块 without XXX不添加 附加模块
            [root@proxy nginx-1.10.3]# make && make install    //编译并安装

        3)启动服务
            [root@proxy ~]# /usr/local/nginx/sbin/nginx                    //启动服务
            [root@proxy ~]# /usr/local/nginx/sbin/nginx -s stop            //关闭服务
            [root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload        //重新加载配置文件 ### (不关闭服务)使配置文件立刻生效
            [root@proxy ~]# /usr/local/nginx/sbin/nginx -V                //查看软件信息
            [root@proxy ~]# ln -s /usr/local/nginx/sbin/nginx /sbin/        //方便后期使用
            当创建完成 软连接后 就可以使用
                nginx 来代替 /usr/local/nginx/sbin/nginx
                nginx -s stop


        查看服务端口
            netstat命令可以查看系统中启动的端口信息，该命令常用选项如下：
                -a显示所有端口的信息
                -n以数字格式显示端口号
                -t显示TCP连接的端口
                -u显示UDP连接的端口
                -l显示服务正在监听的端口信息，如httpd启动后，会一直监听80端口
                -p显示监听端口的服务名称是什么（也就是程序名称）
                netstat -untlp
                        -anptu
                netstat -anptul | grep 80 查找80 端口谁在使用


        版本升级/功能安装
            功能安装没有办法动态安装只能重新安装(升级安装)
            1.版本老旧,需要升级
            2.添加模块

            生成的objs 是从src(源码)中提取需要安装的文件,且没有编译,使用make(而不是make install)编译生成安装文件.
            make install 是重新安装将会覆盖/usr/local/nginx/html or conf or logs or /sbin/nginx ,也就是这些文件夹下所有的文件将会删除.

        1）编译新版本nginx软件
            [root@proxy ~]# tar  -zxvf   nginx-1.12.2.tar.gz
            [root@proxy ~]# cd nginx-1.12.2
            [root@proxy nginx-1.12.2]# ./configure   \
            > --prefix=/usr/local/nginx   \
            > --user=nginx   \
            > --group=nginx  \
            > --with-http_ssl_module
            ####################### 注意这里是make 且 不适用make install(重新安装)
            [root@proxy nginx-1.12.2]# make

        2)备份老的nginx主程序，并使用编译好的新版本nginx替换老版本
            [root@proxy nginx-1.12.2]# mv /usr/local/nginx/sbin/nginx  \
            >/usr/local/nginx/sbin/nginxold
            [root@proxy nginx-1.12.2]# cp objs/nginx  /usr/local/nginx/sbin/         //拷贝新版本

            ###########################################
            [root@proxy nginx-1.12.2]# make upgrade                            //升级
            ############################################333
            #或者使用killall nginx杀死进程后再启动nginx。
            /usr/local/nginx/sbin/nginx -t
            nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok
            nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful
            kill -USR2 `cat /usr/local/nginx/logs/nginx.pid`
            sleep 1
            test -f /usr/local/nginx/logs/nginx.pid.oldbin
            kill -QUIT `cat /usr/local/nginx/logs/nginx.pid.oldbin`
            [root@proxy ~]# /usr/local/nginx/sbin/nginx –v                //查看版本

    访问测试
        1)分别使用浏览器和命令行工具curl测试服务器页面
            [root@client ~]# firefox http://192.168.4.5
            [root@client ~]# curl http://192.168.4.5

    LNMP的配置
    nginx 和 httpd 的配置
        httpd 配置
            <virtualhost *:80>
            documentroot /var/www/html
            servername www.example.com
            </virtualhost>
        nginx 配置
          vim /usr/local/nginx/conf/nginx.conf
            server {
                ###监听端口
                listen 80;
                ###域名
                server_name www.dc.com;
                ####网页根路径
                root html;###默认写相对路径,也可以是用绝对路径
                ######root "/usr/local/nginx/html";
                ####默认首页,第二个是当第一个网页失效的时候备份
                index index.html index.htm;
                    }
          配置格式
            server {                     #### server 代表的是     网站

                location / {             #### location 代表的是  网站下的某个网页
                }
                location / {
                }
            }

    实验目的: 给网页添加用户访问认证,输入正确的账户密码才能访问
        1)修改配置文件
            vim /usr/local/nginx/conf/nginx.con
            server {
            listen       80;
            server_name  localhost;

            #charset koi8-r;

            #access_log  logs/host.access.log  main;
            需要手动添加的配置
            ###############################################
            auth_basic "Input Password:";                 ###提示信息
            auth_basic_user_file "/usr/local/nginx/pass"; ###保存用户名密码的文件
            ###############################################
            location / {
                root   html;
                index  index.html index.htm;
            }
        2)生成密码文件
            ####################
            ###不要使用 vim 创建##
            ####################
            安装httpd-Tools,创建 密码文件
            yum -y install httpd-tools
            #############################################################
            -c 新建文件,当添加第二个用户时应当 不写 -c
            [root@proxy lnmp_soft]# htpasswd -c /usr/local/nginx/pass tom
            New password:
            Re-type new password:
            Adding password for user tom
            [root@proxy lnmp_soft]# htpasswd /usr/local/nginx/pass dc
            New password:
            Re-type new password:
            Adding password for user dc

        3)重启服务
            软连接
            nginx -s reload
        4)排错

            cd /usr/local/nginx/logs

            tailf error.log
            进入文件后 一路回车 让页面 什么都不显示 用浏览器访问 , 之后出现的错误错误信息 可作为排错的依据

    虚拟主机服务
        基于域名(最常用),基于IP,基于端口

        1)修改配置文件
                 每一个server 就是一个 网站 并且放在 html中
            [root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
                .. ..
                server {
                        listen       80;                                      //端口
                        server_name  www.a.com;                                //域名
                        auth_basic "Input Password:";                        //认证提示符
                        auth_basic_user_file "/usr/local/nginx/pass";        //认证密码文件
                location / {
                        root   html;                                    //指定网站根路径
                        index  index.html index.htm;
                               }

                }
                … …
                    server {
                        listen  80;                                        //端口
                        server_name  www.b.com;                                //域名
                    location / {
                        root   www;                                 //指定网站根路径
                        index  index.html index.htm;
                        }
                }

            批量修改配置文件参考 ADMIN 349 行
            vim 末行模式 中 :88,90s/#//
        2) 重启服务
            /usr/local/nginx/sbin/nginx -s reload(重新加载nginx配置文件)


    https加密服务
         对称加密
            AES DES [安全]
            单机加密(安全)
            网络加密(不安全)
         非对称加密
            RSA DSA 私钥 公钥
         信息摘要
            MD5 SHA256 SHA


         1)生成私钥与公钥
            [root@proxy ~]# cd /usr/local/nginx/conf
            [root@proxy ~]# openssl genrsa > cert.key                            //生成私钥
                                              格式
            [root@proxy ~]# openssl req -new -x509 -key cert.key > cert.pem      //生成证书

         2)修改配置文件
            [root@proxy ~]# vim  /usr/local/nginx/conf/nginx.conf
            … …
            server {
                    listen       443 ssl;
                    server_name            www.c.com;
                    ssl_certificate      cert.pem;         #这里是证书文件
                    ssl_certificate_key  cert.key;         #这里是私钥文件
                    ssl_session_cache    shared:SSL:1m;
                    ssl_session_timeout  5m;
                    ssl_ciphers  HIGH:!aNULL:!MD5;
                    ssl_prefer_server_ciphers  on;
                    location / {
                        root   html;
                        index  index.html index.htm;
                    }
                }
         3)重启服务
            [root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
            #请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
            #[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)

         4)验证
            [root@client ~]# vim /etc/hosts  ####添加hosts 由于没有 dns服务器.
            192.168.4.5    www.c.com  www.a.com   www.b.com
            firefox https://www.c.com
            curl  https://www.c.com
            需要输入密码
            curl  -u tom:123 https://www.c.com
    动态页面和静态页面的实现
         区别
            动态(Java,php,py,sh...)代码在服务器执行
            静态(jpg,MP4...)
            注意，FastCGI的内存消耗问题，一个PHP-FPM解释器将消耗约25M的内存。
         1) 安装 nginx mariadb(客户端软件)  mariadb-server(服务器端软件) mariadb-devel(mariadb依赖软件) php php-ftm(PHP服务) php-mysql(链接mysql数据库模块)
            [root@proxy ~]# yum -y install   mariadb   mariadb-server   mariadb-devel
            [root@proxy ~]# yum -y  install  php   php-mysql
            [root@proxy ~]# yum -y  install php-fpm


         2)启动服务
            这里需要注意的是，如果服务器上已经启动了其他监听80端口的服务软件（如httpd），则需要先关闭该服务，否则会出现冲突。

            1.启动Nginx服务
            [root@proxy ~]# systemctl stop httpd                //如果该服务存在则关闭该服务
            [root@proxy ~]# /usr/local/nginx/sbin/nginx             //启动Nginx服务
            [root@proxy ~]# netstat -utnlp | grep :80
            tcp    0    0 0.0.0.0:80        0.0.0.0:*        LISTEN        32428/nginx
            2.启动MySQL服务
            [root@proxy ~]# systemctl start  mariadb           //启动服务器
            [root@proxy ~]# systemctl status mariadb           //查看服务状态
            [root@proxy ~]# systemctl enable mariadb           //设置开机启动
            3.启动PHP-FPM服务
            [root@proxy ~]# systemctl start php-fpm           //启动服务
            [root@proxy ~]# systemctl status php-fpm          //查看服务状态
            [root@proxy ~]# systemctl enable php-fpm          //设置开机启动


            若网页会静态,nginx 直接返回文件
            若网页会动态,nginx 转发给9000(php)端口

            location 匹配用户的地址栏,从域名/ip往后 ; 且支持正则模糊匹配 添加 '~'; 不添加~ 表示模糊匹配
              location 一定要写在 server 中来
              server {
                location / {
                deny 1.1.1.1;
                allow all;
                }

                location /abc {
                allow all;
                }
                location /dachui {
                allow all;
                    }
                }

                #######匹配 动态网页 (以php 结尾的文件, '\'代表 转义 ,   ,'~' 表示使用正则 , '.' 在linux 中代表 匹配任意字符)
                修改nginx.conf 动静分离
                location ~ \.php$ {
                  root           html;
                ################# 将动态文件转发给9000 端口 交个 php-fpm 处理
                  fastcgi_pass   127.0.0.1:9000;
                  fastcgi_index  index.php;
                 #  fastcgi_param  SCRIPT_FILENAME  /s    cripts$fastcgi_script_name;
                 ########## 导入 nginx 变量
                  include        fastcgi.conf;
                 }


         3)添加 网页测试访问
                cd /root/lnmp_soft/php_scripts/
                firefox 192.168.4.5/mysql.php
         3)排错
            当重启nginx服务没有错误时,且页面加载失败那么,可能是 php 错误
            Nginx的默认访问日志文件为/usr/local/nginx/logs/access.log
            Nginx的默认错误日志文件为/usr/local/nginx/logs/error.log
            PHP默认错误日志文件为/var/log/php-fpm/www-error.log
##################################################################
    地址重写
             NGINX服务器地址重写
             用到的参数 : rewrite
             rewrite regex replacement flag
             用到的参数 : rewrite 旧地址(支持正则表达式) 新地址 参数
             #######################
             地址重写格式【总结】
             #######################
             rewrite 旧地址 新地址 [选项];
             last 不再读其他rewrite
             break 不再读其他语句，结束请求
             redirect 临时重定向
             permament 永久重定向
         1.访问a跳转到b
            1)修改nginx配置参数

                [root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
                .. ..
                server {
                        listen       80;
                        server_name  localhost;
                charset utsf-8; ####支持中文显示
                rewrite /a.html  /b.html redirect; ####实现地址转换 ### redirect 访问a.html重定向到b.html（跳转地址栏）

                ###auth_basic "Input Password:"; #提示信息
                ###auth_basic_user_file "/usr/local/nginx/pass"; ###保存用户名密码的文件
                location / {
                    root   html;
                index  index.html index.htm;
                }
                }
            2) 测试访问
                重新加载配置文件
                /usr/local/nginx/sbin/nginx  -s  reload
                firefox  http://192.168.4.5/a.html 添加 redirect 后注意访问 地址栏的的变化

         2.访问192.168.4.5的请求重定向至www.tmooc.cn
            1)修改配置文件
                [root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
                .. ..
                server {
                        listen       80;
                        server_name  localhost;
         #####################################################
                rewrite ^/  http://www.tmooc.cn/;
         ####################################################
                location / {
                    root   html;
                index  index.html index.htm;
                # rewrite /a.html  /b.html  redirect;
                }
                }
            2)访问测试
                /usr/local/nginx/sbin/nginx  -s  reload
                firefox  http://192.168.4.5/a.html (真机测试 虚拟机 没有 网络)

         3.访问192.168.4.5/下面子页面，重定向至www.tmooc.cn/下相同的页面
            1)修改配置文件
                [root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
                .. ..
                server {
                        listen       80;
                        server_name  localhost;
                ############在正则中()表示复制 \1 表示粘贴第一个参数,
                ############但是 在 nginx中粘贴第一个复制参数  $1 表示;;; 注意这个不同
                rewrite ^/(.*)$  http://www.tmooc.cn/$1;
                location / {
                    root   html;
                index  index.html index.htm;
                }
                }
            2) 重新加载配置文件 ,访问测试
               /usr/local/nginx/sbin/nginx  -s  reload
               firefox 192.168.4.5/free

         4.修改配置文件(实现curl和火狐访问相同链接返回的页面不同)
            不同终端访问相同的网站 显示不同网页(移动端和桌面端网页的实现)
            1)修改配置文件
                [root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
                .. ..
                server {
                        listen       80;
                        server_name  localhost;
                location / {
                    root   html;
                index  index.html index.htm;
                }
                #这里，~符号代表模糊正则匹配，*符号代表不区分大小写,只要包含firefox 字符就执行
                if ($http_user_agent ~* firefox) {            //识别客户端firefox浏览器
                rewrite ^(.*)$  /firefox/$1;
                }
                }
            2) 添加网页
                [root@proxy ~]# echo "I am Normal page" > /usr/local/nginx/html/test.html
                [root@proxy ~]# mkdir  -p  /usr/local/nginx/html/firefox/
                [root@proxy ~]# echo "firefox page" > /usr/local/nginx/html/firefox/test.html
            3)重启服务 访问测试
                [root@proxy html]# nginx -s reload
                firefox 192.168.4.5/test.html
                Google-chrome 192.168.4.5/test.html


    NGINX反向代理服务器
         功能: 调度(负载均衡).健康检查(/)
             使用Nginx实现Web反向代理功能，实现如下功能：
                后端Web服务器两台，可以使用httpd实现
                Nginx采用轮询的方式调用后端Web服务器
                两台Web服务器的权重要求设置为不同的值
                最大失败次数为1，失败超时时间为30秒

         算法: 轮询算法(roundrobin,RR)
                                 |------->web1
                clients---->proxy-
                                 |------->web2
              IP_hash
         1.部署实施后端Web服务器
             1）部署后端Web1服务器
                [root@web1 ~]# yum  -y  install  httpd
                [root@web1 ~]# echo "192.168.2.100" > /var/www/html/index.html
                [root@web1 ~]# systemctl restart httpd
                [root@web1 ~]# firewall-cmd --set-default-zone=trusted
                [root@web1 ~]# setenforce 0
             2)部署后端Web2服务器
                [root@web2 ~]# yum  -y  install  httpd
                [root@web2 ~]# echo "192.168.2.200" > /var/www/html/index.html
                [root@web2 ~]# systemctl restart httpd
                [root@web2 ~]# firewall-cmd --set-default-zone=trusted
                [root@web2 ~]# setenforce 0
         2.配置Nginx服务器，添加服务器池，实现反向代理功能
             1）修改/usr/local/nginx/conf/nginx.conf配置文件
                [root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
                .. ..
                http {
                .. ..
                #使用upstream定义后端服务器集群，集群名称任意(如webserver)
                #使用server定义集群中的具体服务器和端口
                upstream webserver {
                                server 192.168.2.100:80;
                                server 192.168.2.200:80;
                        }
                .. ..
                server {
                        listen        80;
                        server_name  localhost;
                            location / {
                #通过proxy_pass将用户的请求转发给webserver集群
                            proxy_pass http://webserver;
                        }
                }
             2)重启nginx服务
                [root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
                #请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
                #[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
             3）客户端使用浏览器访问代理服务器测试轮询效果
                [root@client ~]# curl http://192.168.4.5            //使用该命令多次访问查看效果
                [root@client ~]# curl http://192.168.4.5            //使用该命令多次访问查看效果

         3.配置upstream服务器集群池属性
             1）设置失败次数，超时时间，权重
                weight可以设置后台服务器的权重，max_fails可以设置后台服务器的失败次数，fail_timeout可以设置后台服务器的失败超时时间。
                [root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
                .. ..
                http {
                .. ..
                upstream webserver {
                           ####这里端口默认可以不写(80)         失败多少次后认为失败    超时(检测服务失败后重新开始检测的时间)
                                server 192.168.2.100 weight=1 max_fails=1 fail_timeout=30;
                                server 192.168.2.200 weight=2 max_fails=2 fail_timeout=30;
                                ####彻底关闭2.101的集群服务
                                server 192.168.2.101 down;
                                ip_hash; ###客户端访问网页后,之后的访问依然又第一次提供服务的server提供,除非该server挂了
                        }
                #weight设置服务器权重值，默认值为1
                #max_fails设置最大失败次数
                #fail_timeout设置失败超时时间，单位为秒
                #down标记服务器已关机，不参与集群调度
                .. ..
                server {
                        listen        80;
                        server_name  localhost;
                            location / {
                            proxy_pass http://webserver;
                        }
                }

             2）重启nginx服务
                [root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
                #请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
                #[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)

             3）关闭一台后端服务器（如web1）
                [root@web1 ~]# systemctl stop httpd

             4）客户端使用浏览器访问代理服务器测试轮询效果
                [root@client ~]# curl http://192.168.4.5            //使用该命令多次访问查看效果
             5)重启web1,再次进行测试
                [root@client ~]# curl http://192.168.4.5            //使用该命令多次访问查看效果

    Nginx的TCP/UDP调度器
         问题

            使用Nginx实现TCP/UDP调度器功能，实现如下功能：
            后端SSH服务器两台
            Nginx编译安装时需要使用--with-stream，开启ngx_stream_core_module模块
            Nginx采用轮询的方式调用后端SSH服务器
         方案

            使用4台RHEL7虚拟机，其中一台作为Nginx代理服务器，该服务器需要配置两块网卡，
            IP地址分别为192.168.4.5和192.168.2.5，两台SSH服务器IP地址分别为192.168.2.100和192.168.2.200。
            客户端测试主机IP地址为192.168.4.10。

         步骤
         1.部署支持4层TCP/UDP代理的Nginx服务器
           1)部署nginx服务器
                编译安装必须要使用--with-stream参数开启4层代理模块。
                [root@proxy ~]# yum -y install gcc pcre-devel openssl-devel        //安装依赖包
                [root@proxy ~]# tar  -xf   nginx-1.12.2.tar.gz
                [root@proxy ~]# cd  nginx-1.12.2
                [root@proxy nginx-1.12.2]# ./configure   \
                > --with-http_ssl_module                                //开启SSL加密功能
                > --with-stream                                       //开启4层反向代理功能
                [root@proxy nginx-1.12.2]# make && make install           //编译并安装

         2.配置Nginx服务器，添加服务器池，实现TCP/UDP反向代理功能
            1)修改/usr/local/nginx/conf/nginx.conf配置文件
            ########################################################################
                注意这段配置文件应该在http 之前 ;;; 若写在 http中则会使用 http协议来传输数据
            ##########################################################################
                [root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
                stream {
                            upstream backend {
                               server 192.168.2.100:22;            //后端SSH服务器的IP和端口
                               server 192.168.2.200:22;
                }
                            server {
                                listen 12345;                    //Nginx监听的端口
                                proxy_connect_timeout 1s;         //连接的超时时间，可选配置
                                proxy_timeout 3s;
                                 proxy_pass backend;
                             }
                }
                http {
                .. ..
                }
            2)重启nginx服务
                [root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
                #请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
                #[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)


            3）客户端使用访问代理服务器测试轮询效果
                [root@client ~]# ssh 192.168.4.5 -p 12345            //使用该命令多次访问查看效果

    Nginx常见问题处理
         问题

            本案例要求对Nginx服务器进行适当优化，解决如下问题，以提升服务器的处理性能：
            如何自定义返回给客户端的404错误页面
            如何查看服务器状态信息
            如果客户端访问服务器提示“Too many open files”如何解决
            如何解决客户端访问头部信息过长的问题
            如何让客户端浏览器缓存数据
            日志切割
            开启gzip压缩功能，提高数据传输效率
            开启文件缓存功能
            然后客户机访问此Web服务器验证效果：
            使用ab压力测试软件测试并发量
            编写测试脚本生成长头部信息的访问请求
            客户端访问不存在的页面，测试404错误页面是否重定向

         步骤
         1.自定义报错页面
            1)优化前，客户端使用浏览器访问不存在的页面，会提示404文件未找到
                [root@client ~]# firefox http://192.168.4.5/xxxxx        //访问一个不存在的页面
            2）修改Nginx配置文件，自定义报错页面
                [root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
                .. ..
                        charset utf-8;                    //仅需要中文时需要改选项，可选项
                error_page   404  /404.html;    //自定义错误页面
                .. ..
                [root@proxy ~]# vim /usr/local/nginx/html/404.html        //生成错误页面
                Oops,No NO no page …
                [root@proxy ~]# nginx -s reload
                #请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
                #[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)

            3）优化后，客户端使用浏览器访问不存在的页面，会提示自己定义的40x.html页面
                [root@client ~]# firefox http://192.168.4.5/xxxxx        //访问一个不存在的页面

          ###############################################################################

         2.如何查看服务器状态信息（非常重要的功能）
            服务器状态信息
                1.实时并发量
                2.等待的数量
                3.总链接数量
                4.pv量和uv量 需要自己写脚本
                  page view
                  user view
            1）编译安装时使用--with-http_stub_status_module开启状态页面模块
                [root@proxy ~]# tar  -zxvf   nginx-1.12.2.tar.gz
                [root@proxy ~]# cd  nginx-1.12.2
                [root@proxy nginx-1.12.2]# ./configure   \
                > --with-http_ssl_module                        //开启SSL加密功能
                > --with-stream                                //开启TCP/UDP代理模块
                > --with-http_stub_status_module                //开启status状态页面
                [root@proxy nginx-1.12.2]# make && make install    //编译并安装

            2）启用Nginx服务并查看监听端口状态
                ss命令可以查看系统中启动的端口信息，该命令常用选项如下：
                -a显示所有端口的信息
                -n以数字格式显示端口号
                -t显示TCP连接的端口
                -u显示UDP连接的端口
                -l显示服务正在监听的端口信息，如httpd启动后，会一直监听80端口
                -p显示监听端口的服务名称是什么（也就是程序名称）
                注意：在RHEL7系统中可以使用ss命令替代netstat命令，功能一样，选项一样。

                [root@proxy ~]# /usr/local/nginx/sbin/nginx
                [root@proxy ~]# netstat  -anptu  |  grep nginx
                tcp        0        0 0.0.0.0:80        0.0.0.0:*        LISTEN        10441/nginx
                [root@proxy ~]# ss  -anptu  |  grep nginx
            3）修改Nginx配置文件，定义状态页面
                [root@proxy ~]# cat /usr/local/nginx/conf/nginx.conf
                … …
                location /status {
                                stub_status on;
                                 #allow IP地址;
                                 #deny IP地址;
                        }
                … …
                [root@proxy ~]# nginx

            4）优化后，查看状态页面信息
                [root@proxy ~]# curl  http://192.168.4.5/status
                Active connections: 1
                server accepts handled requests
                 10 10 3
                Reading: 0 Writing: 1 Waiting: 0
            #######################################################
                Active connections：当前活动的连接数量。
                Accepts：已经接受客户端的连接总数量。
                Handled：已经处理客户端的连接总数量。
                （一般与accepts一致，除非服务器限制了连接数量）。
                Requests：客户端发送的请求数量。
                Reading：当前服务器正在读取客户端请求头的数量。
                Writing：当前服务器正在写响应信息的数量。
                Waiting：当前多少客户端在等待服务器的响应

         3.优化Nginx并发量

            操作系统的资源限制
            软件限制(samba,nginx)
            这两者来管理 软件所占用的资源
            ulimit -a
            查看系统 资源限制
                [root@proxy ~]# ulimit -a
                    core file size          (blocks, -c) 0
                    data seg size           (kbytes, -d) unlimited
                    scheduling priority             (-e) 0
                    file size               (blocks, -f) unlimited
                    pending signals                 (-i) 5569
                    max locked memory       (kbytes, -l) 64
                    max memory size         (kbytes, -m) unlimited
                    open files                      (-n) 1024
                    pipe size            (512 bytes, -p) 8
                    POSIX message queues     (bytes, -q) 819200
                    real-time priority              (-r) 0
                    stack size              (kbytes, -s) 8192
                    cpu time               (seconds, -t) unlimited
                    max user processes              (-u) 5569
                    virtual memory          (kbytes, -v) unlimited
                    file locks                      (-x) unlimited
                #########修改硬限制#################################### (决断值)
                [root@proxy ~]# ulimit -Hn 100000
                #########修改软限制#####################################(警告值)
                [root@proxy ~]# ulimit -Sn 100000
                [root@proxy ~]# ulimit -a
                    core file size          (blocks, -c) 0
                    data seg size           (kbytes, -d) unlimited
                    scheduling priority             (-e) 0
                    file size               (blocks, -f) unlimited
                    pending signals                 (-i) 5569
                    max locked memory       (kbytes, -l) 64
                    max memory size         (kbytes, -m) unlimited
                ########################################################
                    open files                      (-n) 100000
                    pipe size            (512 bytes, -p) 8
                ########################################################
                    POSIX message queues     (bytes, -q) 819200
                    real-time priority              (-r) 0
                    stack size              (kbytes, -s) 8192
                    cpu time               (seconds, -t) unlimited
                    max user processes              (-u) 5569
                    virtual memory          (kbytes, -v) unlimited
                    file locks                      (-x) unlimited

            1）优化前使用ab高并发测试
                [root@proxy ~]# ab -n 2000 -c 2000 http://192.168.4.5/
                Benchmarking 192.168.4.5 (be patient)
                socket: Too many open files (24)                //提示打开文件数量过多
            2）修改Nginx配置文件，增加并发量
                [root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
                .. ..
                worker_processes  2;                    //与CPU核心数量一致
                events {
                worker_connections 65535;        //每个worker最大并发连接数
                }
                .. ..
                [root@proxy ~]# nginx -s reload

            3）优化Linux内核参数（最大文件数量）
                [root@proxy ~]# ulimit -a                        //查看所有属性值
                [root@proxy ~]# ulimit -Hn 100000                //设置硬限制（临时规则）
                [root@proxy ~]# ulimit -Sn 100000                //设置软限制（临时规则）
                ################## 永久限制 ###############################
                [root@proxy ~]# vim /etc/security/limits.conf
                    .. ..
                *               soft    nofile            100000
                *               hard    nofile            100000
                #该配置文件分4列，分别如下：
                #用户或组    硬限制或软限制    需要限制的项目   限制的值
            4）优化后测试服务器并发量（因为客户端没调内核参数，所以在proxy测试）
                ab命令最多支持2w并发
                [root@proxy ~]# ab -n 2000 -c 2000 http://192.168.4.5/
         4.优化Nginx数据包头缓存
            1）优化前，使用脚本测试长头部请求是否能获得响应
                [root@proxy ~]# cat lnmp_soft/buffer.sh
                    #!/bin/bash
                    URL=http://192.168.4.5/index.html?
                    for i in {1..5000}
                    do
                        URL=${URL}v$i=$i
                    done
                    curl $URL                                //经过5000次循环后，生成一个长的URL地址栏
                    [root@proxy ~]# ./buffer.sh
                    .. ..
                    <center><h1>414 Request-URI Too Large</h1></center>        //提示头部信息过大

            2）修改Nginx配置文件，增加数据包头部缓存大小
                [root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
                    .. ..
                    http {
                    client_header_buffer_size    1k;        //默认请求包头信息的缓存
                    large_client_header_buffers  4 4k;        //大请求包头部信息的缓存个数与容量
                    .. ..
                    }
                    [root@proxy ~]# nginx -s reload
                    3）优化后，使用脚本测试长头部请求是否能获得响应
                    [root@proxy ~]#cat cat buffer.sh
                    #!/bin/bash
                    URL=http://192.168.4.5/index.html?
                    for i in {1..5000}
                    do
                        URL=${URL}v$i=$i
                        done
                    curl $URL
                [root@proxy ~]# ./buffer.sh



         5.浏览器本地缓存静态数据
            1)浏览器具有缓存功能,但  缓存什么 缓存多久 则是由 服务器决定
                浏览器访问 查看缓存
                about:cache

            2）清空firefox本地缓存数据

            3）修改Nginx配置文件，定义对静态页面的缓存时间
                [root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
                server {
                        listen       80;
                        server_name  localhost;
                        location / {
                            root   html;
                            index  index.html index.htm;
                        }
                location ~* \.(jpg|jpeg|gif|png|css|js|ico|xml)$ {
                expires        30d;            //定义客户端缓存时间为30天
                }
                }
                [root@proxy ~]# cp /usr/share/backgrounds/day.jpg /usr/local/nginx/html
                [root@proxy ~]# nginx -s reload
                #请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
                #[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
            4）优化后，使用Firefox浏览器访问图片，再次查看缓存信息
                [root@client ~]# firefox http://192.168.4.5/day.jpg

                在firefox地址栏内输入about:cache，查看本地缓存数据，查看是否有图片以及过期时间是否正确。


         6.日志切割(重要)
            日志文件越来越大怎么办？单个文件10G? 如何切割？（非常常见的面试题）
            步骤：

            (1) 把旧的日志重命名
            (2) kill USR1 PID(nginx的进程PID号)   kill,(设计用来传递信息), 命令有许多功能 杀进程只是其中一个

            1）手动执行
                备注：/usr/local/nginx/logs/nginx.pid文件中存放的是nginx的进程PID号。
                [root@proxy ~]#  mv access.log access2.log
                [root@proxy ~]# kill -USR1 $(cat /usr/local/nginx/logs/nginx.pid)
            2）自动完成
                每周5的03点03分自动执行脚本完成日志切割工作。
                [root@proxy ~]# vim /usr/local/nginx/logbak.sh
                    #!/bin/bash
                    date=`date +%Y%m%d`
                    logpath=/usr/local/nginx/logs
                    mv $logpath/access.log $logpath/access-$date.log
                    mv $logpath/error.log $logpath/error-$date.log
                    kill -USR1 $(cat $logpath/nginx.pid)
                    [root@proxy ~]# crontab -e
                    03 03 * * 5  /usr/local/nginx/logbak.sh

         7.页面进行压缩处理
                所有主流浏览器支持gzip 压缩
                 小于 1000字节的文件 不压缩
                1）修改Nginx配置文件
                    [root@proxy ~]# cat /usr/local/nginx/conf/nginx.conf
                    http {
                    .. ..
                    gzip on;                            //开启压缩
                    gzip_min_length 1000;                //小文件不压缩
                    gzip_comp_level 4;                //压缩比率
                    gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;
                                                        //对特定文件压缩，类型参考mime.types
                    .. ..
                    }

         8.服务器内存缓存
                  加速用户读取 网页 ,默认不开启.
                1）如果需要处理大量静态文件，可以将文件缓存在(服务器)内存，下次访问会更快。
                http {
                open_file_cache          max=2000  inactive=20s;
                        open_file_cache_valid    60s;
                        open_file_cache_min_uses 5;
                        open_file_cache_errors   off;
                //设置服务器最大缓存2000个文件句柄，关闭20秒内无请求的文件句柄
                //文件句柄的有效时间是60秒，60秒后过期
                //只有访问次数超过5次会被缓存
                }

    Session与Cookie 、 部署memcached 、 Session共享
            通过Nginx调度器负载后端两台Web服务器，实现以下目标：
            部署Nginx为前台调度服务器
            调度算法设置为轮询
            后端为两台LNMP服务器
            部署测试页面，查看PHP本地的Session信息

         1.PHP的本地Session信息
            注册                           写数据
           clients ---------------------> server
            登录                          vim uuid.txt(session)
                                          tom,logined:true/f
            cookie <----------------------
           session: 储存在服务器端,保护用户名登录信息
           cookies: 储存在本地用户,由服务器下发给客户端,保存在客户端的一个文件中
           session和cookie是为了解决 用户登录状态
         搭建集群后 用户的登录会出现问题
            1)部署后端LNMP服务器相关软件(这里跳过)
            2)构建memcached服务
               安装memcached软件，并启动服务
               使用telnet测试memcached服务
               对memcached进行增、删、改、查等操

                验证时需要客户端主机安装telnet，远程memcached来验证服务器的功能：
                add name 0 180 10	//变量不存在则添加
                set name 0 180 10	//添加或替换变量
                replace name 0 180 10	//替换
                get name	//读取变量
                append name 0 180 10	//向变量中追加数据
                delete name	//删除变量
                flush_all	//清空所有
                提示：0表示不压缩，180为数据缓存时间，10为需要存储的数据字节数量。

            构建memcached服务

                (1）使用yum安装软件包memcached
                    [root@proxy ~]# yum -y  install   memcached
                    [root@proxy ~]# rpm -qa memcached
                    memcached-1.4.15-10.el7_3.1.x86_64
                (2) memcached配置文件（查看即可，不需要修改）
                    [root@proxy ~]# vim /usr/lib/systemd/system/memcached.service
                    ExecStart=/usr/bin/memcached -u $USER -p $PORT -m $CACHESIZE -c $MAXCONN $OPTIONS
                    [root@proxy ~]# vim /etc/sysconfig/memcached
                    PORT="11211"
                    USER="memcached"
                    MAXCONN="1024"
                    CACHESIZE="64"
                    OPTIONS=""
                (3）启动服务并查看网络连接状态验证是否开启成功：
                    netstat命令可以查看系统中启动的端口信息，该命令常用选项如下：
                    -a显示所有端口的信息
                    -n以数字格式显示端口号
                    -t显示TCP连接的端口
                    -u显示UDP连接的端口
                    -l显示服务正在监听的端口信息，如httpd启动后，会一直监听80端口
                    -p显示监听端口的服务名称是什么（也就是程序名称）
                    注意：在RHEL7系统中，使用ss命令可以替代netstat，功能与选项一样。
                    [root@proxy ~]# systemctl  start  memcached
                    [root@proxy ~]# systemctl  status  memcached
                    [root@proxy ~]# netstat  -anptu  |  grep memcached
                    tcp    0    0 0.0.0.0:11211        0.0.0.0:*        LISTEN        2839/memcached
                    tcp    0    0 :::11211            :::*                LISTEN        2839/memcached
                    udp    0    0 0.0.0.0:11211        0.0.0.0:*                    2839/memcached
                    udp    0    0 :::11211            :::*                            2839/memcached
                    [root@proxy ~]# setenforce 0
                    [root@proxy ~]# firewall-cmd --set-default-zone=trusted
               使用telnet访问memcached服务器

                (4）使用yum安装telnet
                    [root@proxy ~]# yum -y install telnet
                (5)使用telnet连接服务器测试memcached服务器功能，包括增、删、改、查等操作。
                    [root@proxy ~]# telnet  192.168.4.5  11211
                    Trying 192.168.4.5...
                    ……
                    ##提示：0表示不压缩，180为数据缓存时间，3为需要存储的数据字节数量。
                    set name 0 180 3                //定义变量，变量名称为name
                    plj                            //输入变量的值，值为plj
                    STORED
                    get name                        //获取变量的值
                    VALUE name 0 3                 //输出结果
                    plj
                    END
                    ##提示：0表示不压缩，180为数据缓存时间，3为需要存储的数据字节数量。
                    add myname 0 180 10            //新建，myname不存在则添加，存在则报错
                    set myname 0 180 10            //添加或替换变量
                    replace myname 0 180 10        //替换，如果myname不存在则报错
                    get myname                    //读取变量
                    append myname 0 180 10        //向变量中追加数据
                    delete myname                    //删除变量
                    flush_all                        //清空所有
                    quit                            //退出登录

                                                             web1 + php-pecl-memcache  链接 memcache
                client-------------proxy+memcached-----------
                                                             wbe2 + php-pecl-memcache

         LNMP(php动态网站)+memcached

                沿用已经部署的 LNMP+memcached 网站平台,通过PHP页面实现对memcached服务器的数据操作，
                实现以下目标：

            为PHP安装memcache扩展
                创建PHP页面，并编写PHP代码，实现对memcached的数据操作
            1.方案

                如果希望使用PHP来操作memcached，注意必须要为PHP安装memcache扩展（php-pecl-memcache），否则PHP无法解析连接memcached的指令。客户端测试时需要提前安装telnet远程工具。
            2. 步骤

                实现此案例需要按照如下步骤进行。
                步骤一：创建PHP页面，使用PHP语言测试memcached服务

               1）部署测试页面
                    创建PHP首页文档/usr/local/nginx/html/index.php，测试页面可以参考lnmp_soft/php_scripts/mem.php。
                    注意：192.168.2.5是memcached数据库。
                     [root@web1 ~]# vim /usr/local/nginx/html/mem.php
                    <?php
                    $memcache=new Memcache;                //创建memcache对象
                    $memcache->connect('192.168.2.5',11211) or die ('could not connect!!');
                    $memcache->set('key','test');             //定义变量
                    $get_values=$memcache->get('key');        //获取变量值
                    echo $get_values;
                    ?>
               2）客户端测试（结果会失败）
                    客户端使用浏览器访问服务器PHP首页文档，检验对memcached的操作是否成功：
                    [root@web1 ~]# firefox http://192.168.2.100/mem.php
                    注意：这里因为没有给PHP安装扩展包，默认PHP无法连接memcached数据库，需要给PHP安装扩展模块才可以连接memcached数据库。
               3）为PHP添加memcache扩展
                    [root@web1 ~]# yum -y install  php-pecl-memcache
                    [root@web1 ~]# systemctl restart php-fpm
               4）客户端再次测试（结果会成功显示数据结果）
                    [root@web1 ~]# firefox http://192.168.2.100/mem.php
                     显示test
         PHP实现session共享
            目标: 实现web1 和 web2 将session 写入 proxy  中  并 必要时在 proxy读取session
                  Nginx服务器除了承担调度器外，还需要担任memcached数据库的角色，
                  并在两台后端LNMP服务器上实现PHP的session会话共享。

            1)为PHP添加memcache扩展
                注意，因为后端两台web服务器(web1,web2)都需要连接memcached数据库，所以两台主机都需要安装PHP扩展模块(下面也web1为例)。
                [root@web1 ~]# yum -y install  php-pecl-memcache
                注意：这里因为没有给PHP安装扩展包，默认PHP无法连接memcached数据库，需要给PHP安装扩展模块才可以连接memcached数据库。
            2）客户端测试（结果会失败）
                客户端使用浏览器访问服务器PHP首页文档，检验对memcached的操作是否成功：
                [root@web1 ~]# firefox http://192.168.2.100/test.php
            3）为PHP添加memcache扩展
                [root@web1 ~]# yum -y install  php-pecl-memcache
                [root@web1 ~]# systemctl restart php-fpm
            4）客户端再次测试（结果会成功显示数据结果）
                [root@web1 ~]# firefox http://192.168.2.100/test.php


         TOMCATE+JAVA
            jdk(jre是jdk的阉割版)开放技术
                安装部署JDK基础环境
                安装部署Tomcat服务器
                创建JSP测试页面，文件名为test.jsp，显示服务器当前时间
                访问Tomcat服务器的8080端口，浏览默认首页
            常见的servlet容器


            1.安装部署Tomcat服务器
                1)使用RPM安装JDK环境
                    [root@web1 ~]# yum -y install  java-1.8.0-openjdk                //安装JDK
                    [root@web1 ~]# yum -y install java-1.8.0-openjdk-headless        //安装JDK
                    [root@web1 ~]# java -version                                    //查看JAVA版本
                2）安装Tomcat（apache-tomcat-8.0.30.tar.gz软件包，在lnmp_soft中有提供）
                    [root@web1 ~]# tar -xf  apache-tomcat-8.0.30.tar.gz
                    [root@web1 ~]# mv apache-tomcat-8.0.30  /usr/local/tomcat
                    [root@web1 ~]# ls /usr/local/tomcat
                    bin/                                            //主程序目录
                    lib/                                            //库文件目录
                    logs/                                          //日志目录
                    temp/                                         //临时目录
                    work/                                        //自动编译目录jsp代码转换servlet
                    conf/                                        //配置文件目录
                    webapps/                                        //页面目录
                3）启动服务
                    [root@web1 ~]# /usr/local/tomcat/bin/startup.sh

                4）服务器验证端口信息
                    [root@web1 ~]# netstat -nutlp |grep java        //查看java监听的端口
                    tcp        0      0 :::8080              :::*                LISTEN      2778/java
                    tcp        0      0 ::ffff:127.0.0.1:8005     :::*         LISTEN       2778/java

                    TOMCATE每次启动都需要读取足够多的随机数据 所以会造成8005 端口的服务起不来
                    提示：如果检查端口时，8005端口启动非常慢，可用使用下面的命令用urandom替换random（非必须操作）。
                    [root@web1 ~]# mv /dev/random  /dev/random.bak
                    [root@web1 ~]# ln -s /dev/urandom  /dev/random
                5）客户端浏览测试页面(proxy作为客户端)
                    [root@proxy ~]# firefox http://192.168.2.100:8080


            (2).修改Tomcat配置文件
                1）创建测试JSP页面
                    [root@web1 ~]# vim  /usr/local/tomcat/webapps/ROOT/test.jsp
                    <html>
                    <body>
                    <center>
                    Now time is: <%=new java.util.Date()%>            //显示服务器当前时间
                    </center>
                    </body>
                    </html>
                2）重启服务
                    [root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
                    [root@web1 ~]# /usr/local/tomcat/bin/startup.sh


            (3)验证测试
                1) 测试
                    [root@proxy ~]# firefox http://192.168.2.100:8080
                    [root@proxy ~]# firefox 使用Tomcat部署虚拟主机http://192.168.2.100:8080/test.jsp



            2.使用Tomcat部署虚拟主机
                目标:
                    实现两个基于域名的虚拟主机，域名分别为：www.a.com和 www.b.com
                    使用www.a.com域名访问的页面根路径为/usr/local/tomcat/a/ROOT
                    使用www.b.com域名访问的页面根路径为/usr/local/tomcat/b/base
                    访问www.a.com/test时，页面自动跳转到/var/www/html目录下的页面
                    访问页面时支持SSL加密通讯
                    私钥、证书存储路径为/usr/local/tomcat/conf/cert
                    每个虚拟主机都拥有独立的访问日志文件
                    配置tomcat集群环境
                TOMCATE 修改 conf的 server.conf
                    中参数

                        <Host name="www.a.com"  appBase="a"
                        unpackWARs="true" autoDeploy="true">
                        </Host>

                        # cat /usr/local/tomcat/conf/server.xml
                        <Server>
                           <Service>
                             <Connector port=8080 />
                             <Connector port=8009 />
                             <Engine name="Catalina" defaultHost="localhost">
                        <Host name="www.a.com" appBase="a" unpackWARS="true" autoDeploy="true">
                        </Host>
                        <Host name="www.b.com" appBase="b" unpackWARS="true" autoDeploy="true">
                        </Host>

                (1)配置服务器虚拟主机
                    1）修改server.xml配置文件，创建虚拟主机
                        [root@web1 ~]# vim /usr/local/tomcat/conf/server.xml
                        … …
                        <Host name="www.a.com" appBase="a" unpackWARS="true" autoDeploy="true">
                        </Host>
                        <Host name="www.b.com" appBase="b" unpackWARS="true" autoDeploy="true">
                        </Host>
                    2）创建虚拟主机对应的页面根路径
                        [root@web1 ~]# mkdir -p  /usr/local/tomcat/{a,b}/ROOT
                        [root@web1 ~]# echo "AAA"   > /usr/local/tomcat/a/ROOT/index.html
                        [root@web1 ~]# echo "BBB" > /usr/local/tomcat/b/ROOT/index.html

                    3）重启Tomcat服务器
                        [root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
                        [root@web1 ~]# /usr/local/tomcat/bin/startup.sh
                    4)客户端设置host文件，并浏览测试页面进行测试(proxy充当客户端角色)
                        [root@proxy ~]# vim /etc/hosts
                        … …
                        192.168.2.100      www.a.com  www.b.com
                        [root@proxy ~]# firefox http://www.a.com:8080/        //注意访问的端口为8080
                        [root@proxy ~]# firefox http://www.b.com:8080/

                    访问测试

































