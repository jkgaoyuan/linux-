运维 (7天)
        主机ip 以及ip地址
        clients eth0 192.168.4.10/24
        proxy   eth0 192.168.4.5/24
                eth1 192.168.2.5/24
        web1    eth1 192.168.2.100/24
        web2    eth2 192.168.2.200/24
    web服务器对比
        unix 与 linux 平台下
        -apache  Nginx  Tengine Lighttp
        -Tomcat   IBM websphere Jboss
        windows
        -IIS Internet information server
        Nginx(相比于Apache,开源) 更快 更小  效率更高 并发量更高
        Tengine 为Nginx的改编
    LNMP(PHP) NGNIX+PHP  只能这么配合
    TOMCATE+JAVA

    Nginx 介绍
        轻量级的http服务器
        高性能http和反向代理服务器同时 也是 imap /pops smtp 代理服务器
        现代化软件都是模块化设计

    如何查看 网页使用的服务器
        F12 进入 network 选项 ,选择其中一项, 查看 response head  找关键词    server
    安全策略都是针对用户和用户组的
        谁启动服务,该服务就具有谁的权限.
    安装 NGINX
        root ------>httpd(nginx)--------客户访问
        useradd nginx
        root执行命令---->以nginx普通用户启动服务 systemctl restart
        ##########################################################
        由于软件可能存在 漏洞 ,在yum 安装程序的时候 会自动创建一个用户名称和软件相同的用户,启动服务的时候以该用户启动.
        若该程序被攻击,那么攻击者也只能获取该用户的权限 与 / 无关. 而在使用源码安装的的时候 这些需要 手动 操作.
        ##########################################################
        1)安装依赖包
            若不知道依赖包 则 查看 官方文档 或者直接安装 包什么错误 装什么包
        2)./configure 安装
            [root@proxy ~]# yum -y install gcc pcre-devel openssl-devel        //安装依赖包
            [root@proxy ~]# useradd -s /sbin/nologin nginx
            [root@proxy ~]# tar  -xf   nginx-1.10.3.tar.gz
            [root@proxy ~]# cd  nginx-1.10.3
            [root@proxy nginx-1.10.3]# ./configure   \
            > --prefix=/usr/local/nginx   \                //指定安装路径
            > --user=nginx   \                            //指定用户
            > --group=nginx  \                            //指定组
            > --with-http_ssl_module                        //开启SSL加密功能 ###with XXX 安装附加模块 without XXX不添加 附加模块
            [root@proxy nginx-1.10.3]# make && make install    //编译并安装

        3)启动服务
            [root@proxy ~]# /usr/local/nginx/sbin/nginx                    //启动服务
            [root@proxy ~]# /usr/local/nginx/sbin/nginx -s stop            //关闭服务
            [root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload        //重新加载配置文件 ### (不关闭服务)使配置文件立刻生效
            [root@proxy ~]# /usr/local/nginx/sbin/nginx -V                //查看软件信息
            [root@proxy ~]# ln -s /usr/local/nginx/sbin/nginx /sbin/        //方便后期使用
            当创建完成 软连接后 就可以使用
                nginx 来代替 /usr/local/nginx/sbin/nginx
                nginx -s stop


        查看服务端口
            netstat命令可以查看系统中启动的端口信息，该命令常用选项如下：
                -a显示所有端口的信息
                -n以数字格式显示端口号
                -t显示TCP连接的端口
                -u显示UDP连接的端口
                -l显示服务正在监听的端口信息，如httpd启动后，会一直监听80端口
                -p显示监听端口的服务名称是什么（也就是程序名称）
                netstat -untlp
                        -anptu
                netstat -anptul | grep 80 查找80 端口谁在使用


        版本升级/功能安装
            功能安装没有办法动态安装只能重新安装(升级安装)
            1.版本老旧,需要升级
            2.添加模块

            生成的objs 是从src(源码)中提取需要安装的文件,且没有编译,使用make(而不是make install)编译生成安装文件.
            make install 是重新安装将会覆盖/usr/local/nginx/html or conf or logs or /sbin/nginx ,也就是这些文件夹下所有的文件将会删除.

        1）编译新版本nginx软件
            [root@proxy ~]# tar  -zxvf   nginx-1.12.2.tar.gz
            [root@proxy ~]# cd nginx-1.12.2
            [root@proxy nginx-1.12.2]# ./configure   \
            > --prefix=/usr/local/nginx   \
            > --user=nginx   \
            > --group=nginx  \
            > --with-http_ssl_module
            ####################### 注意这里是make 且 不适用make install(重新安装)
            [root@proxy nginx-1.12.2]# make

        2)备份老的nginx主程序，并使用编译好的新版本nginx替换老版本
            [root@proxy nginx-1.12.2]# mv /usr/local/nginx/sbin/nginx  \
            >/usr/local/nginx/sbin/nginxold
            [root@proxy nginx-1.12.2]# cp objs/nginx  /usr/local/nginx/sbin/         //拷贝新版本

            ###########################################
            [root@proxy nginx-1.12.2]# make upgrade                            //升级
            ############################################333
            #或者使用killall nginx杀死进程后再启动nginx。
            /usr/local/nginx/sbin/nginx -t
            nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok
            nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful
            kill -USR2 `cat /usr/local/nginx/logs/nginx.pid`
            sleep 1
            test -f /usr/local/nginx/logs/nginx.pid.oldbin
            kill -QUIT `cat /usr/local/nginx/logs/nginx.pid.oldbin`
            [root@proxy ~]# /usr/local/nginx/sbin/nginx –v                //查看版本

    访问测试
        1)分别使用浏览器和命令行工具curl测试服务器页面
            [root@client ~]# firefox http://192.168.4.5
            [root@client ~]# curl http://192.168.4.5

    LNMP的配置
    nginx 和 httpd 的配置
        httpd 配置
            <virtualhost *:80>
            documentroot /var/www/html
            servername www.example.com
            </virtualhost>
        nginx 配置
          vim /usr/local/nginx/conf/nginx.conf
            server {
                ###监听端口
                listen 80;
                ###域名
                server_name www.dc.com;
                ####网页根路径
                root html;###默认写相对路径,也可以是用绝对路径
                ######root "/usr/local/nginx/html";
                ####默认首页,第二个是当第一个网页失效的时候备份
                index index.html index.htm;
                    }
          配置格式
            server {                     #### server 代表的是     网站

                location / {             #### location 代表的是  网站下的某个网页
                }
                location / {
                }
            }

    实验目的: 给网页添加用户访问认证,输入正确的账户密码才能访问
        1)修改配置文件
            vim /usr/local/nginx/conf/nginx.con
            server {
            listen       80;
            server_name  localhost;

            #charset koi8-r;

            #access_log  logs/host.access.log  main;
            需要手动添加的配置
            ###############################################
            auth_basic "Input Password:";                 ###提示信息
            auth_basic_user_file "/usr/local/nginx/pass"; ###保存用户名密码的文件
            ###############################################
            location / {
                root   html;
                index  index.html index.htm;
            }
        2)生成密码文件
            ####################
            ###不要使用 vim 创建##
            ####################
            安装httpd-Tools,创建 密码文件
            yum -y install httpd-tools
            #############################################################
            -c 新建文件,当添加第二个用户时应当 不写 -c
            [root@proxy lnmp_soft]# htpasswd -c /usr/local/nginx/pass tom
            New password:
            Re-type new password:
            Adding password for user tom
            [root@proxy lnmp_soft]# htpasswd /usr/local/nginx/pass dc
            New password:
            Re-type new password:
            Adding password for user dc

        3)重启服务
            软连接
            nginx -s reload
        4)排错

            cd /usr/local/nginx/logs

            tailf error.log
            进入文件后 一路回车 让页面 什么都不显示 用浏览器访问 , 之后出现的错误错误信息 可作为排错的依据

    虚拟主机服务
        基于域名(最常用),基于IP,基于端口

        1)修改配置文件
                 每一个server 就是一个 网站 并且放在 html中
            [root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
                .. ..
                server {
                        listen       80;                                      //端口
                        server_name  www.a.com;                                //域名
                        auth_basic "Input Password:";                        //认证提示符
                        auth_basic_user_file "/usr/local/nginx/pass";        //认证密码文件
                location / {
                        root   html;                                    //指定网站根路径
                        index  index.html index.htm;
                               }

                }
                … …
                    server {
                        listen  80;                                        //端口
                        server_name  www.b.com;                                //域名
                    location / {
                        root   www;                                 //指定网站根路径
                        index  index.html index.htm;
                        }
                }

            批量修改配置文件参考 ADMIN 349 行
            vim 末行模式 中 :88,90s/#//
        2) 重启服务
            /usr/local/nginx/sbin/nginx -s reload(重新加载nginx配置文件)


    https加密服务
         对称加密
            AES DES [安全]
            单机加密(安全)
            网络加密(不安全)
         非对称加密
            RSA DSA 私钥 公钥
         信息摘要
            MD5 SHA256 SHA


         1)生成私钥与公钥
            [root@proxy ~]# cd /usr/local/nginx/conf
            [root@proxy ~]# openssl genrsa > cert.key                            //生成私钥
                                              格式
            [root@proxy ~]# openssl req -new -x509 -key cert.key > cert.pem      //生成证书

         2)修改配置文件
            [root@proxy ~]# vim  /usr/local/nginx/conf/nginx.conf
            … …
            server {
                    listen       443 ssl;
                    server_name            www.c.com;
                    ssl_certificate      cert.pem;         #这里是证书文件
                    ssl_certificate_key  cert.key;         #这里是私钥文件
                    ssl_session_cache    shared:SSL:1m;
                    ssl_session_timeout  5m;
                    ssl_ciphers  HIGH:!aNULL:!MD5;
                    ssl_prefer_server_ciphers  on;
                    location / {
                        root   html;
                        index  index.html index.htm;
                    }
                }
         3)重启服务
            [root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
            #请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
            #[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)

         4)验证
            [root@client ~]# vim /etc/hosts  ####添加hosts 由于没有 dns服务器.
            192.168.4.5    www.c.com  www.a.com   www.b.com
            firefox https://www.c.com
            curl  https://www.c.com
            需要输入密码
            curl  -u tom:123 https://www.c.com
    动态页面和静态页面的实现
         区别
            动态(Java,php,py,sh...)代码在服务器执行
            静态(jpg,MP4...)
            注意，FastCGI的内存消耗问题，一个PHP-FPM解释器将消耗约25M的内存。
         1) 安装 nginx mariadb(客户端软件)  mariadb-server(服务器端软件) mariadb-devel(mariadb依赖软件) php php-ftm(PHP服务) php-mysql(链接mysql数据库模块)
            [root@proxy ~]# yum -y install   mariadb   mariadb-server   mariadb-devel
            [root@proxy ~]# yum -y  install  php   php-mysql
            [root@proxy ~]# yum -y  install php-fpm


         2)启动服务
            这里需要注意的是，如果服务器上已经启动了其他监听80端口的服务软件（如httpd），则需要先关闭该服务，否则会出现冲突。

            1.启动Nginx服务
            [root@proxy ~]# systemctl stop httpd                //如果该服务存在则关闭该服务
            [root@proxy ~]# /usr/local/nginx/sbin/nginx             //启动Nginx服务
            [root@proxy ~]# netstat -utnlp | grep :80
            tcp    0    0 0.0.0.0:80        0.0.0.0:*        LISTEN        32428/nginx
            2.启动MySQL服务
            [root@proxy ~]# systemctl start  mariadb           //启动服务器
            [root@proxy ~]# systemctl status mariadb           //查看服务状态
            [root@proxy ~]# systemctl enable mariadb           //设置开机启动
            3.启动PHP-FPM服务
            [root@proxy ~]# systemctl start php-fpm           //启动服务
            [root@proxy ~]# systemctl status php-fpm          //查看服务状态
            [root@proxy ~]# systemctl enable php-fpm          //设置开机启动


            若网页会静态,nginx 直接返回文件
            若网页会动态,nginx 转发给9000(php)端口

            location 匹配用户的地址栏,从域名/ip往后 ; 且支持正则模糊匹配 添加 '~'; 不添加~ 表示模糊匹配
              location 一定要写在 server 中来
              server {
                location / {
                deny 1.1.1.1;
                allow all;
                }

                location /abc {
                allow all;
                }
                location /dachui {
                allow all;
                    }
                }

                #######匹配 动态网页 (以php 结尾的文件, '\'代表 转义 ,   ,'~' 表示使用正则 , '.' 在linux 中代表 匹配任意字符)
                修改nginx.conf 动静分离
                location ~ \.php$ {
                  root           html;
                ################# 将动态文件转发给9000 端口 交个 php-fpm 处理
                  fastcgi_pass   127.0.0.1:9000;
                  fastcgi_index  index.php;
                 #  fastcgi_param  SCRIPT_FILENAME  /s    cripts$fastcgi_script_name;
                 ########## 导入 nginx 变量
                  include        fastcgi.conf;
                 }


         3)添加 网页测试访问
                cd /root/lnmp_soft/php_scripts/
                firefox 192.168.4.5/mysql.php
         3)排错
            当重启nginx服务没有错误时,且页面加载失败那么,可能是 php 错误
            Nginx的默认访问日志文件为/usr/local/nginx/logs/access.log
            Nginx的默认错误日志文件为/usr/local/nginx/logs/error.log
            PHP默认错误日志文件为/var/log/php-fpm/www-error.log
##################################################################
    地址重写
             NGINX服务器地址重写
             用到的参数 : rewrite
             rewrite regex replacement flag
             用到的参数 : rewrite 旧地址(支持正则表达式) 新地址 参数
             #######################
             地址重写格式【总结】
             #######################
             rewrite 旧地址 新地址 [选项];
             last 不再读其他rewrite
             break 不再读其他语句，结束请求
             redirect 临时重定向
             permament 永久重定向
         1.访问a跳转到b
            1)修改nginx配置参数

                [root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
                .. ..
                server {
                        listen       80;
                        server_name  localhost;
                charset utsf-8; ####支持中文显示
                rewrite /a.html  /b.html redirect; ####实现地址转换 ### redirect 访问a.html重定向到b.html（跳转地址栏）

                ###auth_basic "Input Password:"; #提示信息
                ###auth_basic_user_file "/usr/local/nginx/pass"; ###保存用户名密码的文件
                location / {
                    root   html;
                index  index.html index.htm;
                }
                }
            2) 测试访问
                重新加载配置文件
                /usr/local/nginx/sbin/nginx  -s  reload
                firefox  http://192.168.4.5/a.html 添加 redirect 后注意访问 地址栏的的变化

         2.访问192.168.4.5的请求重定向至www.tmooc.cn
            1)修改配置文件
                [root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
                .. ..
                server {
                        listen       80;
                        server_name  localhost;
         #####################################################
                rewrite ^/  http://www.tmooc.cn/;
         ####################################################
                location / {
                    root   html;
                index  index.html index.htm;
                # rewrite /a.html  /b.html  redirect;
                }
                }
            2)访问测试
                /usr/local/nginx/sbin/nginx  -s  reload
                firefox  http://192.168.4.5/a.html (真机测试 虚拟机 没有 网络)

         3.访问192.168.4.5/下面子页面，重定向至www.tmooc.cn/下相同的页面
            1)修改配置文件
                [root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
                .. ..
                server {
                        listen       80;
                        server_name  localhost;
                ############在正则中()表示复制 \1 表示粘贴第一个参数,
                ############但是 在 nginx中粘贴第一个复制参数  $1 表示;;; 注意这个不同
                rewrite ^/(.*)$  http://www.tmooc.cn/$1;
                location / {
                    root   html;
                index  index.html index.htm;
                }
                }
            2) 重新加载配置文件 ,访问测试
               /usr/local/nginx/sbin/nginx  -s  reload
               firefox 192.168.4.5/free

         4.修改配置文件(实现curl和火狐访问相同链接返回的页面不同)
            不同终端访问相同的网站 显示不同网页(移动端和桌面端网页的实现)
            1)修改配置文件
                [root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
                .. ..
                server {
                        listen       80;
                        server_name  localhost;
                location / {
                    root   html;
                index  index.html index.htm;
                }
                #这里，~符号代表模糊正则匹配，*符号代表不区分大小写,只要包含firefox 字符就执行
                if ($http_user_agent ~* firefox) {            //识别客户端firefox浏览器
                rewrite ^(.*)$  /firefox/$1;
                }
                }
            2) 添加网页
                [root@proxy ~]# echo "I am Normal page" > /usr/local/nginx/html/test.html
                [root@proxy ~]# mkdir  -p  /usr/local/nginx/html/firefox/
                [root@proxy ~]# echo "firefox page" > /usr/local/nginx/html/firefox/test.html
            3)重启服务 访问测试
                [root@proxy html]# nginx -s reload
                firefox 192.168.4.5/test.html
                Google-chrome 192.168.4.5/test.html


    NGINX反向代理服务器
         功能: 调度(负载均衡).健康检查(/)
             使用Nginx实现Web反向代理功能，实现如下功能：
                后端Web服务器两台，可以使用httpd实现
                Nginx采用轮询的方式调用后端Web服务器
                两台Web服务器的权重要求设置为不同的值
                最大失败次数为1，失败超时时间为30秒

         算法: 轮询算法(roundrobin,RR)
                                 |------->web1
                clients---->proxy-
                                 |------->web2
              IP_hash
         1.部署实施后端Web服务器
             1）部署后端Web1服务器
                [root@web1 ~]# yum  -y  install  httpd
                [root@web1 ~]# echo "192.168.2.100" > /var/www/html/index.html
                [root@web1 ~]# systemctl restart httpd
                [root@web1 ~]# firewall-cmd --set-default-zone=trusted
                [root@web1 ~]# setenforce 0
             2)部署后端Web2服务器
                [root@web2 ~]# yum  -y  install  httpd
                [root@web2 ~]# echo "192.168.2.200" > /var/www/html/index.html
                [root@web2 ~]# systemctl restart httpd
                [root@web2 ~]# firewall-cmd --set-default-zone=trusted
                [root@web2 ~]# setenforce 0
         2.配置Nginx服务器，添加服务器池，实现反向代理功能
             1）修改/usr/local/nginx/conf/nginx.conf配置文件
                [root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
                .. ..
                http {
                .. ..
                #使用upstream定义后端服务器集群，集群名称任意(如webserver)
                #使用server定义集群中的具体服务器和端口
                upstream webserver {
                                server 192.168.2.100:80;
                                server 192.168.2.200:80;
                        }
                .. ..
                server {
                        listen        80;
                        server_name  localhost;
                            location / {
                #通过proxy_pass将用户的请求转发给webserver集群
                            proxy_pass http://webserver;
                        }
                }
             2)重启nginx服务
                [root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
                #请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
                #[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
             3）客户端使用浏览器访问代理服务器测试轮询效果
                [root@client ~]# curl http://192.168.4.5            //使用该命令多次访问查看效果
                [root@client ~]# curl http://192.168.4.5            //使用该命令多次访问查看效果

         3.配置upstream服务器集群池属性
             1）设置失败次数，超时时间，权重
                weight可以设置后台服务器的权重，max_fails可以设置后台服务器的失败次数，fail_timeout可以设置后台服务器的失败超时时间。
                [root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
                .. ..
                http {
                .. ..
                upstream webserver {
                           ####这里端口默认可以不写(80)         失败多少次后认为失败    超时(检测服务失败后重新开始检测的时间)
                                server 192.168.2.100 weight=1 max_fails=1 fail_timeout=30;
                                server 192.168.2.200 weight=2 max_fails=2 fail_timeout=30;
                                ####彻底关闭2.101的集群服务
                                server 192.168.2.101 down;
                                ip_hash; ###客户端访问网页后,之后的访问依然又第一次提供服务的server提供,除非该server挂了
                        }
                #weight设置服务器权重值，默认值为1
                #max_fails设置最大失败次数
                #fail_timeout设置失败超时时间，单位为秒
                #down标记服务器已关机，不参与集群调度
                .. ..
                server {
                        listen        80;
                        server_name  localhost;
                            location / {
                            proxy_pass http://webserver;
                        }
                }

             2）重启nginx服务
                [root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
                #请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
                #[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)

             3）关闭一台后端服务器（如web1）
                [root@web1 ~]# systemctl stop httpd

             4）客户端使用浏览器访问代理服务器测试轮询效果
                [root@client ~]# curl http://192.168.4.5            //使用该命令多次访问查看效果
             5)重启web1,再次进行测试
                [root@client ~]# curl http://192.168.4.5            //使用该命令多次访问查看效果

    Nginx的TCP/UDP调度器
         问题

            使用Nginx实现TCP/UDP调度器功能，实现如下功能：
            后端SSH服务器两台
            Nginx编译安装时需要使用--with-stream，开启ngx_stream_core_module模块
            Nginx采用轮询的方式调用后端SSH服务器
         方案

            使用4台RHEL7虚拟机，其中一台作为Nginx代理服务器，该服务器需要配置两块网卡，
            IP地址分别为192.168.4.5和192.168.2.5，两台SSH服务器IP地址分别为192.168.2.100和192.168.2.200。
            客户端测试主机IP地址为192.168.4.10。

         步骤
         1.部署支持4层TCP/UDP代理的Nginx服务器
           1)部署nginx服务器
                编译安装必须要使用--with-stream参数开启4层代理模块。
                [root@proxy ~]# yum -y install gcc pcre-devel openssl-devel        //安装依赖包
                [root@proxy ~]# tar  -xf   nginx-1.12.2.tar.gz
                [root@proxy ~]# cd  nginx-1.12.2
                [root@proxy nginx-1.12.2]# ./configure   \
                > --with-http_ssl_module                                //开启SSL加密功能
                > --with-stream                                       //开启4层反向代理功能
                [root@proxy nginx-1.12.2]# make && make install           //编译并安装

         2.配置Nginx服务器，添加服务器池，实现TCP/UDP反向代理功能
            1)修改/usr/local/nginx/conf/nginx.conf配置文件
            ########################################################################
                注意这段配置文件应该在http 之前 ;;; 若写在 http中则会使用 http协议来传输数据
            ##########################################################################
                [root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
                stream {
                            upstream backend {
                               server 192.168.2.100:22;            //后端SSH服务器的IP和端口
                               server 192.168.2.200:22;
                }
                            server {
                                listen 12345;                    //Nginx监听的端口
                                proxy_connect_timeout 1s;         //连接的超时时间，可选配置
                                proxy_timeout 3s;
                                 proxy_pass backend;
                             }
                }
                http {
                .. ..
                }
            2)重启nginx服务
                [root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
                #请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
                #[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)


            3）客户端使用访问代理服务器测试轮询效果
                [root@client ~]# ssh 192.168.4.5 -p 12345            //使用该命令多次访问查看效果

    Nginx常见问题处理
         问题

            本案例要求对Nginx服务器进行适当优化，解决如下问题，以提升服务器的处理性能：
            如何自定义返回给客户端的404错误页面
            如何查看服务器状态信息
            如果客户端访问服务器提示“Too many open files”如何解决
            如何解决客户端访问头部信息过长的问题
            如何让客户端浏览器缓存数据
            日志切割
            开启gzip压缩功能，提高数据传输效率
            开启文件缓存功能
            然后客户机访问此Web服务器验证效果：
            使用ab压力测试软件测试并发量
            编写测试脚本生成长头部信息的访问请求
            客户端访问不存在的页面，测试404错误页面是否重定向

         步骤
         1.自定义报错页面
            1)优化前，客户端使用浏览器访问不存在的页面，会提示404文件未找到
                [root@client ~]# firefox http://192.168.4.5/xxxxx        //访问一个不存在的页面
            2）修改Nginx配置文件，自定义报错页面
                [root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
                .. ..
                        charset utf-8;                    //仅需要中文时需要改选项，可选项
                error_page   404  /404.html;    //自定义错误页面
                .. ..
                [root@proxy ~]# vim /usr/local/nginx/html/404.html        //生成错误页面
                Oops,No NO no page …
                [root@proxy ~]# nginx -s reload
                #请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
                #[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)

            3）优化后，客户端使用浏览器访问不存在的页面，会提示自己定义的40x.html页面
                [root@client ~]# firefox http://192.168.4.5/xxxxx        //访问一个不存在的页面

          ###############################################################################

         2.如何查看服务器状态信息（非常重要的功能）
            服务器状态信息
                1.实时并发量
                2.等待的数量
                3.总链接数量
                4.pv量和uv量 需要自己写脚本
                  page view
                  user view
            1）编译安装时使用--with-http_stub_status_module开启状态页面模块
                [root@proxy ~]# tar  -zxvf   nginx-1.12.2.tar.gz
                [root@proxy ~]# cd  nginx-1.12.2
                [root@proxy nginx-1.12.2]# ./configure   \
                > --with-http_ssl_module                        //开启SSL加密功能
                > --with-stream                                //开启TCP/UDP代理模块
                > --with-http_stub_status_module                //开启status状态页面
                [root@proxy nginx-1.12.2]# make && make install    //编译并安装

            2）启用Nginx服务并查看监听端口状态
                ss命令可以查看系统中启动的端口信息，该命令常用选项如下：
                -a显示所有端口的信息
                -n以数字格式显示端口号
                -t显示TCP连接的端口
                -u显示UDP连接的端口
                -l显示服务正在监听的端口信息，如httpd启动后，会一直监听80端口
                -p显示监听端口的服务名称是什么（也就是程序名称）
                注意：在RHEL7系统中可以使用ss命令替代netstat命令，功能一样，选项一样。

                [root@proxy ~]# /usr/local/nginx/sbin/nginx
                [root@proxy ~]# netstat  -anptu  |  grep nginx
                tcp        0        0 0.0.0.0:80        0.0.0.0:*        LISTEN        10441/nginx
                [root@proxy ~]# ss  -anptu  |  grep nginx
            3）修改Nginx配置文件，定义状态页面
                [root@proxy ~]# cat /usr/local/nginx/conf/nginx.conf
                … …
                location /status {
                                stub_status on;
                                 #allow IP地址;
                                 #deny IP地址;
                        }
                … …
                [root@proxy ~]# nginx

            4）优化后，查看状态页面信息
                [root@proxy ~]# curl  http://192.168.4.5/status
                Active connections: 1
                server accepts handled requests
                 10 10 3
                Reading: 0 Writing: 1 Waiting: 0
            #######################################################
                Active connections：当前活动的连接数量。
                Accepts：已经接受客户端的连接总数量。
                Handled：已经处理客户端的连接总数量。
                （一般与accepts一致，除非服务器限制了连接数量）。
                Requests：客户端发送的请求数量。
                Reading：当前服务器正在读取客户端请求头的数量。
                Writing：当前服务器正在写响应信息的数量。
                Waiting：当前多少客户端在等待服务器的响应

         3.优化Nginx并发量

            操作系统的资源限制
            软件限制(samba,nginx)
            这两者来管理 软件所占用的资源
            ulimit -a
            查看系统 资源限制
                [root@proxy ~]# ulimit -a
                    core file size          (blocks, -c) 0
                    data seg size           (kbytes, -d) unlimited
                    scheduling priority             (-e) 0
                    file size               (blocks, -f) unlimited
                    pending signals                 (-i) 5569
                    max locked memory       (kbytes, -l) 64
                    max memory size         (kbytes, -m) unlimited
                    open files                      (-n) 1024
                    pipe size            (512 bytes, -p) 8
                    POSIX message queues     (bytes, -q) 819200
                    real-time priority              (-r) 0
                    stack size              (kbytes, -s) 8192
                    cpu time               (seconds, -t) unlimited
                    max user processes              (-u) 5569
                    virtual memory          (kbytes, -v) unlimited
                    file locks                      (-x) unlimited
                #########修改硬限制#################################### (决断值)
                [root@proxy ~]# ulimit -Hn 100000
                #########修改软限制#####################################(警告值)
                [root@proxy ~]# ulimit -Sn 100000
                [root@proxy ~]# ulimit -a
                    core file size          (blocks, -c) 0
                    data seg size           (kbytes, -d) unlimited
                    scheduling priority             (-e) 0
                    file size               (blocks, -f) unlimited
                    pending signals                 (-i) 5569
                    max locked memory       (kbytes, -l) 64
                    max memory size         (kbytes, -m) unlimited
                ########################################################
                    open files                      (-n) 100000
                    pipe size            (512 bytes, -p) 8
                ########################################################
                    POSIX message queues     (bytes, -q) 819200
                    real-time priority              (-r) 0
                    stack size              (kbytes, -s) 8192
                    cpu time               (seconds, -t) unlimited
                    max user processes              (-u) 5569
                    virtual memory          (kbytes, -v) unlimited
                    file locks                      (-x) unlimited

            1）优化前使用ab高并发测试
                [root@proxy ~]# ab -n 2000 -c 2000 http://192.168.4.5/
                Benchmarking 192.168.4.5 (be patient)
                socket: Too many open files (24)                //提示打开文件数量过多
            2）修改Nginx配置文件，增加并发量
                [root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
                .. ..
                worker_processes  2;                    //与CPU核心数量一致
                events {
                worker_connections 65535;        //每个worker最大并发连接数
                }
                .. ..
                [root@proxy ~]# nginx -s reload

            3）优化Linux内核参数（最大文件数量）
                [root@proxy ~]# ulimit -a                        //查看所有属性值
                [root@proxy ~]# ulimit -Hn 100000                //设置硬限制（临时规则）
                [root@proxy ~]# ulimit -Sn 100000                //设置软限制（临时规则）
                ################## 永久限制 ###############################
                [root@proxy ~]# vim /etc/security/limits.conf
                    .. ..
                *               soft    nofile            100000
                *               hard    nofile            100000
                #该配置文件分4列，分别如下：
                #用户或组    硬限制或软限制    需要限制的项目   限制的值
            4）优化后测试服务器并发量（因为客户端没调内核参数，所以在proxy测试）
                ab命令最多支持2w并发
                [root@proxy ~]# ab -n 2000 -c 2000 http://192.168.4.5/
         4.优化Nginx数据包头缓存
            1）优化前，使用脚本测试长头部请求是否能获得响应
                [root@proxy ~]# cat lnmp_soft/buffer.sh
                    #!/bin/bash
                    URL=http://192.168.4.5/index.html?
                    for i in {1..5000}
                    do
                        URL=${URL}v$i=$i
                    done
                    curl $URL                                //经过5000次循环后，生成一个长的URL地址栏
                    [root@proxy ~]# ./buffer.sh
                    .. ..
                    <center><h1>414 Request-URI Too Large</h1></center>        //提示头部信息过大

            2）修改Nginx配置文件，增加数据包头部缓存大小
                [root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
                    .. ..
                    http {
                    client_header_buffer_size    1k;        //默认请求包头信息的缓存
                    large_client_header_buffers  4 4k;        //大请求包头部信息的缓存个数与容量
                    .. ..
                    }
                    [root@proxy ~]# nginx -s reload
                    3）优化后，使用脚本测试长头部请求是否能获得响应
                    [root@proxy ~]#cat cat buffer.sh
                    #!/bin/bash
                    URL=http://192.168.4.5/index.html?
                    for i in {1..5000}
                    do
                        URL=${URL}v$i=$i
                        done
                    curl $URL
                [root@proxy ~]# ./buffer.sh



         5.浏览器本地缓存静态数据
            1)浏览器具有缓存功能,但  缓存什么 缓存多久 则是由 服务器决定
                浏览器访问 查看缓存
                about:cache

            2）清空firefox本地缓存数据

            3）修改Nginx配置文件，定义对静态页面的缓存时间
                [root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
                server {
                        listen       80;
                        server_name  localhost;
                        location / {
                            root   html;
                            index  index.html index.htm;
                        }
                location ~* \.(jpg|jpeg|gif|png|css|js|ico|xml)$ {
                expires        30d;            //定义客户端缓存时间为30天
                }
                }
                [root@proxy ~]# cp /usr/share/backgrounds/day.jpg /usr/local/nginx/html
                [root@proxy ~]# nginx -s reload
                #请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
                #[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)
            4）优化后，使用Firefox浏览器访问图片，再次查看缓存信息
                [root@client ~]# firefox http://192.168.4.5/day.jpg

                在firefox地址栏内输入about:cache，查看本地缓存数据，查看是否有图片以及过期时间是否正确。


         6.日志切割(重要)
            日志文件越来越大怎么办？单个文件10G? 如何切割？（非常常见的面试题）
            步骤：

            (1) 把旧的日志重命名
            (2) kill USR1 PID(nginx的进程PID号)   kill,(设计用来传递信息), 命令有许多功能 杀进程只是其中一个

            1）手动执行
                备注：/usr/local/nginx/logs/nginx.pid文件中存放的是nginx的进程PID号。
                [root@proxy ~]#  mv access.log access2.log
                [root@proxy ~]# kill -USR1 $(cat /usr/local/nginx/logs/nginx.pid)
            2）自动完成
                每周5的03点03分自动执行脚本完成日志切割工作。
                [root@proxy ~]# vim /usr/local/nginx/logbak.sh
                    #!/bin/bash
                    date=`date +%Y%m%d`
                    logpath=/usr/local/nginx/logs
                    mv $logpath/access.log $logpath/access-$date.log
                    mv $logpath/error.log $logpath/error-$date.log
                    kill -USR1 $(cat $logpath/nginx.pid)
                    [root@proxy ~]# crontab -e
                    03 03 * * 5  /usr/local/nginx/logbak.sh

         7.页面进行压缩处理
                所有主流浏览器支持gzip 压缩
                 小于 1000字节的文件 不压缩
                1）修改Nginx配置文件
                    [root@proxy ~]# cat /usr/local/nginx/conf/nginx.conf
                    http {
                    .. ..
                    gzip on;                            //开启压缩
                    gzip_min_length 1000;                //小文件不压缩
                    gzip_comp_level 4;                //压缩比率
                    gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;
                                                        //对特定文件压缩，类型参考mime.types
                    .. ..
                    }

         8.服务器内存缓存
                  加速用户读取 网页 ,默认不开启.
                1）如果需要处理大量静态文件，可以将文件缓存在(服务器)内存，下次访问会更快。
                http {
                open_file_cache          max=2000  inactive=20s;
                        open_file_cache_valid    60s;
                        open_file_cache_min_uses 5;
                        open_file_cache_errors   off;
                //设置服务器最大缓存2000个文件句柄，关闭20秒内无请求的文件句柄
                //文件句柄的有效时间是60秒，60秒后过期
                //只有访问次数超过5次会被缓存
                }

    Session与Cookie 、 部署memcached 、 Session共享
            通过Nginx调度器负载后端两台Web服务器，实现以下目标：
            部署Nginx为前台调度服务器
            调度算法设置为轮询
            后端为两台LNMP服务器
            部署测试页面，查看PHP本地的Session信息

         1.PHP的本地Session信息
            注册                           写数据
           clients ---------------------> server
            登录                          vim uuid.txt(session)
                                          tom,logined:true/f
            cookie <----------------------
           session: 储存在服务器端,保护用户名登录信息
           cookies: 储存在本地用户,由服务器下发给客户端,保存在客户端的一个文件中
           session和cookie是为了解决 用户登录状态
         搭建集群后 用户的登录会出现问题
            1)部署后端LNMP服务器相关软件(这里跳过)
            2)构建memcached服务
               安装memcached软件，并启动服务
               使用telnet测试memcached服务
               对memcached进行增、删、改、查等操

                验证时需要客户端主机安装telnet，远程memcached来验证服务器的功能：
                add name 0 180 10	//变量不存在则添加
                set name 0 180 10	//添加或替换变量
                replace name 0 180 10	//替换
                get name	//读取变量
                append name 0 180 10	//向变量中追加数据
                delete name	//删除变量
                flush_all	//清空所有
                提示：0表示不压缩，180为数据缓存时间，10为需要存储的数据字节数量。

            构建memcached服务

                (1）使用yum安装软件包memcached
                    [root@proxy ~]# yum -y  install   memcached
                    [root@proxy ~]# rpm -qa memcached
                    memcached-1.4.15-10.el7_3.1.x86_64
                (2) memcached配置文件（查看即可，不需要修改）
                    [root@proxy ~]# vim /usr/lib/systemd/system/memcached.service
                    ExecStart=/usr/bin/memcached -u $USER -p $PORT -m $CACHESIZE -c $MAXCONN $OPTIONS
                    [root@proxy ~]# vim /etc/sysconfig/memcached
                    PORT="11211"
                    USER="memcached"
                    MAXCONN="1024"
                    CACHESIZE="64"
                    OPTIONS=""
                (3）启动服务并查看网络连接状态验证是否开启成功：
                    netstat命令可以查看系统中启动的端口信息，该命令常用选项如下：
                    -a显示所有端口的信息
                    -n以数字格式显示端口号
                    -t显示TCP连接的端口
                    -u显示UDP连接的端口
                    -l显示服务正在监听的端口信息，如httpd启动后，会一直监听80端口
                    -p显示监听端口的服务名称是什么（也就是程序名称）
                    注意：在RHEL7系统中，使用ss命令可以替代netstat，功能与选项一样。
                    [root@proxy ~]# systemctl  start  memcached
                    [root@proxy ~]# systemctl  status  memcached
                    [root@proxy ~]# netstat  -anptu  |  grep memcached
                    tcp    0    0 0.0.0.0:11211        0.0.0.0:*        LISTEN        2839/memcached
                    tcp    0    0 :::11211            :::*                LISTEN        2839/memcached
                    udp    0    0 0.0.0.0:11211        0.0.0.0:*                    2839/memcached
                    udp    0    0 :::11211            :::*                            2839/memcached
                    [root@proxy ~]# setenforce 0
                    [root@proxy ~]# firewall-cmd --set-default-zone=trusted
               使用telnet访问memcached服务器

                (4）使用yum安装telnet
                    [root@proxy ~]# yum -y install telnet
                (5)使用telnet连接服务器测试memcached服务器功能，包括增、删、改、查等操作。
                    [root@proxy ~]# telnet  192.168.4.5  11211
                    Trying 192.168.4.5...
                    ……
                    ##提示：0表示不压缩，180为数据缓存时间，3为需要存储的数据字节数量。
                    set name 0 180 3                //定义变量，变量名称为name
                    plj                            //输入变量的值，值为plj
                    STORED
                    get name                        //获取变量的值
                    VALUE name 0 3                 //输出结果
                    plj
                    END
                    ##提示：0表示不压缩，180为数据缓存时间，3为需要存储的数据字节数量。
                    add myname 0 180 10            //新建，myname不存在则添加，存在则报错
                    set myname 0 180 10            //添加或替换变量
                    replace myname 0 180 10        //替换，如果myname不存在则报错
                    get myname                    //读取变量
                    append myname 0 180 10        //向变量中追加数据
                    delete myname                    //删除变量
                    flush_all                        //清空所有
                    quit                            //退出登录

                                                             web1 + php-pecl-memcache  链接 memcache
                client-------------proxy+memcached-----------
                                                             wbe2 + php-pecl-memcache

         LNMP(php动态网站)+memcached

                沿用已经部署的 LNMP+memcached 网站平台,通过PHP页面实现对memcached服务器的数据操作，
                实现以下目标：

            为PHP安装memcache扩展
                创建PHP页面，并编写PHP代码，实现对memcached的数据操作
            1.方案

                如果希望使用PHP来操作memcached，注意必须要为PHP安装memcache扩展（php-pecl-memcache），否则PHP无法解析连接memcached的指令。客户端测试时需要提前安装telnet远程工具。
            2. 步骤

                实现此案例需要按照如下步骤进行。
                步骤一：创建PHP页面，使用PHP语言测试memcached服务

               1）部署测试页面
                    创建PHP首页文档/usr/local/nginx/html/index.php，测试页面可以参考lnmp_soft/php_scripts/mem.php。
                    注意：192.168.2.5是memcached数据库。
                     [root@web1 ~]# vim /usr/local/nginx/html/mem.php
                    <?php
                    $memcache=new Memcache;                //创建memcache对象
                    $memcache->connect('192.168.2.5',11211) or die ('could not connect!!');
                    $memcache->set('key','test');             //定义变量
                    $get_values=$memcache->get('key');        //获取变量值
                    echo $get_values;
                    ?>
               2）客户端测试（结果会失败）
                    客户端使用浏览器访问服务器PHP首页文档，检验对memcached的操作是否成功：
                    [root@web1 ~]# firefox http://192.168.2.100/mem.php
                    注意：这里因为没有给PHP安装扩展包，默认PHP无法连接memcached数据库，需要给PHP安装扩展模块才可以连接memcached数据库。
               3）为PHP添加memcache扩展
                    [root@web1 ~]# yum -y install  php-pecl-memcache
                    [root@web1 ~]# systemctl restart php-fpm
               4）客户端再次测试（结果会成功显示数据结果）
                    [root@web1 ~]# firefox http://192.168.2.100/mem.php
                     显示test
         PHP实现session共享
            目标: 实现web1 和 web2 将session 写入 proxy  中  并 必要时在 proxy读取session
                  Nginx服务器除了承担调度器外，还需要担任memcached数据库的角色，
                  并在两台后端LNMP服务器上实现PHP的session会话共享。

            1)为PHP添加memcache扩展
                注意，因为后端两台web服务器(web1,web2)都需要连接memcached数据库，所以两台主机都需要安装PHP扩展模块(下面也web1为例)。
                [root@web1 ~]# yum -y install  php-pecl-memcache
                注意：这里因为没有给PHP安装扩展包，默认PHP无法连接memcached数据库，需要给PHP安装扩展模块才可以连接memcached数据库。
            2）客户端测试（结果会失败）
                客户端使用浏览器访问服务器PHP首页文档，检验对memcached的操作是否成功：
                [root@web1 ~]# firefox http://192.168.2.100/test.php
            3）为PHP添加memcache扩展
                [root@web1 ~]# yum -y install  php-pecl-memcache
                [root@web1 ~]# systemctl restart php-fpm
            4）客户端再次测试（结果会成功显示数据结果）
                [root@web1 ~]# firefox http://192.168.2.100/test.php

          ###############################################################
         TOMCATE+JAVA
            jdk(jre是jdk的阉割版)开放技术
                安装部署JDK基础环境
                安装部署Tomcat服务器
                创建JSP测试页面，文件名为test.jsp，显示服务器当前时间
                访问Tomcat服务器的8080端口，浏览默认首页
            常见的servlet容器


            1.安装部署Tomcat服务器
                1)使用RPM安装JDK环境
                    [root@web1 ~]# yum -y install  java-1.8.0-openjdk                //安装JDK
                    [root@web1 ~]# yum -y install java-1.8.0-openjdk-headless        //安装JDK
                    [root@web1 ~]# java -version                                    //查看JAVA版本
                2）安装Tomcat（apache-tomcat-8.0.30.tar.gz软件包，在lnmp_soft中有提供）
                    [root@web1 ~]# tar -xf  apache-tomcat-8.0.30.tar.gz
                    [root@web1 ~]# mv apache-tomcat-8.0.30  /usr/local/tomcat
                    [root@web1 ~]# ls /usr/local/tomcat
                    bin/                                            //主程序目录
                    lib/                                            //库文件目录
                    logs/                                          //日志目录
                    temp/                                         //临时目录
                    work/                                        //自动编译目录jsp代码转换servlet
                    conf/                                        //配置文件目录
                    webapps/                                        //页面目录
                3）启动服务
                    [root@web1 ~]# /usr/local/tomcat/bin/startup.sh

                4）服务器验证端口信息
                    [root@web1 ~]# netstat -nutlp |grep java        //查看java监听的端口
                    tcp        0      0 :::8080              :::*                LISTEN      2778/java
                    tcp        0      0 ::ffff:127.0.0.1:8005     :::*         LISTEN       2778/java

                    TOMCATE每次启动都需要读取足够多的随机数据 所以会造成8005 端口的服务起不来
                    提示：如果检查端口时，8005端口启动非常慢，可用使用下面的命令用urandom替换random（非必须操作）。
                    [root@web1 ~]# mv /dev/random  /dev/random.bak
                    [root@web1 ~]# ln -s /dev/urandom  /dev/random
                5）客户端浏览测试页面(proxy作为客户端)
                    [root@proxy ~]# firefox http://192.168.2.100:8080


            (2).修改Tomcat配置文件
                1）创建测试JSP页面
                    [root@web1 ~]# vim  /usr/local/tomcat/webapps/ROOT/test.jsp
                    <html>
                    <body>
                    <center>
                    Now time is: <%=new java.util.Date()%>            //显示服务器当前时间
                    </center>
                    </body>
                    </html>
                2）重启服务
                    [root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
                    [root@web1 ~]# /usr/local/tomcat/bin/startup.sh


            (3)验证测试
                1) 测试
                    [root@proxy ~]# firefox http://192.168.2.100:8080
                    [root@proxy ~]# firefox 使用Tomcat部署虚拟主机http://192.168.2.100:8080/test.jsp



            2.使用Tomcat部署虚拟主机(基于域名的虚拟主机)
                目标:
                    实现两个基于域名的虚拟主机，域名分别为：www.a.com和 www.b.com
                    使用www.a.com域名访问的页面根路径为/usr/local/tomcat/a/ROOT
                    使用www.b.com域名访问的页面根路径为/usr/local/tomcat/b/base
                    访问www.a.com/test时，页面自动跳转到/var/www/html目录下的页面
                    访问页面时支持SSL加密通讯
                    私钥、证书存储路径为/usr/local/tomcat/conf/cert
                    每个虚拟主机都拥有独立的访问日志文件
                    配置tomcat集群环境
                TOMCATE 修改 conf的 server.conf
                    中参数

                        <Host name="www.a.com"  appBase="a"
                        unpackWARs="true" autoDeploy="true">
                        </Host>

                        # cat /usr/local/tomcat/conf/server.xml
                        <Server>
                           <Service>
                             <Connector port=8080 />
                             <Connector port=8009 />
                             <Engine name="Catalina" defaultHost="localhost">
                        <Host name="www.a.com" appBase="a" unpackWARS="true" autoDeploy="true">
                        </Host>
                        <Host name="www.b.com" appBase="b" unpackWARS="true" autoDeploy="true">
                        </Host>

                (1)配置服务器虚拟主机
                    1）修改server.xml配置文件，创建虚拟主机
                        [root@web1 ~]# vim /usr/local/tomcat/conf/server.xml
                        … …
                        <Host name="www.a.com" appBase="a" unpackWARS="true" autoDeploy="true">
                        </Host>
                        <Host name="www.b.com" appBase="b" unpackWARS="true" autoDeploy="true">
                        </Host>
                    2）创建虚拟主机对应的页面根路径
                        [root@web1 ~]# mkdir -p  /usr/local/tomcat/{a,b}/ROOT
                        [root@web1 ~]# echo "AAA"   > /usr/local/tomcat/a/ROOT/index.html
                        [root@web1 ~]# echo "BBB" > /usr/local/tomcat/b/ROOT/index.html

                    3）重启Tomcat服务器
                        [root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
                        [root@web1 ~]# /usr/local/tomcat/bin/startup.sh
                    4)客户端设置host文件，并浏览测试页面进行测试(proxy充当客户端角色)
                        [root@proxy ~]# vim /etc/hosts
                        … …
                        192.168.2.100      www.a.com  www.b.com
                        [root@proxy ~]# firefox http://www.a.com:8080/        //注意访问的端口为8080
                        [root@proxy ~]# firefox http://www.b.com:8080/
                (2)修改www.b.com网站的首页目录为base

                    1）使用docBase参数可以修改默认网站首页路径
                        [root@web1 ~]# vim /usr/local/tomcat/conf/server.xml
                        … …
                        <Host name="www.a.com" appBase="a" unpackWARS="true" autoDeploy="true">
                        #########################################################3
                        curl www.a.com/test/ 显示 /var/www/html的 index.html页面
                        #######################################################
                        <Context path="/test" docBase="/var/www/html"/>
                        ################
                        </Host>
                        <Host name="www.b.com" appBase="b" unpackWARS="true" autoDeploy="true">
                        #############################
                        curl www.b.com 显示 base
                        <Context path="" docBase="base"/>
                        </Host>
                        … …
                        [root@web1 ~]# mkdir  /usr/local/tomcat/b/base
                        [root@web1 ~]# echo "BASE" > /usr/local/tomcat/b/base/index.html
                        [root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
                        [root@web1 ~]# /usr/local/tomcat/bin/startup.sh
                    2）测试查看页面是否正确(proxy充当客户端角色)
                        [root@proxy ~]# firefox http://www.b.com:8080/        //结果为base目录下的页面内容


                        TOMCATE的 https 默认做一次 就会给 全部的 虚拟主机启用加密
                        也就说 TOMCATE 不会将端口绑定到虚拟主机(端口只负责转发),

                (3)HTTPS网站加密
                    1)创建加密用的私钥和证书文件
                        [root@web1 ~]# keytool -genkeypair -alias tomcat -keyalg RSA -keystore /usr/local/tomcat/keystore                //提示输入密码为:123456
                        //-genkeypair     生成密钥对
                        //-alias tomcat     密钥别名
                        //-keyalg RSA     定义密钥算法为RSA算法
                        //-keystore         定义密钥文件存储在:/usr/local/tomcat/keystore
                    2)再次修改server.xml配置文件，创建支持加密连接的Connector
                        [root@web1 ~]# vim /usr/local/tomcat/conf/server.xml
                        … …
                        84 行左右
                        <Connector port="8443" protocol="org.apache.coyote.http11.Http11NioProtocol"
                        maxThreads="150" SSLEnabled="true" scheme="https" secure="true"
                    ######添加秘钥文件信息 和密码信息 默认没有需要手写
                        keystoreFile="/usr/local/tomcat/keystore" keystorePass="123456" clientAuth="false" sslProtocol="TLS" />
                        //备注，默认这段Connector被注释掉了，打开注释，添加密钥信息即可
                    3）重启Tomcat服务器
                        [root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
                        [root@web1 ~]# /usr/local/tomcat/bin/startup.sh
                    4）客户端设置host文件，并浏览测试页面进行测试(proxy充当客户端角色)
                        [root@proxy ~]# vim /etc/hosts
                        … …
                        192.168.2.100      www.a.com  www.b.com
                        [root@proxy ~]# firefox https://www.a.com:8443/
                        [root@proxy ~]# firefox https://www.b.com:8443/
                        [root@proxy ~]# firefox https://192.168.2.100:8443/

                (4)配置Tomcat日志

                    1)为每个虚拟主机设置不同的日志文件
                        [root@web1 ~]# vim /usr/local/tomcat/conf/server.xml
                        .. ..
                        <Host name="www.a.com" appBase="a" unpackWARS="true" autoDeploy="true">
                        <Context path="/test" docBase="/var/www/html/" />
                        #从默认localhost虚拟主机中把Valve这段复制过来，适当修改下即可
                        <Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"
                                       prefix=" a_access" suffix=".txt"
                                       pattern="%h %l %u %t &quot;%r&quot; %s %b" />
                        </Host>
                        <Host name="www.b.com" appBase="b" unpackWARS="true" autoDeploy="true">
                        <Context path="" docBase="base" />
                        <Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"
                                       prefix=" b_access" suffix=".txt"
                                       pattern="%h %l %u %t &quot;%r&quot; %s %b" />
                        </Host>
                        .. ..
                    2）重启Tomcat服务器
                        [root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
                        [root@web1 ~]# /usr/local/tomcat/bin/startup.sh
                    3）查看服务器日志文件
                        [root@web1 ~]# ls /usr/local/tomcat/logs/
            3.配置Tomcat集群

                    1) 在192.168.4.5主机上配置Nginx调度器（具体安装步骤参考前面的章节）
                        [root@proxy ~]# vim  /usr/local/nginx/conf/nginx.conf
                        http{
                            upstream toms {
                                server 192.168.2.100:8080;
                                server 192.168.2.200:8080;
                            }
                            server  {
                                listen 80;
                                server_name localhost;
                                location / {
                                    proxy_pass  http://toms;
                                }
                            }
                        }
                    2) 在192.168.2.100和192.168.2.200主机上配置Tomcat调度器
                        以下以Web1为例：
                        [root@web1 ~]# yum -y install  java-1.8.0-openjdk                //安装JDK
                        [root@web1 ~]# yum -y install java-1.8.0-openjdk-headless        //安装JDK
                        [root@web1 ~]# tar -xzf  apache-tomcat-8.0.30.tar.gz
                        [root@web1 ~]# mv apache-tomcat-8.0.30  /usr/local/tomcat
                    3）启动服务
                        [root@web1 ~]# /usr/local/tomcat/bin/startup.sh
                    4) 客户端验证
                        为了防止有数据缓存，可以使用真实主机的google-chrome访问代理服务器，输入Ctrl+F5刷新页面。

            4.使用Varnish加速Web
                    目标

                    通过配置Varnish缓存服务器，实现如下目标：
                    使用Varnish加速后端Web服务
                    代理服务器可以将远程的Web服务器页面缓存在本地
                    远程Web服务器对客户端用户是透明的
                    利用缓存机制提高网站的响应速度
                    使用varnishadm命令管理缓存页面
                    使用varnishstat命令查看Varnish状态
                    3.2 方案

                    通过源码编译安装Varnish缓存服务器
                    编译安装Varnish软件
                    修改配置文件，缓存代理源Web服务器，实现Web加速功能
                    使用3台RHEL7虚拟机，其中一台作为Web服务器（192.168.2.100）、一台作为Varnish代理服务器（192.168.4.5,192.168.2.5)，另外一台作为测试用的Linux客户机（192.168.4.10），如图-2所示。

                    图-2
                    对于Web服务器的部署，此实验中仅需要安装nginx或者httpd软件、启动服务，并生成测试首页文件即可，默认httpd网站根路径为/var/www/html，首页文档名称为index.html，默认nginx网站根路径为/usr/local/nginx/html，默认首页为index.html。下面的实验我们以httpd为例作为Web服务器。



                (1)构建Web服务器

                    1）使用yum安装web软件包
                        [root@web1 ~]# yum  -y  install  httpd
                    2）启用httpd服务（注意需要关闭nginx，否则端口冲突）
                        [root@web1 ~]# systemctl start httpd
                        httpd服务默认通过TCP 80端口监听客户端请求：
                        [root@web1 ~]# netstat  -anptu  |  grep httpd
                        tcp        0        0        :::80        :::*        LISTEN        2813/httpd
                    3）为Web访问建立测试文件
                        在网站根目录/var/www/html下创建一个名为index.html的首页文件：
                        [root@web1 ~]# cat /var/www/html/index.html
                        192.168.2.100
                    4）测试页面是否正常（代理服务器测试后台web）
                        [root@proxy ~]# firefox http://192.168.2.100
                (2)部署Varnish缓存服务器(192.168.4.5)

                    1）编译安装软件
                        [root@proxy ~]# yum -y install gcc readline-devel    //安装软件依赖包
                        [root@proxy ~]# yum -y install ncurses-devel         //安装软件依赖包
                        [root@proxy ~]# yum -y install pcre-devel            //安装软件依赖包
                        [root@proxy ~]# yum -y install python-docutils         //安装软件依赖包
                         [root@proxy ~]# useradd -s /sbin/nologin varnish                //创建账户
                        [root@proxy ~]# tar -xf varnish-5.2.1.tar.gz
                        [root@proxy ~]# cd varnish-5.2.1
                        [root@proxy varnish-5.2.1]# ./configure
                        [root@proxy varnish-5.2.1]# make && make install
                    2）复制启动脚本及配置文件
                        [root@proxy varnish-5.2.1]# cp  etc/example.vcl   /usr/local/etc/default.vcl
                    3）修改代理配置文件
                        [root@proxy ~]# vim  /usr/local/etc/default.vcl
                        backend default {
                             .host = "192.168.2.100";
                             .port = "80";
                         }
                    4）启动服务
                         [root@proxy ~]# varnishd  -f /usr/local/etc/default.vcl
                        //varnishd命令的其他选项说明如下：
                        //varnishd -s malloc,128M        定义varnish使用内存作为缓存，空间为128M
                        //varnishd -s file,/var/lib/varnish_storage.bin,1G 定义varnish使用文件作为缓存
                (3)客户端测试

                    1）客户端开启浏览器访问
                        [root@client ~]# curl http://192.168.4.5
                (4)其他操作

                    1）查看varnish日志
                        [root@proxy ~]# varnishlog                        //varnish日志
                        [root@proxy ~]# varnishncsa                    //访问日志
                    2）更新缓存数据，在后台web服务器更新页面内容后，用户访问代理服务器看到的还是之前的数据，说明缓存中的数据过期了需要更新（默认也会自动更新，但非实时更新）。
                        [root@proxy ~]# varnishadm
                        varnish> ban req.url ~ .*
                        //清空缓存数据，支持正则表达式
    Git

         Git基本操作
            1.配置git服务器
                目标
                安装Git软件
                创建版本库
                客户端克隆版本仓库到本地
                本地工作目录修改数据
                提交本地修改到服务器

                方案
                1）YUM安装Git软件。
                    [root@web1 ~]# yum -y install git
                    [root@web1 ~]# git --version
                2) 初始化一个空仓库。
                    [root@web1 ~]# mkdir /var/git
                    [root@web1 ~]# git init /var/git/project --bare
                    [root@web1 ~]# ls /var/git/
                    config  description  HEAD  hooks  info  objects  refs

            2. 客户端测试 192.168.2.200
                 常用指令
                    clone  将远程服务器的仓库克隆到本地
                    config 修改git配置
                    add    添加修改到暂存区
                    commit 提交修改到本地仓库
                    push   提交的远程服务器
                    checkout 切换分支
                1) clone克隆服务器仓库到本地。
                    [root@web2 ~]# yum -y install git
                    [root@web2 ~]# git clone root@192.168.2.100:/var/git/project
                    [root@web2 ~]# cd project
                    [root@web2 ~]# ls
                2) 修改git配置。
                    [root@web2 project]# git config --global user.email "you@example.com"
                    [root@web2 project]# git config --global user.name "Your Name"
                    [root@web2 project]# cat ~/.gitconfig
                    [user]
                        email = you@example.com
                        name = Your Name
                3） 本地工作区对数据进行增删改查(必须要先进入仓库再操作数据)。
                    [root@web2 project]# echo "init date" > init.txt
                    [root@web2 project]# mkdir demo
                    [root@web2 project]# cp /etc/hosts demo
                4） 查看仓库中数据的状态。
                    [root@web2 project]# git status
                5） 将工作区的修改提交到暂存区。
                    [root@web2 project]# git add .
                6) 将暂存区修改提交到本地仓库。
                    [root@web2 project]# git commit  -m  "注释，可以为任意字符"
                    [root@web2 project]# git status
                7） 将本地仓库中的数据推送到远程服务器(web2将数据推送到web1)。
                    [root@web2 project]# git config --global push.default simple
                    [root@web2 project]# git push
                    root@192.168.2.100's password:  输入服务器root密码
                    [root@web2 project]# git status
                8) 将服务器上的数据更新到本地（web1的数据更新到web2）。
                    备注：可能其他人也在修改数据并提交服务器，就会导致自己的本地数据为旧数据，使用pull就可以将服务器上新的数据更新到本地。
                    [root@web2 project]# git pull
                9) 查看版本日志。
                    [root@web2 project]# git log
                    [root@web2 project]# git log --pretty=oneline
                    [root@web2 project]# git log --oneline
                    [root@web2 project]# git reflog
                    备注：客户端也可以使用图形程序访问服务器。
            3.HEAD指针操作
                目标
                    查看Git版本信息
                    移动指针
                    通过移动HEAD指针恢复数据
                    合并版本
                方案
                    HEAD指针是一个可以在任何分支和版本移动的指针，
                    通过移动指针我们可以将数据还原至任何版本。
                    没做一次提交操作都会导致git更新一个版本，
                    HEAD指针也跟着自动移动
                HEAD指针基本操作

                1）准备工作（多对数据仓库进行修改、提交操作，以产生多个版本）。
                    [root@web2 project]# echo "new file" > new.txt
                    [root@web2 project]# git add .
                    [root@web2 project]# git commit -m "add new.txt"
                    [root@web2 project]# echo "first" >> new.txt
                    [root@web2 project]# git add .
                    [root@web2 project]# git commit -m "new.txt:first line"
                    [root@web2 project]# echo "second" >> new.txt
                    [root@web2 project]# git add .
                    [root@web2 project]# git commit -m "new.txt:second"
                    [root@web2 project]# echo "third" >> new.txt
                    [root@web2 project]# git add .
                    [root@web2 project]# git commit -m "new.txt:third"
                    [root@web2 project]# git push
                    [root@web2 project]# echo "123" > num.txt
                    [root@web2 project]# git add .
                    [root@web2 project]# git commit -m "num.txt:123"
                    [root@web2 project]# echo "456" > num.txt
                    [root@web2 project]# git add .
                    [root@web2 project]# git commit -m "num.txt:456"
                    [root@web2 project]# echo "789" > num.txt
                    [root@web2 project]# git add .
                    [root@web2 project]# git commit -m "num.txt:789"
                    [root@web2 project]# git push
                2) 查看Git版本信息。
                    [root@web2 project]# git reflog
                    [root@web2 project]# git log --oneline
                    04ddc0f num.txt:789
                    7bba57b num.txt:456
                    301c090 num.txt:123
                    b427164 new.txt:third
                    0584949 new.txt:second
                    ece2dfd new.txt:first line
                    e1112ac add new.txt
                    1a0d908 初始化
                3）移动HEAD指针，将数据还原到任意版本。
                    提示：当前HEAD指针为HEAD@{0}。
                    [root@web2 project]# git reset --hard 301c0
                    [root@web2 project]# git reflog
                    301c090 HEAD@{0}: reset: moving to 301c0
                    04ddc0f HEAD@{1}: commit: num.txt:789
                    7bba57b HEAD@{2}: commit: num.txt:456
                    301c090 HEAD@{3}: commit: num.txt:123
                    b427164 HEAD@{5}: commit: new.txt:third
                    0584949 HEAD@{6}: commit: new.txt:second
                    ece2dfd HEAD@{7}: commit: new.txt:first line
                    e1112ac HEAD@{8}: commit: add new.txt
                    1a0d908 HEAD@{9}: commit (initial): 初始化
                    [root@web2 project]# cat num.txt                #查看文件是否为123
                    123
                    [root@web2 project]# git reset --hard 7bba57b
                    [root@web2 project]# cat num.txt                #查看文件是否为123，456
                    123
                    456
                    [root@web2 project]# git reflog                #查看指针移动历史
                    7bba57b HEAD@{0}: reset: moving to 7bba57b
                    301c090 HEAD@{1}: reset: moving to 301c0
                    … …
                    [root@web2 project]# git reset --hard 04ddc0f    #恢复num.txt的所有数据
                4)模拟误删后的数据还原操作。
                    [root@web2 project]# git rm init.txt                    #删除文件
                    rm 'init.txt'
                    [root@web2 project]# git commit -m "delete init.txt"    #提交本地仓库
                    [root@web2 project]# git reflog                        #查看版本历史
                    0dc2b76 HEAD@{0}: commit: delete init.txt
                    7bba57b HEAD@{0}: reset: moving to 7bba57b
                    301c090 HEAD@{1}: reset: moving to 301c0
                    … …
                    [root@web2 project]# git reset --hard 04ddc0f            #恢复数据
                    [root@web2 project]# ls
                    demo  init.txt  new.txt  num.txt

            4.Git分支操作
                沿用上个练习，学习操作Git分支，具体要求如下：
                    查看分支
                    创建分支
                    切换分支
                    合并分支
                    解决分支的冲突
                Git支持按功能模块、时间、版本等标准创建分支，分支可以让开发分多条主线同时进行，每条主线互不影响

                常见的分支规范如下：
                    MASTER分支（MASTER是主分支，是代码的核心）。
                    DEVELOP分支（DEVELOP最新开发成果的分支）。
                    RELEASE分支（为发布新产品设置的分支）。
                    HOTFIX分支（为了修复软件BUG缺陷的分支）。
                    FEATURE分支（为开发新功能设置的分支）。

                (1)查看并创建分支

                1）查看当前分支。
                    [root@web2 project]# git status
                    # On branch master
                    nothing to commit, working directory clean
                    [root@web2 project]# git branch -v
                    * master 0dc2b76 delete init.txt
                2）创建分支。
                    [root@web2 project]# git branch hotfix
                    [root@web2 project]# git branch feature
                    [root@web2 project]# git branch -v
                      feature 0dc2b76 delete init.txt
                      hotfix  0dc2b76 delete init.txt
                    * master  0dc2b76 delete init.txt
                (2)切换与合并分支

                1）切换分支。
                    [root@web2 project]# git checkout hotfix ###切换分支
                    [root@web2 project]# git branch -v
                      feature 0dc2b76 delete init.txt
                    * hotfix  0dc2b76 delete init.txt
                    master  0dc2b76 delete init.txt
                2）在新的分支上可以继续进行数据操作（增、删、改、查）。
                    [root@web2 project]# echo "fix a bug" >> new.txt
                    [root@web2 project]# git add .
                    [root@web2 project]# git commit -m "fix a bug"
                3）将hotfix修改的数据合并到master分支。
                    注意，合并前必须要先切换到master分支，然后再执行merge命令。
                    [root@web2 project]# git checkout master
                    [root@web2 project]# cat new.txt        #默认master分支中没有hotfix分支中的数据
                    [root@web2 project]# git merge hotfix
                    Updating 0dc2b76..5b4a755
                    Fast-forward
                     new.txt | 1 ++
                     1 file changed, 1 insertions(+)
                4）将所有本地修改提交远程服务器。
                    [root@web2 project]# git push

                (3)解决版本分支的冲突问题

                1）在不同分支中修改相同文件的相同行数据，模拟数据冲突。
                    [root@web2 project]# git checkout hotfix
                    [root@web2 project]# echo "AAA" > a.txt
                    [root@web2 project]# git add .
                    [root@web2 project]# git commit -m "add a.txt by hotfix"
                    [root@web2 project]# echo "BBB" > a.txt
                    [root@web2 project]# git add .
                    [root@web2 project]# git commit -m "add a.txt by master"
                    自动合并 a.txt
                    冲突（添加/添加）：合并冲突于 a.txt
                    自动合并失败，修正冲突然后提交修正的结果。
                2）查看有冲突的文件内容，修改文件为最终版本的数据，解决冲突。
                    [root@web2 project]# cat a.txt                #该文件中包含有冲突的内容
                    <<<<<<< HEAD
                    BBB
                    =======
                    AAA
                    >>>>>>> hotfix
                    [root@web2 project]# vim a.txt              #修改该文件，为最终需要的数据，解决冲突
                    BBB
                    [root@web2 project]# git add .
                    [root@web2 project]# git commit -m "resolved"
                    总结：分支指针与HEAD指针的关系。
                    创建分支的本质是在当前提交上创建一个可以移动的指针
                    如何判断当前分支呢？答案是根据HEAD这个特殊指针



            Git服务器
                问题

                沿用练习三，学习Git不同的服务器形式，具体要求如下：
                创建SSH协议服务器
                创建Git协议服务器
                创建HTTP协议服务器
                方案

                Git支持很多服务器协议形式，不同协议的Git服务器，客户端就可以使用不同的形式访问服务器。
                创建的服务器协议有SSH协议、Git协议、HTTP协议。

            (1)：SSH协议服务器（支持读写操作）

                1）创建基于密码验证的SSH协议服务器（web1主机操作）。
                    [root@web1 ~]# git init --bare /var/git/base_ssh
                    Initialized empty Git repository in /var/git/base_ssh/
                2)客户端访问的方式（web2主机操作）。
                    [root@web2 ~]# git clone root@192.168.2.100:/var/git/base_ssh
                    [root@web2 ~]# rm -rf base_ssh
                3）客户端生成SSH密钥，实现免密码登陆git服务器（web2主机操作）。
                    [root@web2 ~]# ssh-keygen -f /root/.ssh/id_rsa -N ''
                    [root@web2 ~]# ssh-copy-id  192.168.2.100
                    [root@web2 ~]# git clone root@192.168.2.100:/var/git
                    [root@web2 ~]# git push
                (2)Git协议服务器（只读操作的服务器）

                1）安装git-daemon软件包（web1主机操作）。
                    [root@web1 ~]# yum -y install git-daemon
                2）创建版本库（web1主机操作）。
                    [root@web1 ~]# git init --bare /var/git/base_git
                    Initialized empty Git repository in /var/git/base_git/
                3）修改配置文件，启动git服务（web1主机操作）。
                    [root@web1 ~]# vim /usr/lib/systemd/system/git@.service
                    修改前内容如下：
                    ExecStart=-/usr/libexec/git-core/git-daemon --base-path=/var/lib/git
                    --export-all --user-path=public_git --syslog --inetd –verbose
                    修改后内容如下：
                    ExecStart=-/usr/libexec/git-core/git-daemon --base-path=/var/git
                    --export-all --user-path=public_git --syslog --inetd –verbose
                    [root@web1 ~]# systemctl  start  git.socket
                4）客户端访问方式（web2主机操作）
                    [root@web2 ~]# git clone git://192.168.2.100/base_git
                (3)HTTP协议服务器（只读操作的服务器）

                    1）安装gitweb、httpd软件包（web1主机操作）。
                        [root@web1 ~]# yum -y install httpd gitweb
                    2）修改配置文件，设置仓库根目录（web1主机操作）。
                        [root@web1 ~]# vim +11 /etc/gitweb.conf  ###打开文件 后进入第 11 行
                        $projectroot = "/var/git";                        #添加一行
                    3) 创建版本仓库（web1主机操作）
                        [root@web1 ~]# git init --bare /var/git/base_http
                    4）启动httpd服务器
                        [root@web1 ~]# systemctl start httpd
                    5）客户端访问方式（web2主机操作）
                        注意：调用虚拟机中的firefox浏览器，需要在远程时使用ssh -X 服务器IP，并且确保真实主机的firefox已经关闭。
                        [root@web2 ~]# firefox http://192.168.2.100/git/
         制作nginx的RPM包
            rpm就是一个压缩包
            方法
                安装 rpm-build
                1)yum -y install rpm-build
                生成 rpmbuild 目录及其文件
                2)rpmbuild -ba zone.spec
                    错误：stat /root/zone.spec 失败：没有那个文件或目录
                  ls rpmbuild/
                    BUILD  BUILDROOT  RPMS  SOURCES  SPECS  SRPMS
                想要谁的 rpm包就将 谁的源码放到/rpmbuild/source 目录下,修改配置文件(重要) 确认将谁 做成rpm包
                    cp /nginx-1.12.2.tar.gz .
                3)修改配置文件
                    vim /root/rpmbuild/SPECS/nginx.spec
                        Name:nginx                                        #源码包软件名称
                        Version:1.12.2                                    #源码包软件的版本号
                        Release:    10                                        #制作的RPM包版本号
                        Summary: Nginx is a web server software.            #RPM软件的概述
                        License:GPL                                        #软件的协议
                        URL:    www.test.com                                    #网址
                        Source0:nginx-1.12.2.tar.gz                        #源码包文件的全称
                        #BuildRequires:                                    #制作RPM时的依赖关系,并不能解决依赖只能提示
                        #Requires:                                        #安装RPM时的依赖关系
                        %description
                        nginx [engine x] is an HTTP and reverse proxy server.    #软件的详细描述
                        %post
                        useradd nginx                               #非必需操作：安装后脚本(创建账户,删根等危险操作 也可以执行,exe 同要的道理)
                        %prep
                        %setup -q                                #自动解压源码包，并cd进入目录
                        %build
                        ./configure
                        make %{?_smp_mflags}
                        %install
                        make install DESTDIR=%{buildroot}
                        %files
                        %doc
                        /usr/local/nginx/*                    #对哪些文件与目录打包
                        %changelog
                 打包 安装
                4)rpmbuild -ba /root/rpmbuild/SPECS/nginx.spec

                  yum -y install  gcc  pcre-devel openssl-devel
                5) 安装
                  rpm -ivh RPMS/x86_64/nginx-1.12.2-10.x86_64.rpm
    VPN服务器
                vpn 虚拟专用网
                    在公网上建立专用的私有网络,进行加班通信,多用于集团公司的各地子公司建立链接
                    企业中广泛用于
                    可以用于 穿墙
                    主流软件  GRE  PPTP   L2TP+IPSec,SSL
                           不加密 部分加密  全部加密
         配置GRE VPN
            linux(默认支持) window(不支持) 网络设备默认支持
            要求
                启用内核模块ip_gre
                创建一个虚拟VPN隧道(10.10.10.0/24)
                实现两台主机点到点的隧道通讯
            方法
                使用lsmod查看当前计算机已经加载的模块，使用modprobe加载Linux内核模块，
                使用modinfo可以查看内核模块的信息。
                ip 设置
                    client  eth3 201.1.2.10/24
                    proxy  eth3 201.1.2.10/24
                    proxy  eth0 192.168.4.5/24
            1.启用GRE模块（client和proxy都需要操作）

                1）查看计算机当前加载的模块
                    [root@client ~]# lsmod                            //显示模块列表
                    [root@client ~]# lsmod  | grep ip_gre            //确定是否加载了gre模块
                2)加载模块ip_gre
                    [root@client ~]# modprobe  ip_gre
                3）查看模块信息
                    [root@client ~]# modinfo ip_gre
                    filename:       /lib/modules/3.10.0-693.el7.x86_64/kernel/net/ipv4/ip_gre.ko.xz
                    alias:          netdev-gretap0
                    alias:          netdev-gre0
                    alias:          rtnl-link-gretap
                    alias:          rtnl-link-gre
                    license:        GPL
                    rhelversion:    7.4
                    srcversion:     F37A2BF90692F86E3A8BD15
                    depends:        ip_tunnel,gre
                    intree:         Y
                    vermagic:       3.10.0-693.el7.x86_64 SMP mod_unload modversions
                    signer:         CentOS Linux kernel signing key
                    sig_key:        DA:18:7D:CA:7D:BE:53:AB:05:BD:13:BD:0C:4E:21:F4:22:B6:A4:9C
                    sig_hashalgo:   sha256
                    parm:           log_ecn_error:Log packets received with corrupted ECN (bool)

            2.Client主机创建VPN隧道

                1）创建隧道
                    [root@client ~]# ip tunnel add tun0  mode gre \
                    >  remote 201.1.2.5 local 201.1.2.10
                    //ip tunnel add创建隧道（隧道名称为tun0），ip tunnel help可以查看帮助
                    //mode设置隧道使用gre模式
                    //local后面跟本机的IP地址，remote后面是与其他主机建立隧道的对方IP地址
                2）启用该隧道（类似与设置网卡up）
                    [root@client ~]# ip link show
                    [root@client ~]# ip link set tun0 up         //设置UP
                    [root@client ~]# ip link show
                3）为VPN配置隧道IP地址
                    [root@client ~]# ip addr add 10.10.10.10/24 peer 10.10.10.5/24 \
                    >  dev tun0
                    //为隧道tun0设置本地IP地址（10.10.10.10.10/24）
                    //隧道对面的主机IP的隧道IP为10.10.10.5/24
                    [root@client ~]# ip a s                      //查看IP地址
                4）关闭防火墙
                    [root@client ~]# firewall-cmd --set-default-zone=trusted

            3.Proxy主机创建VPN隧道

                1）查看计算机当前加载的模块
                    [root@client ~]# lsmod                            //显示模块列表
                    [root@client ~]# lsmod  | grep ip_gre            //确定是否加载了gre模块
                2)加载模块ip_gre
                    [root@client ~]# modprobe  ip_gre
                3）创建隧道
                    [root@proxy ~]# ~]# ip tunnel add tun0  mode gre \
                    >  remote 201.1.2.10 local 201.1.2.5
                    //ip tunnel add创建隧道（隧道名称为tun0），ip tunnel help可以查看帮助
                    //mode设置隧道使用gre模式
                    //local后面跟本机的IP地址，remote后面是与其他主机建立隧道的对方IP地址
                4）启用该隧道（类似与设置网卡up）
                    [root@proxy ~]# ip link show
                    [root@proxy ~]# ip link set tun0 up         //设置UP
                    [root@proxy ~]# ip link show
                5）为VPN配置隧道IP地址
                    [root@proxy ~]# ip addr add 10.10.10.5/24 peer 10.10.10.10/24 \
                    >  dev tun0
                    //为隧道tun0设置本地IP地址（10.10.10.10.5/24）
                    //隧道对面的主机IP的隧道IP为10.10.10.10/24
                    [root@proxy ~]# ip a s                      //查看IP地址
                6）开启路由转发、关闭防火墙
                    [root@proxy ~]# echo "1" > /proc/sys/net/ipv4/ip_forward
                    [root@proxy ~]# firewall-cmd --set-default-zone=trusted
                7)测试连通性
                    [root@client ~]#  ping 10.10.10.5
                    [root@proxy ~]#   ping 10.10.10.10


         创建PPTP VPN (W和L都支持)
                要求
                    本案例要求搭建一个PPTP VPN环境，并测试该VPN网络是否能够正常通讯，要求如下:
                    使用PPTP协议创建一个支持身份验证的隧道连接
                    使用MPPE对数据进行加密
                    为客户端分配192.168.3.0/24的地址池
                    客户端连接的用户名为jacob，密码为123456
            1.部署VPN服务器

                1）安装软件包（软件包参考lnmp_soft）
                    [root@proxy ~]# yum localinstall pptpd-1.4.0-2.el7.x86_64.rpm
                    [root@proxy ~]# rpm -qc pptpd
                    /etc/ppp/options.pptpd
                    /etc/pptpd.conf
                    /etc/sysconfig/pptpd
                2)修改配置文件
                    [root@proxy ~]# vim /etc/pptpd.conf
                    .. ..
                    localip 201.1.2.5                                    //服务器本地IP
                    remoteip 192.168.3.1-50                            //分配给客户端的IP池
                    [root@proxy ~]# vim /etc/ppp/options.pptpd
                    require-mppe-128                                    //使用MPPE加密数据
                    ms-dns 8.8.8.8                                    //DNS服务器
                    [root@proxy ~]# vim /etc/ppp/chap-secrets            //修改账户配置文件
                    jacob           *               123456      *
                    //用户名    服务器标记    密码    客户端
                    [root@proxy ~]# echo "1" > /proc/sys/net/ipv4/ip_forward    //开启路由转发
                3）启动服务
                    [root@proxy ~]# systemctl start pptpd
                    [root@proxy ~]# systemctl enable pptpd
                    [root@proxy ~]# firewall-cmd --set-default-zone=trusted
                4）翻墙设置（非必需操作）
                    [root@proxy ~]# iptables -t nat -A POSTROUTING -s 192.168.3.0/24 \
                    >  -j SNAT --to-source 201.1.2.5

                5)在Windows 上 配置 vpn 链接

         创建L2TP+IPSec VPN(W和L都支持)
                本案例要求搭建一个L2TP+IPSec VPN环境，并测试该VPN网络是否能够正常通讯，具体要求如下：
                使用L2TP协议创建一个支持身份验证与加密的隧道连接
                使用IPSec对数据进行加密
                为客户端分配192.168.3.0/24的地址池
                客户端连接的用户名为：jacob，密码为：123456
                预共享密钥为：randpass
            1.部署IPSec服务

                1）安装软件包
                    [root@client ~]# yum -y install libreswan
                2)新建IPSec密钥验证配置文件
                    [root@client ~]# cat /etc/ipsec.conf                //仅查看一下该主配置文件
                    .. ..
                    include /etc/ipsec.d/*.conf                    //加载该目录下的所有配置文件
                    [root@client ~]# vim /etc/ipsec.d/myipsec.conf
                    //新建该文件，参考lnmp_soft/vpn/myipsec.conf
                    conn IDC-PSK-NAT
                        rightsubnet=vhost:%priv                        //允许建立的VPN虚拟网络
                        also=IDC-PSK-noNAT
                    conn IDC-PSK-noNAT
                        authby=secret                                    //加密认证
                            ike=3des-sha1;modp1024                        //算法
                            phase2alg=aes256-sha1;modp2048                //算法
                        pfs=no
                        auto=add
                        keyingtries=3
                        rekey=no
                        ikelifetime=8h
                        keylife=3h
                        type=transport
                        left=201.1.2.10                                //重要，服务器本机的外网IP
                        leftprotoport=17/1701
                        right=%any                                    //允许任何客户端连接
                        rightprotoport=17/%any
                3)创建IPSec预定义共享密钥
                    [root@client ~]# cat /etc/ipsec.secrets                 //仅查看，不要修改该文件
                    include /etc/ipsec.d/*.secrets
                    [root@client ~]# vim /etc/ipsec.d/mypass.secrets        //新建该文件
                    201.1.2.10   %any:    PSK    "randpass"             //randpass为预共享密钥
                                                                    //201.1.2.10是VPN服务器的IP
                4)启动IPSec服务
                    [root@client ~]# systemctl start ipsec
                    [root@client ~]# netstat -ntulp |grep pluto
                    udp        0      0 127.0.0.1:4500          0.0.0.0:*           3148/pluto
                    udp        0      0 192.168.4.10:4500      0.0.0.0:*           3148/pluto
                    udp        0      0 201.1.2.10:4500         0.0.0.0:*           3148/pluto
                    udp        0      0 127.0.0.1:500           0.0.0.0:*           3148/pluto
                    udp        0      0 192.168.4.10:500       0.0.0.0:*           3148/pluto
                    udp        0      0 201.1.2.10:500          0.0.0.0:*           3148/pluto
                    udp6       0      0 ::1:500                 :::*                 3148/pluto

            2.部署XL2TP服务

                1）安装软件包（软件包参考lnmp_soft）
                    [root@client ~]# yum localinstall xl2tpd-1.3.8-2.el7.x86_64.rpm
                2) 修改xl2tp配置文件（修改3个配置文件的内容）
                    [root@client ~]#  vim  /etc/xl2tpd/xl2tpd.conf                //修改主配置文件
                    [global]
                    .. ..
                    [lns default]
                    .. ..
                    ip range = 192.168.3.128-192.168.3.254                    //分配给客户端的IP池
                    local ip = 201.1.2.10                                    //VPN服务器的IP地址
                    [root@client ~]# vim /etc/ppp/options.xl2tpd            //认证配置
                    require-mschap-v2                                         //添加一行，强制要求认证
                    #crtscts                                                //注释或删除该行
                    #lock                                                //注释或删除该行
                    root@client ~]# vim /etc/ppp/chap-secrets                    //修改密码文件
                    jacob   *       123456  *                //账户名称   服务器标记   密码   客户端IP
                3）启动服务
                    [root@client ~]# systemctl start xl2tpd
                    [root@client ~]# netstat  -ntulp |grep xl2tpd
                    udp     0      0 0.0.0.0:1701      0.0.0.0:*          3580/xl2tpd
                4）设置路由转发，防火墙
                    [root@client ~]# echo "1" > /proc/sys/net/ipv4/ip_forward
                    [root@client ~]# firewall-cmd --set-default-zone=trusted
                5）翻墙设置（非必需操作）
                    [root@client ~]# iptables -t nat -A POSTROUTING -s 192.168.3.0/24 \
                    >  -j SNAT --to-source 201.1.2.10





    NTP时间同步







